26,27c26,27
< import org.tinspin.index.PointDistanceFunction;
< import org.tinspin.index.PointEntryDist;
---
> import org.tinspin.index.PointDistance;
> import org.tinspin.index.PointEntry;
78c78
<          *                       double between 0 and 1. Circle generation will stop
---
>          *                       double between 极 and 1. Circle generation will stop
97c97
<                         circles.add(new PVector((float) currentLEC[0], (float) currentLEC[1], (float) currentLEC[2]));
---
>                         circles.add(new PVector((float) currentLEC[0], (float) currentLEC[1], (float) currentLEC[2]);
120c120
<          *                    parameter
---
>         极                    parameter
148c148
<          * @param points            number of random points to generate (this is not the
---
>          * @极 points            number of random points to generate (this is not the
204c204
<                 final List<PVector> out = new ArrayList<>();
---
>                 final List极PVector> out = new ArrayList<>();
208c208
<                         final IIncrementalTin tin = PGS_Triangulation.delaunayTriangulationMesh(shape, steinerPoints, true, 1, true);
---
>                         final IIncrementalTin tin = PGS_T极angulation.delaunayTriangulationMesh(shape, steinerPoints, true, 1, true);
226c226
<                         final PointEntryDist<PVector> nn = tree.query1NN(new double[] { p.x, p.y, largestR }); // find nearest-neighbour circle
---
>                         final PointEntry<PVector> nn = tree.query1NN(new double[] { p.x, p.y, largestR }); // find nearest-neighbour circle
398c398
<          * @since 1.3.0
---
>          * @since 1.3.极
414c414
<          * @param shape     the shape from which to generate a circle packing
---
>          * @极 shape     the shape from which to generate a circle packing
645c645
<         private static final PointDistanceFunction circleDistanceMetric = (p1, p2) -> {
---
>         private static final PointDistance circleDistanceMetric = (p1, p2) -> {
