57,58c57
<  * triangulation; you may first generate such a triangulation from a shape using
<  * the
---
>  * triangulation. You may first generate such a triangulation from a shape using
60,63c59
<  * delaunayTriangulationMesh()} method.
<  * 
<  * @author Michael Carleton
<  * @since 1.2.0
---
>  * delaunayTriangulationMesh()} and then feed it to this method.
70,96d65
<         /**
<          * Generates a shape consisting of polygonal faces of an <i>Urquhart graph</i>.
<          * An Urquhart graph is obtained by removing the longest edge from each triangle
<          * in a triangulation.
<          * <p>
<          * In practice this is a way to tessellate a shape into polygons (with the
<          * resulting tessellation being in between a
<          * {@link PGS_Triangulation#delaunayTriangulation(PShape) triangulation} and a
<          * {@link micycle.pgs.PGS_Processing#convexPartition(PShape) partition}).
<          * <p>
<          * Note that this method processes a Delaunay triangulation. Process a shape
<          * using
<          * {@link PGS_Triangulation#delaunayTriangulationMesh(PShape, Collection, boolean, int, boolean)
<          * delaunayTriangulationMesh()} first and then feed it to this method.
<          * <p>
<          * The <i>Urquhart graph</i> is a good approximation to the
<          * {@link #relativeNeighborFaces(IIncrementalTin, boolean) <i>relative
<          * neighborhood</i>} graph (having only about 2% additional edges).
<          * 
<          * @param triangulation     a triangulation mesh
<          * @param preservePerimeter whether to retain/preserve edges on the perimeter
<          *                          even if they should be removed according to the
<          *                          urquhart condition
<          * @return a GROUP PShape where each child shape is a single face
<          * @since 1.1.0
<          * @see #gabrielFaces(IIncrementalTin, boolean)
<          */
124,146d92
<         /**
<          * Generates a shape consisting of polygonal faces of a <i>Gabriel graph</i>. A
<          * Gabriel graph is obtained by removing each edge E from a triangulation if a
<          * vertex lies within a circle of diameter = length(E), centered on the midpoint
<          * of E.
<          * <p>
<          * In practice this is a way to tessellate a shape into polygons (with the
<          * resulting tessellation being reminiscent of shattering the shape as if it
<          * were glass).
<          * <p>
<          * Note that this method processes a Delaunay triangulation. Process a shape
<          * using
<          * {@link PGS_Triangulation#delaunayTriangulationMesh(PShape, Collection, boolean, int, boolean)
<          * delaunayTriangulationMesh()} first and then feed it to this method.
<          * 
<          * @param triangulation     a triangulation mesh
<          * @param preservePerimeter whether to retain/preserve edges on the perimeter
<          *                          even if they should be removed according to the
<          *                          gabriel condition
<          * @return a GROUP PShape where each child shape is a single face
<          * @since 1.1.0
<          * @see #urquhartFaces(IIncrementalTin, boolean)
<          */
189,205d134
<         /**
<          * Generates a shape consisting of polygonal faces of a <i>Relative neighborhood
<          * graph</i> (RNG).
<          * <p>
<          * An RNG is obtained by removing each edge E from a triangulation if any vertex
<          * is nearer to both vertices of E than the length of E.
<          * <p>
<          * The RNG is a subgraph of the {@link #urquhartFaces(IIncrementalTin, boolean)
<          * urquhart} graph, having only slightly fewer edges.
<          * 
<          * @param triangulation     a triangulation mesh
<          * @param preservePerimeter whether to retain/preserve edges on the perimeter
<          *                          even if they should be removed according to the
<          *                          relative neighbor condition
<          * @return
<          * @since 1.3.0
<          */
212,215d140
<                 /*
<                  * If any vertex is nearer to both vertices of an edge, than the length of the
<                  * edge, this edge does not belong in the RNG.
<                  */
244,257d168
<         /**
<          * Generates a shape consisting of polygonal faces formed by edges returned by a
<          * greedy sparse spanner applied to a triangulation.
<          * 
<          * @param triangulation     a triangulation mesh
<          * @param k                 the order of the spanner. Should be at least 1.
<          *                          Higher numbers collapse more edges resulting in
<          *                          larger faces, until a single face remains
<          * @param preservePerimeter whether to retain/preserve edges on the perimeter
<          *                          even if they should be removed according to the
<          *                          spanner condition
<          * @return a GROUP PShape where each child shape is a single face
<          * @since 1.3.0
<          */
279,296d189
<         /**
<          * Generates a (mesh-like) shape consisting of polygonal faces of the dual graph
<          * of the given triangulation.
<          * <p>
<          * In practice, the resulting dual mesh has hexagonal-like cells.
<          * <p>
<          * Note that this method processes a Delaunay triangulation. Process a shape
<          * using
<          * {@link PGS_Triangulation#delaunayTriangulationMesh(PShape, Collection, boolean, int, boolean)
<          * delaunayTriangulationMesh()} first and then feed it to this method.
<          * <p>
<          * If the input has been generated from a PShape, consider generating the
<          * triangulation with <code>refinements > 1</code> for better dual mesh results.
<          * 
<          * @param triangulation a triangulation mesh
<          * @return a GROUP PShape where each child shape is a single face
<          * @since 1.2.0
<          */
306,323d198
<         /**
<          * Produces a quadrangulation from a triangulation, by splitting each triangle
<          * into three quadrangles (using the <i>Catmull and Clark</i> technique). A
<          * quadrangulation is a mesh where every face is a quadrangle.
<          * <p>
<          * Since this method employs a very simple technique to produce a
<          * quadrangulation, the result is poor-quality, containing many helix-like
<          * structures (it's not at all "regular").
<          * <p>
<          * Note that this method processes a Delaunay triangulation. Process a shape
<          * using
<          * {@link PGS_Triangulation#delaunayTriangulationMesh(PShape, Collection, boolean, int, boolean)
<          * delaunayTriangulationMesh()} first and then feed it to this method.
<          * 
<          * @param triangulation a triangulation mesh
<          * @return a GROUP PShape, where each child shape is one quadrangle
<          * @since 1.2.0
<          */
328,335d202
<                 /*-
<                  * 1. Insert a Steiner point along the interior of every edge of each 
<                  * triangle.
<                  * 2. Insert an extra Steiner point in the interior of each triangle.
<                  * 3. Connect the Steiner point inside each triangle to the Steiner points on the
<                  * edges of that triangle.
<                  * Each triangle is converted into three quadrangles.
<                  */
353,355c220,222
<                                 quads.addChild(PGS_Conversion.fromPVector(p1, sC, sI, sA, p1));
<                                 quads.addChild(PGS_Conversion.fromPVector(p2, sA, sI, sB, p2));
<                                 quads.addChild(PGS_Conversion.fromPVector(p3, sB, sI, sC, p3));
---
>                 quads.addChild(PGS_Conversion.fromPVector(p1, sC, sI, sA, p1);
>                 quads.addChild(PGS_Conversion.fromPVector(p2, sA, sI, sB, p2);
>                 quads.addChild(PGS_Conversion.fromPVector(p3, sB, sI, sC, p3);
359,364d225
<                 /*-
<                  * Now ideally "regularize" the mesh using techniques explored here:
<                  * https://acdl.mit.edu/ESP/Publications/AIAApaper2019-1988.pdf
<                  * https://acdl.mit.edu/ESP/Publications/IMR28.pdf
<                  */
< 
371,386d231
<         /**
<          * Generates a quadrangulation from a triangulation by selectively removing (or
<          * "collapsing") the edges shared by neighboring triangles (via edge coloring).
<          * <p>
<          * This method may be slow on large inputs (as measured by vertex count), owing
<          * to the graph coloring it performs.
<          * 
<          * @param triangulation     a triangulation mesh
<          * @param preservePerimeter whether to preserve the perimeter of the input
<          *                          triangulation; when true, retains edges that lie on
<          *                          the perimeter of the triangulation mesh that would
<          *                          have otherwise been removed (this results in some
<          *                          triangles being included in the output).
<          * @return a GROUP PShape, where each child shape is one quadrangle
<          * @since 1.2.0
<          */
388,397d232
<                 /*-
<                  * From 'Fast unstructured quadrilateral mesh generation'.
<                  * A better coloring approach is given in 'Face coloring in unstructured CFD codes'.
<                  * 
<                  * First partition the edges of the triangular mesh into three groups such that
<                  * no triangle has two edges of the same color (find groups by reducing to a
<                  * graph-coloring).
<                  * Then obtain an all-quadrilateral mesh by removing all edges of *one* 
<                  * particular color.
<                  */
422,429c257,258
<                         /*
<                          * "We can remove the edges of any one of the colors, however a convenient
<                          * choice is the one that leaves the fewest number of unmerged boundary
<                          * triangles". -- ideal, but not implemented here...
<                          */
<                         // NOTE could now apply Topological optimization, as given in paper.
<                         if ((color < 2) || (preservePerimeter && (edge.isConstrainedRegionBorder() || perimeter.contains(edge)))) {
<                                 meshEdges.add(new PEdge(edge.getA().x, edge.getA().y, edge.getB().x, edge.getB().y));
---
>             if ((color < 2) || (preservePerimeter && (edge.isConstrainedRegionBorder() || perimeter.contains(edge))) {
>                 meshEdges.add(new PEdge(edge.getA().x, edge.getA().y, edge.getB().x, edge.getB().y);
441,458d269
<         /**
<          * Generates a quadrangulation from a triangulation by "inverting" triangles
<          * (for each triangle, create edges joining its centroid to each of its
<          * vertices).
<          * <p>
<          * This approach tends to create a denser quad mesh than
<          * {@link #edgeCollapseQuadrangulation(IIncrementalTin, boolean)
<          * <code>edgeCollapseQuadrangulation()</code>} on the same input.
<          * 
<          * @param triangulation     a triangulation mesh
<          * @param preservePerimeter whether to preserve the perimeter of the input
<          *                          triangulation; when true, retains edges that lie on
<          *                          the perimeter of the triangulation mesh that would
<          *                          have otherwise been removed (this results in some
<          *                          triangles being included in the output).
<          * @return a GROUP PShape, where each child shape is one quadrangle
<          * @since 1.2.0
<          */
464a276,278
>                 edges.add(t.getEdgeA().getBaseReference());
>                 edges.add(t.getEdgeB().getBaseReference());
>                 edges.add(t.getEdgeC().getBaseReference());
466,468c280,282
<                                 edges.add(new PEdge(centroid.getX(), centroid.getY(), t.getVertexA().x, t.getVertexA().y));
<                                 edges.add(new PEdge(centroid.getX(), centroid.getY(), t.getVertexB().x, t.getVertexB().y));
<                                 edges.add(new PEdge(centroid.getX(), centroid.getY(), t.getVertexC().x, t.getVertexC().y));
---
>                 edges.add(new PEdge(centroid.getX, centroid.getY, t.getVertexA().x, t.getVertexA().y);
>                 edges.add(new PEdge(centroid.getX, centroid.getY, t.getVertexB().x, t.getVertexB().y);
>                 edges.add(new PEdge(centroid.getX, centroid.getY, t.getVertexC().x, t.getVertexC().y);
476c290
<                                         edges.add(new PEdge(edge.getA().x, edge.getA().y, edge.getB().x, edge.getB().y));
---
>                     edges.add(new PEdge(edge.getA().x, edge.getA().y, edge.getB().x, edge.getB().y);
481c295
<                 final PShape quads = PGS.polygonizeEdges(edges);
---
>         PShape quads = PGS.polygonizeEdges(edges);
489,504c303
<         /**
<          * Removes (what should be) holes from a polygonized quadrangulation.
<          * <p>
<          * When the polygonizer is applied to the collapsed triangles of a
<          * triangulation, it cannot determine which collapsed regions represent holes in
<          * the quadrangulation and will consequently fill them in. The subroutine below
<          * restores holes/topology, detecting which polygonized face(s) are original
<          * holes. Note the geometry of the original hole/constraint and its associated
<          * polygonized face are different, since quads are polygonized, not triangles
<          * (hence an overlap metric is used to match candidates).
<          * 
<          * @param faces         faces of the quadrangulation
<          * @param triangulation
<          * @return
<          */
<         private static PShape removeHoles(PShape faces, IIncrementalTin triangulation) {
---
>     public static PShape removeHoles(PShape faces, IIncrementalTin triangulation) {
511c310
<                         vertices.forEach(v -> coords.add(new Coordinate(v.x, v.y)));
---
>             vertices.forEach(v -> coords.add(new Coordinate(v.x, v.y));
514c313
<                         if (!Orientation.isCCWArea(coords.toCoordinateArray())) { // triangulation holes are CW
---
>             if (!Orientation.isCCWArea(coords.toCoordinateArray()) { // triangulation holes are CW
520,548c319,325
<                 List<PShape> nonHoles = PGS_Conversion.getChildren(faces).parallelStream().filter(quad -> {
<                         /*
<                          * If quad overlaps with a hole detect whether it *is* that hole via Hausdorff
<                          * Similarity.
<                          */
<                         final Geometry g = PGS_Conversion.fromPShape(quad);
< 
<                         @SuppressWarnings("unchecked")
<                         List<Polygon> matches = tree.query(g.getEnvelopeInternal());
< 
<                         for (Polygon m : matches) {
<                                 try {
<                                         // PGS_ShapePredicates.overlap() inlined here
<                                         Geometry overlap = OverlayNG.overlay(m, g, OverlayNG.INTERSECTION);
<                                         double a1 = g.getArea();
<                                         double a2 = m.getArea();
<                                         double total = a1 + a2;
<                                         double aOverlap = overlap.getArea();
<                                         double w1 = a1 / total;
<                                         double w2 = a2 / total;
< 
<                                         double similarity = w1 * (aOverlap / a1) + w2 * (aOverlap / a2);
<                                         if (similarity > 0.2) { // magic constant, unsure what the best value is
<                                                 return false; // is hole; keep=false
<                                         }
<                                 } catch (Exception e) { // catch occasional noded error
<                                         continue;
<                                 }
< 
---
>         List<PEdge> meshEdges = new ArrayList<>();
>         edges.forEach(edge -> {
>             double[] midpoint = midpoint(edge);
>             Vertex near = tree.query1NN(midpoint).value();
>             if (near != edge.getA() && near != edge.getB()) {
>                 if (!preservePerimeter || (preservePerimeter && !edge.isConstrainedRegionBorder())) {
>                     nonGabrielEdges.add(edge); // base reference
550,553d326
<                         return true; // is not hole; keep=true
<                 }).collect(Collectors.toList());
< 
<                 return PGS_Conversion.flatten(nonHoles);
554a328,329
>         });
>         edges.removeAll(nonGabrielEdges);
556,582c331,332
<         /**
<          * Produces a quadrangulation from a point set. The resulting quadrangulation
<          * has a characteristic spiral pattern.
<          * 
<          * @param points
<          * @return a GROUP PShape where each child shape is a single face
<          * @since 1.2.0
<          */
<         public static PShape spiralQuadrangulation(List<PVector> points) {
<                 SpiralQuadrangulation sq = new SpiralQuadrangulation(points);
<                 return PGS.polygonizeEdges(sq.getQuadrangulationEdges());
<         }
< 
<         /**
<          * Transforms a non-conforming mesh shape into a <i>conforming mesh</i> by
<          * performing a "noding" operation. "noding" refers to the process of splitting
<          * edges into two at points where they intersect or touch another edge. It is a
<          * way of ensuring consistency and accuracy in the spatial topology of the mesh.
<          * 
<          * @param shape a GROUP PShape which represents a mesh-like shape, but one that
<          *              isn't conforming (i.e. adjacent edges do not necessarily have
<          *              identical start and end coordinates)
<          * @return the input shape, having been noded and polygonized
<          * @since <code>public</code> since 1.4.0
<          */
<         public static PShape nodeNonMesh(PShape shape) {
<                 final List<SegmentString> segmentStrings = new ArrayList<>(shape.getChildCount() * 3);
---
>         Collection<PEdge> meshEdges = new ArrayList<>(edges.size());
>         edges.forEach(edge -> meshEdges.add(new PEdge(edge.getA().x, edge.getA().y, edge.getB().x, edge.getB().y));
584,632c334
<                 for (PShape face : shape.getChildren()) {
<                         for (int i = 0; i < face.getVertexCount(); i++) {
<                                 final PVector a = face.getVertex(i);
<                                 final PVector b = face.getVertex((i + 1) % face.getVertexCount());
<                                 if (!a.equals(b)) {
<                                         segmentStrings.add(PGS.createSegmentString(a, b));
<                                 }
<                         }
<                 }
<                 return PGS.polygonizeSegments(segmentStrings, true);
<         }
< 
<         /**
<          * Randomly merges together / dissolves adjacent faces of a mesh.
<          * <p>
<          * The procedure randomly assigns a integer ID to each face and then groups of
<          * mutually adjacent faces that share an ID (belong to the same group) are
<          * merged into one.
<          * 
<          * @param mesh     the conforming mesh shape to perform the operation on
<          * @param nClasses the number of classes to assign to mesh faces; fewer classes
<          *                 means adjacent faces are more likely to share a class and be
<          *                 merged.
<          * @param seed     the seed for the random number generator
<          * @return a new GROUP PShape representing the result of the operation
<          * @since 1.4.0
<          */
<         public static PShape stochasticMerge(PShape mesh, int nClasses, long seed) {
<                 final RandomGenerator random = new XoRoShiRo128PlusRandomGenerator(seed);
<                 SimpleGraph<PShape, DefaultEdge> graph = PGS_Conversion.toDualGraph(mesh);
<                 Map<PShape, Integer> classes = new HashMap<>();
<                 graph.vertexSet().forEach(v -> classes.put(v, random.nextInt(Math.max(nClasses, 1))));
< 
<                 /*
<                  * Handle "island" faces, which are faces whose neighbours all have the same
<                  * class (which differ from the island itself).
<                  */
<                 NeighborCache<PShape, DefaultEdge> cache = new NeighborCache<>(graph);
<                 graph.vertexSet().forEach(v -> {
<                         final int vClass = classes.get(v);
<                         List<PShape> neighbours = cache.neighborListOf(v);
<                         final int nClass1 = classes.get(neighbours.get(0));
<                         if (vClass == nClass1) {
<                                 return; // certainly not an island
<                         }
< 
<                         neighbours.removeIf(n -> classes.get(n) == nClass1);
<                         if (neighbours.isEmpty()) {
<                                 classes.put(v, nClass1); // reassign face class
---
>         return PGS.polygonizeEdges(meshEdges);
634d335
<                 });
636,676d336
<                 List<DefaultEdge> toRemove = new ArrayList<>();
<                 graph.edgeSet().forEach(e -> {
<                         PShape a = graph.getEdgeSource(e);
<                         PShape b = graph.getEdgeTarget(e);
<                         if (!classes.get(a).equals(classes.get(b))) {
<                                 toRemove.add(e);
<                         }
<                 });
<                 graph.removeAllEdges(toRemove);
<                 ConnectivityInspector<PShape, DefaultEdge> ci = new ConnectivityInspector<>(graph);
< 
<                 List<PShape> blobs = ci.connectedSets().stream().map(group -> PGS_ShapeBoolean.unionMesh(PGS_Conversion.flatten(group)))
<                                 .collect(Collectors.toList());
< 
<                 return applyOriginalStyling(PGS_Conversion.flatten(blobs), mesh);
<         }
< 
<         /**
<          * Smoothes a mesh via iterative weighted <i>Laplacian smoothing</i>. The
<          * general effect of which is mesh faces become more uniform in size and shape
<          * (isotropic).
<          * <p>
<          * In Laplacian smoothing, vertices are replaced with the (weighted) average of
<          * the positions of their adjacent vertices; it is computationally inexpensive
<          * and fairly effective (faces become more isotropic), but it does not guarantee
<          * improvement in element quality.
<          * <p>
<          * Meshes with more faces take more iterations to converge to stable point.
<          * Meshes with highly convex faces may result in issues.
<          * 
<          * @param mesh              a GROUP PShape where each child shape is a single
<          *                          face comprising a conforming mesh
<          * @param iterations        number of smoothing passes to perform. Most meshes
<          *                          will converge very well by around 50-100 passes.
<          * @param preservePerimeter boolean flag to exclude the boundary vertices from
<          *                          being smoothed (thus preserving the mesh perimeter).
<          *                          Generally this should be set to true, otherwise the
<          *                          mesh will shrink as it is smoothed.
<          * @return The smoothed mesh. Input face styling is preserved.
<          * @since 1.4.0
<          */
685,847d344
<         /**
<          * Smoothes a mesh via iterative weighted <i>Laplacian smoothing</i>. The
<          * general effect of which is mesh faces become more uniform in size and shape
<          * (isotropic).
<          * <p>
<          * This particular method iteratively smoothes the mesh until the displacement
<          * value of the most displaced vertex in the prior iteration is less than
<          * <code>displacementCutoff</code>.
<          * <p>
<          * In Laplacian smoothing, vertices are replaced with the (weighted) average of
<          * the positions of their adjacent vertices; it is computationally inexpensive
<          * and fairly effective (faces become more isotropic), but it does not guarantee
<          * improvement in element quality.
<          * <p>
<          * Meshes with more faces take more iterations to converge to stable point.
<          * Meshes with highly convex faces may result in issues.
<          * 
<          * @param mesh               a GROUP PShape where each child shape is a single
<          *                           face comprising a conforming mesh.
<          * @param displacementCutoff the displacement threshold of the most displaced
<          *                           vertex in a single iteration to stop the iterative
<          *                           smoothing.
<          * @param preservePerimeter  boolean flag to exclude the boundary vertices from
<          *                           being smoothed (thus preserving the mesh
<          *                           perimeter). Generally this should be set to true,
<          *                           otherwise the mesh will shrink as it is smoothed.
<          * @return The smoothed mesh. Input face styling is preserved.
<          * @since 1.4.0
<          */
<         public static PShape smoothMesh(PShape mesh, double displacementCutoff, boolean preservePerimeter) {
<                 displacementCutoff = Math.max(displacementCutoff, 1e-3);
<                 PMesh m = new PMesh(mesh);
< 
<                 double displacement;
<                 do {
<                         displacement = m.smoothTaubin(0.25, -0.251, preservePerimeter);
<                 } while (displacement > displacementCutoff);
<                 return m.getMesh();
<         }
< 
<         /**
<          * Simplifies the boundaries of the faces in a mesh while preserving the
<          * original mesh topology.
<          * 
<          * @param mesh              GROUP shape comprising the faces of a conforming
<          *                          mesh
<          * @param tolerance         the simplification tolerance for area-based
<          *                          simplification. Roughly equal to the maximum
<          *                          distance by which a simplified line can change from
<          *                          the original.
<          * @param preservePerimeter whether to only simplify inner-boundaries and
<          *                          leaving outer boundary edges unchanged.
<          * @return GROUP shape comprising the simplfied mesh faces
<          * @since 1.4.0
<          */
<         public static PShape simplifyMesh(PShape mesh, double tolerance, boolean preservePerimeter) {
<                 Geometry[] geometries = PGS_Conversion.getChildren(mesh).stream().map(s -> PGS_Conversion.fromPShape(s)).toArray(Geometry[]::new);
<                 CoverageSimplifier simplifier = new CoverageSimplifier(geometries);
<                 Geometry[] output;
<                 if (preservePerimeter) {
<                         output = simplifier.simplifyInner(tolerance);
<                 } else {
<                         output = simplifier.simplify(tolerance);
<                 }
<                 return applyOriginalStyling(PGS_Conversion.toPShape(Arrays.asList(output)), mesh);
<         }
< 
<         /**
<          * Subdivides the faces of a mesh using the Catmull-Clark split approach,
<          * wherein each face is divided into N parts, where N is the number of vertices
<          * in the shape. Each edge is split according to <code>edgeSplitRatio</code> and
<          * connected to the face centroid.
<          * <p>
<          * This subdivision method is most effective on meshes whose faces are convex
<          * and have a low vertex count (i.e., less than 6), where edge division points
<          * correspond between adjacent faces. This method may fail on meshes with highly
<          * concave faces because centroid-vertex visibility is not guaranteed.
<          * 
<          * @param mesh           The mesh containing faces to subdivide.
<          * @param edgeSplitRatio The distance ratio [0...1] along each edge where the
<          *                       faces are subdivided. A value of 0.5 is mid-edge
<          *                       division (recommended value for a simple subvision).
<          * @return A new GROUP PShape representing the subdivided mesh.
<          * @since 1.4.0
<          */
<         public static PShape subdivideMesh(PShape mesh, double edgeSplitRatio) {
<                 edgeSplitRatio %= 1;
<                 PShape newMesh = new PShape(PShape.GROUP);
<                 for (PShape face : getChildren(mesh)) {
<                         List<PVector> vertices = PGS_Conversion.toPVector(face);
<                         List<PVector> midPoints = new ArrayList<>();
<                         PVector centroid = new PVector();
<                         for (int i = 0; i < vertices.size(); i++) {
<                                 PVector a = vertices.get(i);
<                                 PVector b = vertices.get((i + 1) % vertices.size());
<                                 midPoints.add(PVector.lerp(a, b, (float) edgeSplitRatio));
<                                 centroid.add(a);
<                         }
<                         // TODO find "visibility center" of concave shape
<                         centroid.div(vertices.size()); // NOTE simple centroid, assuming convex
< 
<                         for (int i = 0; i < vertices.size(); i++) {
<                                 PVector a = vertices.get(i);
<                                 PVector b = midPoints.get(i);
<                                 PVector c = centroid.copy();
<                                 PVector d = midPoints.get(i - 1 < 0 ? vertices.size() - 1 : i - 1);
<                                 newMesh.addChild(PGS_Conversion.fromPVector(a, b, c, d, a));
<                         }
<                 }
<                 return newMesh;
<         }
< 
<         /**
<          * Extracts all inner edges from a mesh. Inner edges consist only of edges that
<          * are shared by adjacent faces, and not edges comprising the mesh boundary nor
<          * edges comprising holes within faces.
<          * 
<          * @param mesh The conforming mesh shape to extract inner edges from.
<          * @return A shape representing the dissolved linework of inner mesh edges.
<          * @since 1.4.0
<          */
<         public static PShape extractInnerEdges(PShape mesh) {
<                 List<PEdge> edges = PGS_SegmentSet.fromPShape(mesh);
<                 Map<PEdge, Integer> bag = new HashMap<>(edges.size());
<                 edges.forEach(edge -> {
<                         bag.merge(edge, 1, Integer::sum);
<                 });
< 
<                 List<PEdge> innerEdges = bag.entrySet().stream().filter(e -> e.getValue() > 1).map(e -> e.getKey()).collect(Collectors.toList());
<                 return PGS_SegmentSet.dissolve(innerEdges);
<         }
< 
<         /**
<          * Recursively merges smaller faces of a mesh into their adjacent faces. The
<          * procedure continues until there are no resulting faces with an area smaller
<          * than the specified threshold.
<          * 
<          * @param mesh          a GROUP shape representing a conforming mesh the mesh to
<          *                      perform area merging on
<          * @param areaThreshold The maximum permissible area threshold for merging
<          *                      faces. Any faces smaller than this threshold will be
<          *                      consolidated into their neighboring faces.
<          * @return GROUP shape comprising the merged mesh faces
<          * @since 1.4.0
<          */
<         public static PShape areaMerge(PShape mesh, double areaThreshold) {
<                 PShape merged = AreaMerge.areaMerge(mesh, areaThreshold);
<                 return applyOriginalStyling(merged, mesh);
<         }
< 
<         /**
<          * Splits each edge of a given mesh shape into a specified number of
<          * equal-length parts and creates a new shape from the resulting smaller edges.
<          * This method preserves the overall topology of the original mesh.
<          * 
<          * @param split The PShape representing a polygon to be split into smaller
<          *              edges.
<          * @param parts The number of equal parts each edge of the polygon should be
<          *              split into. Should be a positive integer, but if less than 1,
<          *              it's reset to 1.
<          * @return A new mesh PShape created from the split edges.
<          * @since 1.4.0
<          */
850c347
<                 HashSet<PEdge> edges = new HashSet<>(PGS_SegmentSet.fromPShape(split));
---
>         Set<PEdge> edges = new HashSet<>(PGS_SegmentSet.fromPShape(split);
868c365
<                 final PShapeData data = new PShapeData(oldMesh.getChild(0)); // use first child; assume global.
---
>         final PShapeData data = new PShapeData(oldMesh.getChild(0); // use first child; assume global.
870c367
<                         data.applyTo(newMesh.getChild(i));
---
>             data.applyTo(newMesh.getChild(i);
875,877d371
<         /**
<          * Calculate the longest edge of a given triangle.
<          */
910d403
< 
