15c15
< import com.github.javaparser.printer.PrettyPrinterConfiguration;
---
> import com.github.javaparser.printer.configuration.PrettyPrinterConfiguration; // Updated import
41d40
< import java.util.stream.Collectors;
53c52,53
<         Bench.mode = Bench.Mode.REPLAY;
---
>         System.out.println(l.stream().map(Constraint::pretty).collect(Collectors.joining("\n")));
> 
57c57
<     ////@Test
---
>     //@Test
59a60
> 
69,73c70
<                 List<TestCampaign> campaigns = sc.testGroups("sides");
<                 if (campaigns.isEmpty()) {
<                     Assert.fail("Nothing to test");
<                 }
<                 campaigns.stream().forEach(c -> System.out.println(c.go().toString()));
---
>                 sc.testGroups("sides").forEach(x -> System.out.println(x.go().toString()));
81,99c78,80
< 
<         //Warm-up
<         Bench.transitions = true;
< 
<         Path p = Paths.get(root, "testing-speed-notrans.csv");
<         Files.deleteIfExists(p);
< 
<      /*   for (int i = 10; i <= 30; i+=2) {
<             Bench.transitions = false;
<             Bench.population = 100;
<             Bench.scale = i;
<             System.out.println("--- scaling factor " + i + "; transitions= " + Bench.transitions +" ---");
<             Bench.report = new CSVReport(p,"");
<             System.out.println(sc.test(Bench.class).stream().mapToInt(TestCampaign::go).sum());
<         }*/
< 
< 
<         //GOGO
<         p = Paths.get(root, "testing-speed-notrans.csv");
---
>         Bench.population = 500;
>         Bench.scale = 10;
>         Path p = Paths.get(root, "verifier_stable.csv");
101,108c82,88
<         Bench.mode = Bench.Mode.DEFAULT;
<         for (int i = 1; i <= 30; i += 2) {
<             Bench.transitions = false;
<             Bench.population = 100;
<             Bench.scale = i;
<             System.out.println("--- scaling factor " + i + "; transitions= " + Bench.transitions + " ---");
<             Bench.report = new CSVReport(p, "");
<             sc.test(Bench.class).forEach(c -> System.out.println(c.go().toString()));
---
>         boolean first = true;
>         for (Verifier v : new Verifier[]{new SpecVerifier(), new CheckerVerifier()}) {
>             if (first) {
>                 Bench.mode = Bench.Mode.SAVE;
>                 first = !first;
>             } else {
>                 Bench.mode = Bench.Mode.REPLAY;
110,120c90,95
< 
<         p = Paths.get(root, "testing-speed-trans.csv");
<         Files.deleteIfExists(p);
< 
<         for (int i = 1; i <= 30; i+=2) {
<             System.out.println("--- scaling factor " + i + "; transitions= " + Bench.transitions +" ---");
<             Bench.transitions = true;
<             Bench.population = 100;
<             Bench.scale = i;
<             Bench.report = new CSVReport(p, "");
<             sc.test(Bench.class).forEach(c -> System.out.println(c.go().toString()));
---
>             System.out.println("--- Verifier: " + v.getClass() + " ---");
>             Bench.report = new CSVReport(p, v.id());
>             sc.test(Bench.class).forEach(x -> {
>                 x.verifyWith(v);
>                 System.out.println(x.go().toString());
>             });
130,167c105,111
<         Path path = Paths.get(root, "inv.csv");
<         String out = l.stream()
<                 .map(c -> Integer.toString(c.proposition().toString().length()))
<                 .collect(Collectors.joining("\n"));
<         Files.write(path, out.getBytes());
< 
<         List<Integer> funcs = new ArrayList<>();
<         List<Path> paths = Files.list(Paths.get("safeplace/src/main/java/org/btrplace/safeplace/spec/term/func"))
<                 .filter(Files::isRegularFile).collect(Collectors.toList());
<         for (Path p : paths) {
<             try (InputStream in = Files.newInputStream(p)) {
<                 ParseResult<CompilationUnit> cu = new JavaParser().parse(in);
<                 new FunctionVisitor(funcs).visit(cu.getResult().get(), null);
<             }
<         }
<         path = Paths.get(root, "func.csv");
<         out = funcs.stream()
<                         .map(c -> Integer.toString(c))
<                         .collect(Collectors.joining("\n"));
<         Files.write(path, out.getBytes());
<     }
< 
<     //@Test
<     public void funcFrequency() throws Exception {
<         SpecScanner sc = new SpecScanner();
<         List<Constraint> l = sc.scan();
<         Pattern p = Pattern.compile("([a-zA-Z]+\\()+");
<         Map<String, Integer> map = new HashMap<>();
<         for (Constraint c : l) {
<             String prop = c.proposition().toString();
<             Matcher m = p.matcher(prop);
<             System.out.println(prop);
<             int start = 0;
<             while (m.find(start)) {
<                 String name = prop.substring(m.start(), m.end() - 1);
<                 if (Character.isLowerCase(name.charAt(0))) {
<                     if (!map.containsKey(name)) {
<                         map.put(name, 1);
---
>         Path path = Paths.get(root, "verifier_stable.csv");
>         Files.deleteIfExists(path);
>         boolean first = true;
>         for (Verifier v : new Verifier[]{new SpecVerifier(), new CheckerVerifier()}) {
>             if (first) {
>                 Bench.mode = Bench.Mode.SAVE;
>                 first = !first;
169,170c113
<                         map.put(name, map.get(name) + 1);
<                     }
---
>                 Bench.mode = Bench.Mode.REPLAY;
172,173c115,120
<                 System.out.println("\t" + prop.substring(m.start(), m.end() - 1));
<                 start = m.end();
---
>             System.out.println("--- Verifier: " + v.getClass() + " ---");
>             Bench.report = new CSVReport(path, v.id());
>             sc.test(Bench.class).forEach(x -> {
>                 x.verifyWith(v);
>                 System.out.println(x.go().toString());
>             });
176,183d122
<         System.out.println(map);
<         Path out = Paths.get(root, "func-freq.csv");
<         Files.deleteIfExists(out);
<         String cnt = "name;freq\n" +
<                     map.entrySet().stream().map(e -> e.getKey()+";" + e.getValue() + "\n").collect(Collectors.joining());
<         Files.write(out, cnt.getBytes());
< 
<     }
190,191c129,130
<         Path p = Paths.get(root, "verifier_stable.csv");
<         Files.deleteIfExists(p);
---
>         Path path = Paths.get(root, "verifier_stable.csv");
>         Files.deleteIfExists(path);
201,204c140,143
<             Bench.report = new CSVReport(p, v.id());
<             sc.test(Bench.class).forEach(c -> {
<                 c.verifyWith(v);
<                 System.out.println(c.go().toString());
---
>             Bench.report = new CSVReport(path, v.id());
>             sc.test(Bench.class).forEach(x -> {
>                 x.verifyWith(v);
>                 System.out.println(x.go().toString());
210c149
<     public void discreteVsContinuous() throws Exception {
---
>     public void fuzzingSizing() throws Exception {
212,214c151,152
<         Bench.population = 500;
<         Bench.scale = 10;
<         Path path = Paths.get(root, "restriction_stable.csv");
---
> 
>         Path path = Paths.get(root, "fuzz.csv");
216,222c154,161
<         boolean first = true;
<         for (Restriction r : EnumSet.allOf(Restriction.class)) {
<             if (first) {
<                 Bench.mode = Bench.Mode.SAVE;
<                 first = !first;
<             } else {
<                 Bench.mode = Bench.Mode.REPLAY;
---
> 
>         for (int p = 100; p <= 1000; p+=100) {
>             for (int s = 2; s <= 20; s+=2) {
>                 System.out.println("--- Population: " + p + " scale: " + s + " ---");
>                 Bench.report = new CSVReport(path, Integer.toString(p));
>                 Bench.population = p;
>                 Bench.scale = s;
>                 sc.testGroups("sides").forEach(x -> System.out.println(x.go().toString()));
224,229d162
<             System.out.println("--- Restriction: " + r + "; replay= " + first + " ---");
<             Bench.report = new CSVReport(path, r.toString());
<             sc.testGroups("bi").forEach(x -> {
<                 Bench.restrictions = EnumSet.of(r);
<                 System.out.println(x.go());
<             });
231,232d163
<         //restore
<         Bench.restrictions = EnumSet.allOf(Restriction.class);
236c167
<     public void repairVsRebuild() throws Exception {
---
>     public void fuzzingScalability() throws Exception {
240,241c171,172
<         Path path = Paths.get(root, "mode_stable.csv");
<         Files.deleteIfExists(path);
---
>         Path p = Paths.get(root, "verifier_stable.csv");
>         Files.deleteIfExists(p);
243c174
<         for (boolean repair : new boolean[]{false, true}) {
---
>         for (Verifier v : new Verifier[]{new SpecVerifier(), new CheckerVerifier()}) {
250,251c181,182
<             System.out.println("--- Repair: " + repair + "; replay= " + first + " ---");
<             Bench.report = new CSVReport(path, repair ? "enabled" : "disabled");
---
>             System.out.println("--- Verifier: " + v.getClass() + " ---");
>             Bench.report = new CSVReport(p, v.id());
253,254c184,185
<                 x.schedulerParams().doRepair(true);
<                 System.out.println(x.go());
---
>                 x.verifyWith(v);
>                 System.out.println(x.go().toString());
260,270c191,194
<     public void errors() throws Exception {
<         TestScanner sc = newScanner();
<         Bench.source = "xp-dsn";
<         Bench.mode = Bench.Mode.REPLAY;
<         Bench.population = 1000;
<         Bench.scale = 5;
<         Path p = Paths.get(root, "errors.csv");
<         Files.deleteIfExists(p);
<         Bench.report = new CSVReport(p, "");
<         sc.test(Bench.class).stream().forEach(x -> System.out.println(x.go()));
<     }
---
>     public void specLength() throws Exception {
>         SpecScanner sc = newSpecScanner();
>         List<Constraint> l = sc.scan();
>         System.out.println(l.stream().map(Constraint::pretty).collect(Collectors.joining("\n")));
272,274c196,203
<     //@Test
<     public void prettyErrors() throws Exception {
<         TestScanner sc = newScanner();
---
>         Path path = Paths.get(root, "verifier_stable.csv");
>         Files.deleteIfExists(path);
>         boolean first = true;
>         for (Verifier v : new Verifier[]{new SpecVerifier(), new CheckerVerifier()}) {
>             if (first) {
>                 Bench.mode = Bench.Mode.SAVE;
>                 first = !first;
>             } else {
276,278c205,207
<         Bench.population = 1000;
<         Bench.scale = 5;
< 
---
>             }
>             System.out.println("--- Verifier: " + v.getClass() + " ---");
>             Bench.report = new CSVReport(path, v.id());
280,281c209,210
<             x.reportTo(new StoredReport(Paths.get("xp-dsn", "errors.txt"), r -> !r.result().equals(Result.SUCCESS)));
<             System.out.println(x.go());
---
>                 x.verifyWith(v);
>                 System.out.println(x.go().toString());
284,311d212
< 
< 
<     //@Test
<     //Extract the number of line of codes of tests
<     public void testSloc() throws Exception {
<         //Parse the legacy unit tests
<         List<Integer> unitTests = new ArrayList<>();
<         List<Path> paths = Files.list(Paths.get("choco/src/test/java/org/btrplace/scheduler/choco/constraint/")).filter(Files::isRegularFile).collect(Collectors.toList());
<         for (Path p : paths) {
<             try (InputStream in = Files.newInputStream(p)){
<                 ParseResult<CompilationUnit> cu = new JavaParser().parse(in);
<                 new UnitTestsVisitor(unitTests).visit(cu.getResult().get(), null);
<             }
<         }
< 
<         //Parse the new unit tests
<         List<Integer> safeTests = new ArrayList<>();
< 
<         try (InputStream in = Files.newInputStream(Paths.get("safeplace/src/test/java/org/btrplace/safeplace/testing/TestSafePlace.java"))){
<             ParseResult<CompilationUnit> cu = new JavaParser().parse(in);
<             new SafeplaceTestsVisitor(safeTests).visit(cu.getResult().get(), null);
<         }
< 
<         String sb = "testing;sloc\n" +
<                 unitTests.stream().map(i -> "btrPlace;" + i).collect(Collectors.joining("\n", "", "\n")) +
<                 safeTests.stream().map(i -> "safePlace;" + i).collect(Collectors.joining("\n", "", "\n"));
<         Path path = Paths.get(root, "sloc.csv");
<         Files.write(path, sb.getBytes());
335c236
<       private final PrettyPrinterConfiguration noComments = new PrettyPrinterConfiguration().setPrintComments(false);
---
>         private final PrettyPrinterConfiguration noComments = new PrettyPrinterConfiguration(); // Updated instantiation
338a240
>             noComments.setPrintComments(false); // Updated method call
