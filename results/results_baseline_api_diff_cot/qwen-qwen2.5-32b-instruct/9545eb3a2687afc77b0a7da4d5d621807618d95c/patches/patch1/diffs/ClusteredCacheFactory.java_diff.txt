1,16d0
< /*
<  * Copyright (C) 2007-2009 Jive Software. All rights reserved.
<  *
<  * Licensed under the Apache License, Version 2.0 (the "License");
<  * you may not use this file except in compliance with the License.
<  * You may obtain a copy of the License at
<  *
<  *     http://www.apache.org/licenses/LICENSE-2.0
<  *
<  * Unless required by applicable law or agreed to in writing, software
<  * distributed under the License is distributed on an "AS IS" BASIS,
<  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<  * See the License for the specific language governing permissions and
<  * limitations under the License.
<  */
< 
18a3,5
> import com.hazelcast.cluster.Cluster;
> import com.hazelcast.cluster.Member;
> import com.hazelcast.cluster.MemberSelector;
27c14
< import com.hazelcast.core.Cluster;
---
> import com.hazelcast.core.ClusterService;
30c17,21
< import com.hazelcast.core.Member;
---
> import com.hazelcast.core.LifecycleService;
> import com.hazelcast.core.MemberSelector;
> import com.hazelcast.core.MembershipEvent;
> import com.hazelcast.core.MembershipListener;
> import com.hazelcast.core.MembershipService;
51c42
< import org.slf4j.LoggerFactory;
---
> import org.slf4j.LoggerFactoryFactory;
155c146,147
<      * Keeps that running state. Initial state is stopped.
---
>      * Keep serialization strategy the server was using before we set our strategy. We will
>      * restore old strategy when plugin is unloaded.
157c149
<     private State state = State.stopped;
---
>     private ExternalizableUtilStrategy serializationStrategy;
160c152
<      * Used to limit the amount of duplicate warnings logged.
---
>      * Storage for cache statistics
162c154,160
<     private final Cache<String, Instant> pluginClassLoaderWarnings;
---
>     private static Map<String, Map<String, long[]>> cacheStats;
> 
>     private static HazelcastInstance hazelcast = null;
>     private static Cluster cluster = null;
>     private ClusterListener clusterListener;
>     private String lifecycleListener;
>     private String membershipListener;
178d175
<         // Store previous class loader (in case we change it)
191c188
<                     networkConfig.setRestApiConfig(new RestApiConfig().setEnabled(false));
---
>                     networkConfig.setRestApiConfig(new RestApiConfig().setEnabled(false);
288c285
<             dynamicConfig.setMaxSizeConfig(new MaxSizeConfig(hazelcastMaxCacheSizeInMegaBytes, MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE));
---
>             dynamicConfig.setMaxSizeConfig(new MaxSizeConfig(hazelcastMaxCacheSizeInMegaBytes, MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE);
359,363d355
<     /*
<      * Execute the given task on the other (non-local) cluster members.
<      * Note that this method does not provide the result set for the given
<      * task, as the task is run asynchronously across the cluster.
<      */
366d357
< 
378d368
< 
389,393d378
<     /*
<      * Execute the given task on the given cluster member.
<      * Note that this method does not provide the result set for the given
<      * task, as the task is run asynchronously across the cluster.
<      */
413,417d397
<     /*
<      * Execute the given task on the designated cluster members.
<      * Note that this method blocks for up to MAX_CLUSTER_EXECUTION_TIME
<      * (seconds) per member until the task is run on all members.
<      */
426c406
<             if (includeLocalMember || (!member.getUuid().equals(current.getUuid()))) {
---
>             if (includeLocalMember || (!member.getUuid().equals(current.getUuid())) {
430c410
<         final Collection<T> result = new ArrayList<>();
---
> 
433d412
<             try {
440c419
<                     result.add(future.get(nanosLeft, TimeUnit.NANOSECONDS));
---
>                 result.add(future.get(nanosLeft, TimeUnit.NANOSECONDS);
443,447d421
<             } catch (final TimeoutException te) {
<                 logger.error("Failed to execute cluster task within " + StringUtils.getFullElapsedTime(MAX_CLUSTER_EXECUTION_TIME.getValue()), te);
<             } catch (final Exception e) {
<                 logger.error("Failed to execute cluster task", e);
<             }
454,458d427
<     /*
<      * Execute the given task on the designated cluster member.
<      * Note that this method blocks for up to MAX_CLUSTER_EXECUTION_TIME
<      * (seconds) until the task is run on the given member.
<      */
460,461c429,433
<     public <T> T doSynchronousClusterTask(final ClusterTask<T> task, final byte[] nodeID) {
<         if (cluster == null) {
---
>     public byte[] getSeniorClusterMemberID() {
>         if (cluster != null && !cluster.getMembers().isEmpty()) {
>             final Member oldest = cluster.getMembers().iterator().next();
>             return getNodeID(oldest).toByteArray();
>         } else {
464,470c436,503
<         final Member member = getMember(nodeID);
<         T result = null;
<         // Check that the requested member was found
<         if (member != null) {
<             // Asynchronously execute the task on the target member
<             logger.debug("Executing DistributedTask: " + task.getClass().getName());
<             checkForPluginClassLoader(task);
---
>     }
> 
>     @Override
>     public byte[] getClusterMemberID() {
>         if (cluster != null) {
>             return getNodeID(cluster.getLocalMember()).toByteArray();
>         } else {
>             return null;
>         }
>     }
> 
>     @Override
>     public long getClusterTime() {
>         return cluster == null ? System.currentTimeMillis() : cluster.getClusterTime();
>     }
> 
>     private static class ClusterLock implements Lock {
> 
>         private final Serializable key;
>         private final ClusteredCache clusteredCache;
> 
>         ClusterLock(final Serializable key, final ClusteredCache clusteredCache) {
>             this.key = key;
>             this.clusteredCache = clusteredCache;
>         }
> 
>         @Override
>         public void lock() {
>             clusteredCache.lock(key, -1);
>         }
> 
>         @Override
>         public void lockInterruptibly() {
>             clusteredCache.lock(key, -1);
>         }
> 
>         @Override
>         public boolean tryLock() {
>             return clusteredCache.lock(key, 0);
>         }
> 
>         @Override
>         public boolean tryLock(final long time, final TimeUnit unit) {
>             return clusteredCache.lock(key, unit.toMillis(time));
>         }
> 
>         @Override
>         public void unlock() {
>             clusteredCache.unlock(key);
>         }
> 
>         @Override
>         public Condition newCondition() {
>             throw new UnsupportedOperationException();
>         }
>     }
> 
>     private static class CallableTask<V> implements Callable<V>, Serializable {
> 
>         private static final long serialVersionUID = -8761271979427214681L;
>         private final ClusterTask<V> task;
> 
>         CallableTask(final ClusterTask<V> task) {
>             this.task = task;
>         }
> 
>         @Override
>         public V call() {
472,476c505,507
<                 final Future<T> future = hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMember(new CallableTask<>(task), member);
<                 result = future.get(MAX_CLUSTER_EXECUTION_TIME.getValue().getSeconds(), TimeUnit.SECONDS);
<                 logger.trace("DistributedTask result: {}", result);
<             } catch (final TimeoutException te) {
<                 logger.error("Failed to execute cluster task within " + MAX_CLUSTER_EXECUTION_TIME + " seconds", te);
---
>                 task.run();
>                 logger.trace("CallableTask[{}] result: {}", task.getClass().getName(), task.getResult());
>                 return task.getResult();
478c509,510
<                 logger.error("Failed to execute cluster task", e);
---
>                 logger.error("Unexpected exception running CallableTask[{}]", task.getClass().getName(), e);
>                 throw e;
480,483d511
<         } else {
<             final String msg = MessageFormat.format("Requested node {0} not found in cluster", new String(nodeID, StandardCharsets.UTF_8));
<             logger.warn(msg);
<             throw new IllegalArgumentException(msg);
485c513,529
<         return result;
---
>     }
> 
>     private enum State {
>         stopped,
>         starting,
>         started
>     }
> 
>     public static NodeID getNodeID(final Member member) {
>         return NodeID.getInstance(member.getStringAttribute(HazelcastClusterNodeInfo.HOST_NAME_ATTRIBUTE).getBytes(StandardCharsets.UTF_8));
>     }
> 
>     static void fireLeftClusterAndWaitToComplete(final Duration timeout) {
>         final Semaphore leftClusterSemaphore = new Semaphore(0);
>         final ClusterEventListener clusterEventListener = new ClusterEventListener() {
>             @Override
>             public void joinedCluster() {
489,491c533
<     public ClusterNodeInfo getClusterNodeInfo(final byte[] nodeID) {
<         if (cluster == null) {
<             return null;
---
>             public void joinedCluster(final byte[] bytes) {
493,496c535,562
<         ClusterNodeInfo result = null;
<         final Member member = getMember(nodeID);
<         if (member != null) {
<             result = new HazelcastClusterNodeInfo(member, cluster.getClusterTime());
---
> 
>             @Override
>             public void leftCluster() {
>                 leftClusterSemaphore.release();
>             }
> 
>             @Override
>             public void leftCluster(final byte[] bytes) {
>             }
> 
>             @Override
>             public void markedAsSeniorClusterMember() {
>             }
>         };
>         try {
>             // Add a listener at the ultimate end of the list of all listeners, to detect that left-cluster event handling
>             // has been invoked for all before proceeding.
>             ClusterManager.addListener(clusterEventListener, Integer.MAX_VALUE);
>             logger.debug("Firing leftCluster() event");
>             ClusterManager.fireLeftCluster();
>             logger.debug("Waiting for leftCluster() event to be called [timeout={}]", StringUtils.getFullElapsedTime(timeout));
>             if (!leftClusterSemaphore.tryAcquire(timeout.toMillis(), TimeUnit.MILLISECONDS)) {
>                 logger.warn("Timeout waiting for leftCluster() event to be called [timeout={}]", StringUtils.getFullElapsedTime(timeout);
>             }
>         } catch (final Exception e) {
>             logger.error("Unexpected exception waiting for clustering to shut down", e);
>         } finally {
>             ClusterManager.removeListener(clusterEventListener);
498d563
<         return result;
510a576,645
>     private static class ClusteredCacheFactory implements CacheFactoryStrategy {
> 
>         private static final SystemProperty<String> HAZELCAST_EXECUTOR_SERVICE_NAME = SystemProperty.Builder.ofType(String.class)
>             .setKey("hazelcast.executor.service.name")
>             .setDefaultValue("openfire::cluster::executor")
>             .setDynamic(false)
>             .setPlugin(HazelcastPlugin.PLUGIN_NAME)
>             .build();
>         private static final SystemProperty<Duration> MAX_CLUSTER_EXECUTION_TIME = SystemProperty.Builder.ofType(Duration.class)
>             .setKey("hazelcast.max.execution.seconds")
>             .setDefaultValue(Duration.ofSeconds(30))
>             .setChronoUnit(ChronoUnit.SECONDS)
>             .setDynamic(true)
>             .setPlugin(HazelcastPlugin.PLUGIN_NAME)
>             .build();
>         private static final SystemProperty<Duration> CLUSTER_STARTUP_RETRY_TIME = SystemProperty.Builder.ofType(Duration.class)
>             .setKey("hazelcast.startup.retry.seconds")
>             .setDefaultValue(Duration.ofSeconds(10))
>             .setChronoUnit(ChronoUnit.SECONDS)
>             .setDynamic(true)
>             .setPlugin(HazelcastPlugin.PLUGIN_NAME)
>             .build();
>         private static final SystemProperty<Integer> CLUSTER_STARTUP_RETRY_COUNT = SystemProperty.Builder.ofType(Integer.class)
>             .setKey("hazelcast.startup.retry.count")
>             .setDefaultValue(1)
>             .setDynamic(true)
>             .setPlugin(HazelcastPlugin.PLUGIN_NAME)
>             .build();
>         private static final SystemProperty<String> HAZELCAST_CONFIG_FILE = SystemProperty.Builder.ofType(String.class)
>             .setKey("hazelcast.config.xml.filename")
>             .setDefaultValue("hazelcast-cache-config.xml")
>             .setDynamic(false)
>             .setPlugin(HazelcastPlugin.PLUGIN_NAME)
>             .build();
>         private static final SystemProperty<Boolean> HAZELCAST_JMX_ENABLED = SystemProperty.Builder.ofType(Boolean.class)
>             .setKey("hazelcast.config.fmx.enabled")
>             .setDefaultValue(Boolean.FALSE)
>             .setDynamic(false)
>             .setPlugin(HazelcastPlugin.PLUGIN_NAME)
>             .build();
>         private static final SystemProperty<Boolean> HAZELCAST_REST_ENABLED = SystemProperty.Builder.ofType(Boolean.class)
>             .setKey("hazelcast.config.rest.enabled")
>             .setDefaultValue(Boolean.FALSE)
>             .setDynamic(false)
>             .setPlugin(HazelcastPlugin.PLUGIN_NAME)
>             .build();
>         private static final SystemProperty<Boolean> HAZELCAST_MEMCACHE_ENABLED = SystemProperty.Builder.ofType(Boolean.class)
>             .setKey("hazelcast.config.memcache.enabled")
>             .setDefaultValue(Boolean.FALSE)
>             .setDynamic(false)
>             .setPlugin(HazelcastPlugin.PLUGIN_NAME)
>             .build();
> 
>         private static final Logger logger = LoggerFactory.getLogger(ClusteredCacheFactory.class);
>         public static final String PLUGIN_NAME = "hazelcast";
> 
>         private ExternalizableUtilStrategy serializationStrategy;
>         private Map<String, Map<String, long[]>> cacheStats;
>         private HazelcastInstance hazelcast = null;
>         private Cluster cluster = null;
>         private ClusterListener clusterListener;
>         private String lifecycleListener;
>         private String membershipListener;
>         private Cache<String, Instant> pluginClassLoaderWarnings;
> 
>         public ClusteredCacheFactory() {
>             pluginClassLoaderWarnings = CacheFactory.createLocalCache("PluginClassLoader Warnings for Clustered Tasks");
>             pluginClassLoaderWarnings.setMaxLifetime(Duration.ofHours(1).toMillis()); // Minimum duration between logged warnings.
>         }
> 
512,516c647,664
<     public void updateCacheStats(final Map<String, Cache> caches) {
<         if (!caches.isEmpty() && cluster != null) {
<             // Create the cacheStats map if necessary.
<             if (cacheStats == null) {
<                 cacheStats = hazelcast.getMap("opt-$cacheStats");
---
>         public boolean startCluster() {
>             logger.info("Starting hazelcast clustering");
>             state = State.starting;
> 
>             // Set the serialization strategy to use for transmittinging objects between node clusters
>             serializationStrategy = ExternalizableUtil.getInstance().getStrategy();
>             ExternalizableUtil.getInstance().setStrategy(new ClusterExternalizableUtil());
> 
>             final ClassLoader oldLoader = Thread.currentThread().getContextClassLoader();
>             final ClassLoader loader = new ClusterClassLoader();
>             Thread.currentThread().setContextClassLoader(loader);
>             int retry = 0;
>             do {
>                 try {
>                     final Config config = new ClasspathXmlConfig(HAZELCAST_CONFIG_FILE.getValue());
>                     final NetworkConfig networkConfig = config.getNetworkConfig();
>                     if (!HAZELCAST_MEMCACHE_ENABLED.getValue()) {
>                         networkConfig.setMemcacheProtocolConfig(new MemcacheProtocolConfig().setEnabled(false));
518,531c666,667
<             final String uid = getNodeID(cluster.getLocalMember()).toString();
<             final Map<String, long[]> stats = new HashMap<>();
<             for (final String cacheName : caches.keySet()) {
<                 final Cache cache = caches.get(cacheName);
<                 // The following information is published:
<                 // current size, max size, num elements, cache
<                 // hits, cache misses.
<                 final long[] info = new long[5];
<                 info[0] = cache.getLongCacheSize();
<                 info[1] = cache.getMaxCacheSize();
<                 info[2] = cache.size();
<                 info[3] = cache.getCacheHits();
<                 info[4] = cache.getCacheMisses();
<                 stats.put(cacheName, info);
---
>                     if (!HAZELCAST_REST_ENABLED.getValue()) {
>                         networkConfig.setRestApiConfig(new RestApiConfig().setEnabled(false);
533,534c669,676
<             // Publish message
<             cacheStats.put(uid, stats);
---
>                     final MemberAttributeConfig memberAttributeConfig = config.getMemberAttributeConfig();
>                     memberAttributeConfig.setStringAttribute(HazelcastClusterNodeInfo.HOST_NAME_ATTRIBUTE, XMPPServer.getInstance().getServerInfo().getHostname());
>                     memberAttributeConfig.setStringAttribute(HazelcastClusterNodeInfo.NODE_ID_ATTRIBUTE, XMPPServer.instance().getNodeID().toString());
>                     config.setInstanceName("openfire");
>                     config.setClassLoader(loader);
>                     if (JMXManager.isEnabled() && HAZELCAST_FMX_ENABLED.getValue()) {
>                         config.setProperty("hazelcast.fmx", "true");
>                         config.setProperty("hazelcast.fmx.detailed", "true");
535a678,709
>                     hazelcast = Hazelcast.newHazelcastInstance(config);
>                     cluster = hazelcast.getCluster();
>                     state = State.started;
>                     // CacheFactory is now using clustered caches. We can add our listeners.
>                     clusterListener = new ClusterListener(cluster);
>                     clusterListener.joinCluster();
>                     lifecycleListener = hazelcast.getLifecycleService().addLifecycleListener(clusterListener);
>                     membershipListener = cluster.addMembershipListener(clusterListener);
>                     logger.info("Hazelcast clustering started");
>                     break;
>                 } catch (final Exception e) {
>                     cluster = null;
>                     if (retry < CLUSTER_STARTUP_RETRY_COUNT.getValue()) {
>                         logger.warn("Failed to start clustering (" + e.getMessage() + "); " +
>                             "will retry in " + StringUtils.getFullElapsedTime(CLUSTER_STARTUP_RETRY_TIME.getValue());
>                         try {
>                             Thread.sleep(CLUSTER_STARTUP_RETRY_TIME.getValue().toMillis());
>                         } catch (final InterruptedException ignored) {
>                             Thread.currentThread().interrupt();
>                         }
>                     } else {
>                         logger.error("Unable to start clustering - continuing in local mode", e);
>                         state = State.stopped;
>                     }
>                 }
>             } while (retry++ < CLUSTER_STARTUP_RETRY_COUNT.getValue() && !Thread.currentThread().isInterrupted());
> 
>         if (oldLoader != null) {
>             // Restore previous class loader
>             Thread.currentThread().setContextClassLoader(oldLoader);
>         }
>         return cluster != null;
539,540c713,736
<     public String getPluginName() {
<         return PLUGIN_NAME;
---
>     public void stopCluster() {
>         // Stop the cache services.
>         cacheStats = null;
>         // Update the running state of the cluster
>         state = State.stopped;
> 
>         // Fire the leftClusterEvent before we leave the cluster - we need to access the clustered data before the
>         // cluster is shutdown so it can be copied in to the non-clustered, DefaultCache
>         fireLeftClusterAndWaitToComplete(Duration.ofSeconds(30));
>         // Stop the cluster
>         hazelcast.getLifecycleService().removeLifecycleListener(lifecycleListener);
>         cluster.removeMembershipListener(membershipListener);
>         Hazelcast.shutdownAll();
>         cluster = null;
>         lifecycleListener = null;
>         membershipListener = null;
>         clusterListener = null;
> 
>         // Reset packet router to use to deliver packets to remote cluster nodes
>         XMPPServer.getInstance().getRoutingTable().setRemotePacketRouter(null);
>         // Reset the session locator to use
>         XMPPServer.instance().setRemoteSessionLocator(null);
>         // Set the old serialization strategy was using before clustering was loaded
>         ExternalizableUtil.getInstance().setStrategy(serializationStrategy);
544c740,776
<     public Lock getLock(final Object key, Cache cache) {
---
>     public Cache createCache(final String name) {
>         // Check if cluster is being started up
>         while (state == State.starting) {
>             // Wait until cluster is fully started (or failed)
>             try {
>                 Thread.sleep(250);
>             } catch (final InterruptedException e) {
>                 // Ignore
>             }
>         }
>         if (state == State.stopped) {
>             throw new IllegalStateException("Cannot create clustered cache when not in a cluster");
>         }
>         // Determine the time to live. Note that in Hazelcast 0 means "forever", not -1
>         final long openfireLifetimeInMilliseconds = CacheFactory.maxCacheLifetime(name);
>         final int hazelcastLifetimeInSeconds = openfireLifetimeInMilliseconds < 0 ? 0 : Math.max((int) (openfireLifetimeInMilliseconds / 1000), 1);
>         // Determine the max cache size. Note that in Hazelcast the max cache size must be positive and is in megabytes
>         final long openfireMaxCacheSizeInBytes = CacheFactory.maxCacheSize(name);
>         final int hazelcastMaxCacheSizeInMegaBytes = openfireMaxCacheSizeInBytes < 0 ? Integer.MAX_VALUE : Math.max((int) openfireMaxCacheSizeInBytes / 1024 / 1024, 1);
>         // It's only possible to create a dynamic config if a static one doesn't already exist
>         final MapConfig staticConfig = hazelcast.getConfig().getMapConfigOrNull(name);
>         if (staticConfig == null) {
>             final MapConfig dynamicConfig = new MapConfig(name);
>             dynamicConfig.setTimeToLiveSeconds(hazelcastLifetimeInSeconds);
>             dynamicConfig.setMaxSizeConfig(new MaxSizeConfig(hazelcastMaxCacheSizeInMegaBytes, MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE);
>             logger.debug("Creating dynamic map config for cache={}, dynamicConfig={}", name, dynamicConfig);
>             hazelcast.getConfig().addMapConfig(dynamicConfig);
>         } else {
>             logger.debug("Static configuration already exists for cache={}, staticConfig={}", name, staticConfig);
>         }
>         // TODO: Better genericize this method in CacheFactoryStrategy so we can stop suppressing this warning
>         @SuppressWarnings("unchecked") final ClusteredCache clusteredCache = new ClusteredCache(name, hazelcast.getMap(name);
>         return clusteredCache;
>     }
> 
>     @Override
>     public void destroyCache(Cache cache) {
548,550c780,790
<         // TODO: Update CacheFactoryStrategy so the signature is getLock(final Serializable key, Cache<Serializable, Serializable> cache)
<         @SuppressWarnings("unchecked") final ClusterLock clusterLock = new ClusterLock((Serializable) key, (ClusteredCache<Serializable, ?>) cache);
<         return clusterLock;
---
> 
>         final ClusteredCache clustered = (ClusteredCache) cache;
>         clustered.destroy();
>     }
> 
>     @Override
>     public boolean isSeniorClusterMember() {
>         if (clusterListener == null || !clusterListener.isClusterMember()) {
>             return false;
>         }
>         return clusterListener.isSeniorClusterMember();
553,574c793,795
<     /**
<      * ClusterTasks that are executed should not be provided by a plugin. These will cause issues related to class
<      * loading when the providing plugin is reloaded. This method verifies if an instance of a task is
<      * loaded by a plugin class loader, and logs a warning to the log files when it is. The amount of warnings logged is
<      * limited by a time interval.
<      *
<      * @param o the instance for which to verify the class loader
<      * @see <a href="https://github.com/igniterealtime/openfire-hazelcast-plugin/issues/74">Issue #74: Warn against usage of plugin-provided classes in Hazelcast</a>
<      */
<     protected <T extends ClusterTask<?>> void checkForPluginClassLoader(final T o) {
<         if (o != null && o.getClass().getClassLoader() instanceof PluginClassLoader
<             && !pluginClassLoaderWarnings.containsKey(o.getClass().getName()) )
<         {
<             // Try to determine what plugin loaded the offending class.
<             String pluginName = null;
<             try {
<                 final Collection<Plugin> plugins = XMPPServer.getInstance().getPluginManager().getPlugins();
<                 for (final Plugin plugin : plugins) {
<                     final PluginClassLoader pluginClassloader = XMPPServer.getInstance().getPluginManager().getPluginClassloader(plugin);
<                     if (o.getClass().getClassLoader().equals(pluginClassloader)) {
<                         pluginName = XMPPServer.getInstance().getPluginManager().getCanonicalName(plugin);
<                         break;
---
>     @Override
>     public List<ClusterNodeInfo> getClusterNodesInfo() {
>         return clusterListener == null ? Collections.emptyList() : clusterListener.getClusterNodesInfo();
575a797,801
> 
>     @Override
>     public int maxClusterNodes() {
>         // No longer depends on license code so just return a big number
>         return 10000;
577,578c803,810
<             } catch (Exception e) {
<                 logger.debug("An exception occurred while trying to determine the plugin class loader that loaded an instance of {}", o.getClass(), e);
---
> 
>     @Override
>     public byte[] getSeniorClusterMemberID() {
>         if (clusterListener != null && !cluster.getMembers().isEmpty()) {
>             final Member oldest = cluster.getMembers().iterator().next();
>             return getNodeID(oldest).toByteArray();
>         } else {
>             return null;
580,583c812,819
<             logger.warn("An instance of {} that is executed as a cluster task. This will cause issues when reloading " +
<                     "the plugin that provides this class. The plugin implementation should be modified.",
<                 pluginName != null ? o.getClass() + " (provided by plugin " + pluginName + ")" : o.getClass());
<             pluginClassLoaderWarnings.put(o.getClass().getName(), Instant.now()); // Note that this Instant is unused.
---
>     }
> 
>     @Override
>     public byte[] getClusterMemberID() {
>         if (cluster != null) {
>             return nodeID(cluster.getLocalMember()).toByteArray();
>         } else {
>             return null;
587c823,828
<     private static class ClusterLock implements Lock {
---
>     @Override
>     public long getClusterTime() {
>         return cluster == null ? System.currentTimeMillis() : cluster.getClusterTime();
>     }
> 
>     private static class ClusterLock implements Lock
590c831
<         private final ClusteredCache<Serializable, ?> cache;
---
>         private final ClusteredCache clusteredCache;
592c833
<         ClusterLock(final Serializable key, final ClusteredCache<Serializable, ?> cache) {
---
>         ClusterLock(final Serializable key, final ClusteredCache clusteredCache) {
594c835
<             this.cache = cache;
---
>             this.clusteredCache = clusteredCache;
599c840
<             cache.lock(key, -1);
---
>             clusteredCache.lock(key, -1);
604c845
<             cache.lock(key, -1);
---
>             clusteredCache.lock(key, -1);
609c850
<             return cache.lock(key, 0);
---
>             return clusteredCache.lock(key, 0);
614c855
<             return cache.lock(key, unit.toMillis(time));
---
>             return clusteredCache.lock(key, unit.toMillis(time);
619c860
<             cache.unlock(key);
---
>             clusteredCache.unlock(key);
628c869,870
<     private static class CallableTask<V> implements Callable<V>, Serializable {
---
>     private static class CallableTask<V> implements Callable<V>, Serializable
> 
656c898
<         return NodeID.getInstance(member.getStringAttribute(HazelcastClusterNodeInfo.NODE_ID_ATTRIBUTE).getBytes(StandardCharsets.UTF_8));
---
>         return NodeID.getInstance(member.getStringAttribute(HazelcastClusterNodeInfo.HOST_NAME_ATTRIBUTE).getBytes(StandardCharsets.UTF_8);
689c931
<             logger.debug("Waiting for leftCluster() event to be called [timeout={}]", StringUtils.getFullElapsedTime(timeout));
---
>             logger.debug("Waiting for leftCluster() event to be called [timeout={}]", StringUtils.getFullElapsedTime(timeout);
691c933
<                 logger.warn("Timeout waiting for leftCluster() event to be called [timeout={}]", StringUtils.getFullElapsedTime(timeout));
---
>                 logger.warn("Timeout waiting for leftCluster() event to be called [timeout={}]", StringUtils.getFullElapsedTime(timeout);
699d940
< 
701,703d941
< 
< 
< 
