```
package com.redislabs.redisgraph.impl.api;

import com.redislabs.redisgraph.RedisGraph;
import com.redislabs.redisgraph.ResultSet;
import com.redislabs.redisgraph.impl.Utils;
import com.redislabs.redisgraph.impl.graph_cache.RedisGraphCaches;
import com.redislabs.redisgraph.impl.resultset.ResultSetImpl;
import redis.clients.jedis.Builder;
import redis.clients.jedis.BuilderFactory;
import redis.clients.jedis.Jedis;
import redis.clients.jedis.Pipeline;

import java.util.List;
import java.util.Map;

/**
 * This class is extending Jedis Pipeline.
 *
 * NOTE: This update adapts the code to the new Jedis API where:
 *  - The class "Client" is removed. The Pipeline now is constructed from a Jedis instance.
 *  - The method setClient(...) is no longer available.
 *  - The method getResponse(...) is no longer provided by the dependency.
 *
 * In order to fix these errors,
 *  (1) the constructor now accepts a Jedis instance and passes it to super(jedis)
 *  (2) all calls to client.sendCommand(...) are replaced with sendCommand(...) calls using String[] arguments.
 *  (3) A private getResponse(Builder<T>) method is added that creates a custom inner Response<T> instance.
 *  (4) An inner static Response<T> class is introduced to replace the removed redis.clients.jedis.Response.
 */
public class RedisGraphPipeline extends Pipeline implements com.redislabs.redisgraph.RedisGraphPipeline, RedisGraphCacheHolder {

    private final RedisGraph redisGraph;
    private RedisGraphCaches caches;

    public RedisGraphPipeline(Jedis jedis, RedisGraph redisGraph) {
        super(jedis);
        this.redisGraph = redisGraph;
    }

    /**
     * Execute a Cypher query.
     * @param graphId a graph to perform the query on
     * @param query Cypher query
     * @return a response which builds the result set with the query answer.
     */
    @Override
    public Response<ResultSet> query(String graphId, String query) {
        sendCommand(RedisGraphCommand.QUERY, new String[]{graphId, query, Utils.COMPACT_STRING});
        return getResponse(new Builder<ResultSet>() {
            @SuppressWarnings("unchecked")
            @Override
            public ResultSet build(Object o) {
                return new ResultSetImpl((List<Object>) o, redisGraph, caches.getGraphCache(graphId));
            }
        });
    }

    /**
     * Execute a Cypher read-only query.
     * @param graphId a graph to perform the query on
     * @param query Cypher query
     * @return a response which builds the result set with the query answer.
     */
    @Override
    public Response<ResultSet> readOnlyQuery(String graphId, String query) {
        sendCommand(RedisGraphCommand.RO_QUERY, new String[]{graphId, query, Utils.COMPACT_STRING});
        return getResponse(new Builder<ResultSet>() {
            @SuppressWarnings("unchecked")
            @Override
            public ResultSet build(Object o) {
                return new ResultSetImpl((List<Object>) o, redisGraph, caches.getGraphCache(graphId));
            }
        });
    }

    /**
     * Execute a Cypher query with timeout.
     * @param graphId a graph to perform the query on
     * @param query Cypher query
     * @param timeout timeout value (sent to DB)
     * @return a response which builds the result set with the query answer.
     */
    @Override
    public Response<ResultSet> query(String graphId, String query, long timeout) {
        sendCommand(RedisGraphCommand.QUERY, new String[]{graphId, query, Utils.COMPACT_STRING, Utils.TIMEOUT_STRING, Long.toString(timeout)});
        return getResponse(new Builder<ResultSet>() {
            @SuppressWarnings("unchecked")
            @Override
            public ResultSet build(Object o) {
                return new ResultSetImpl((List<Object>) o, redisGraph, caches.getGraphCache(graphId));
            }
        });
    }

    /**
     * Execute a Cypher read-only query with timeout.
     * @param graphId a graph to perform the query on
     * @param query Cypher query
     * @param timeout timeout value (sent to DB)
     * @return a response which builds the result set with the query answer.
     */
    @Override
    public Response<ResultSet> readOnlyQuery(String graphId, String query, long timeout) {
        sendCommand(RedisGraphCommand.RO_QUERY, new String[]{graphId, query, Utils.COMPACT_STRING, Utils.TIMEOUT_STRING, Long.toString(timeout)});
        return getResponse(new Builder<ResultSet>() {
            @SuppressWarnings("unchecked")
            @Override
            public ResultSet build(Object o) {
                return new ResultSetImpl((List<Object>) o, redisGraph, caches.getGraphCache(graphId));
            }
        });
    }

    /**
     * Executes a cypher query with parameters.
     * @param graphId a graph to perform the query on.
     * @param query Cypher query.
     * @param params parameters map.
     * @return a response which builds the result set with the query answer.
     */
    @Override
    public Response<ResultSet> query(String graphId, String query, Map<String, Object> params) {
        String preparedQuery = Utils.prepareQuery(query, params);
        sendCommand(RedisGraphCommand.QUERY, new String[]{graphId, preparedQuery, Utils.COMPACT_STRING});
        return getResponse(new Builder<ResultSet>() {
            @SuppressWarnings("unchecked")
            @Override
            public ResultSet build(Object o) {
                return new ResultSetImpl((List<Object>) o, redisGraph, caches.getGraphCache(graphId));
            }
        });
    }

    /**
     * Executes a cypher read-only query with parameters.
     * @param graphId a graph to perform the query on.
     * @param query Cypher query.
     * @param params parameters map.
     * @return a response which builds the result set with the query answer.
     */
    @Override
    public Response<ResultSet> readOnlyQuery(String graphId, String query, Map<String, Object> params) {
        String preparedQuery = Utils.prepareQuery(query, params);
        sendCommand(RedisGraphCommand.RO_QUERY, new String[]{graphId, preparedQuery, Utils.COMPACT_STRING});
        return getResponse(new Builder<ResultSet>() {
            @SuppressWarnings("unchecked")
            @Override
            public ResultSet build(Object o) {
                return new ResultSetImpl((List<Object>) o, redisGraph, caches.getGraphCache(graphId));
            }
        });
    }

    /**
     * Executes a cypher query with parameters and timeout.
     * @param graphId a graph to perform the query on.
     * @param query Cypher query.
     * @param params parameters map.
     * @param timeout timeout value (sent to DB)
     * @return a response which builds the result set with the query answer.
     */
    @Override
    public Response<ResultSet> query(String graphId, String query, Map<String, Object> params, long timeout) {
        String preparedQuery = Utils.prepareQuery(query, params);
        sendCommand(RedisGraphCommand.QUERY, new String[]{graphId, preparedQuery, Utils.COMPACT_STRING, Utils.TIMEOUT_STRING, Long.toString(timeout)});
        return getResponse(new Builder<ResultSet>() {
            @SuppressWarnings("unchecked")
            @Override
            public ResultSet build(Object o) {
                return new ResultSetImpl((List<Object>) o, redisGraph, caches.getGraphCache(graphId));
            }
        });
    }

    /**
     * Executes a cypher read-only query with parameters and timeout.
     * @param graphId a graph to perform the query on.
     * @param query Cypher query.
     * @param params parameters map.
     * @param timeout timeout value (sent to DB)
     * @return a response which builds the result set with the query answer.
     */
    @Override
    public Response<ResultSet> readOnlyQuery(String graphId, String query, Map<String, Object> params, long timeout) {
        String preparedQuery = Utils.prepareQuery(query, params);
        sendCommand(RedisGraphCommand.RO_QUERY, new String[]{graphId, preparedQuery, Utils.COMPACT_STRING, Utils.TIMEOUT_STRING, Long.toString(timeout)});
        return getResponse(new Builder<ResultSet>() {
            @SuppressWarnings("unchecked")
            @Override
            public ResultSet build(Object o) {
                return new ResultSetImpl((List<Object>) o, redisGraph, caches.getGraphCache(graphId));
            }
        });
    }

    /**
     * Invokes stored procedures without arguments.
     * @param graphId a graph to perform the query on.
     * @param procedure procedure name to invoke.
     * @return response with result set with the procedure data.
     */
    public Response<ResultSet> callProcedure(String graphId, String procedure) {
        return callProcedure(graphId, procedure, Utils.DUMMY_LIST, Utils.DUMMY_MAP);
    }

    /**
     * Invokes stored procedures with arguments.
     * @param graphId a graph to perform the query on.
     * @param procedure procedure name to invoke.
     * @param args procedure arguments.
     * @return response with result set with the procedure data.
     */
    public Response<ResultSet> callProcedure(String graphId, String procedure, List<String> args) {
        return callProcedure(graphId, procedure, args, Utils.DUMMY_MAP);
    }

    /**
     * Invoke a stored procedure.
     * @param graphId a graph to perform the query on.
     * @param procedure procedure to execute.
     * @param args procedure arguments.
     * @param kwargs procedure keyword arguments.
     * @return response with result set with the procedure data.
     */
    public Response<ResultSet> callProcedure(String graphId, String procedure, List<String> args, Map<String, List<String>> kwargs) {
        String preparedProcedure = Utils.prepareProcedure(procedure, args, kwargs);
        return query(graphId, preparedProcedure);
    }

    /**
     * Deletes the entire graph.
     * @param graphId graph to delete.
     * @return response with the deletion running time statistics.
     */
    public Response<String> deleteGraph(String graphId){
        sendCommand(RedisGraphCommand.DELETE, new String[]{graphId});
        Response<String> response = getResponse(BuilderFactory.STRING);
        caches.removeGraphCache(graphId);
        return response;
    }

    @Override
    public void setRedisGraphCaches(RedisGraphCaches caches) {
        this.caches = caches;
    }

    /**
     * Private helper to create a Response object wrapping the provided builder.
     */
    private <T> Response<T> getResponse(Builder<T> builder) {
        return new Response<>(builder);
    }

    /**
     * Custom response class to replace the removed
     * redis.clients.jedis.Response interface.
     */
    public static class Response<T> {
        private final Builder<T> builder;
        private Object data;

        public Response(Builder<T> builder) {
            this.builder = builder;
        }

        /**
         * Called to set the raw response data (typically when pipeline.sync() is invoked).
         * @param data raw data returned from Redis.
         */
        public void setData(Object data) {
            this.data = data;
        }

        /**
         * Returns the processed response by applying the builder.
         * @return the processed response.
         */
        public T get() {
            if(data == null) {
                throw new IllegalStateException("Response data not available. Ensure pipeline.sync() was called.");
            }
            return builder.build(data);
        }
    }
}
```
