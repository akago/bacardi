3,4d2
< import static micycle.pgs.PGS_Conversion.fromPShape;
< 
26,28d23
< import org.tinspin.index.PointDistanceFunction;
< import org.tinspin.index.PointEntryDist;
< import org.tinspin.index.covertree.CoverTree;
57,61d51
<         /*-
<          * Roadmap (see/implement): 'A LINEARIZED CIRCLE PACKING ALGORITHM'? 
<          * 'A note on circle packing' Young Joon AHN.
<          */
< 
88c78,79
<                 LargestEmptyCircles lec = new LargestEmptyCircles(fromPShape(PGS_Conversion.toPointsPShape(pointObstacles)), geometry,
---
>         LargestEmptyCircles lec = new LargestEmptyCircles(
>                 fromPShape(PGS_Conversion.toPointsPShape(pointObstacles)), geometry,
127c118,120
<                 return StreamSupport.stream(tin.triangles().spliterator(), false).filter(filterBorderTriangles).map(t -> inCircle(t))
---
>         return StreamSupport.stream(tin.triangles().spliterator(), false)
>                 .filter(filterBorderTriangles)
>                 .map(t -> inCircle(t))
203c196
<                 final CoverTree<PVector> tree = CoverTree.create(3, 2, circleDistanceMetric);
---
>         final SimpleCircleIndex tree = new SimpleCircleIndex();
209,210c202,205
<                         steinerPoints = StreamSupport.stream(tin.triangles().spliterator(), false).filter(filterBorderTriangles)
<                                         .map(PGS_CirclePacking::centroid).collect(Collectors.toList());
---
>             steinerPoints = StreamSupport.stream(tin.triangles().spliterator(), false)
>                                          .filter(filterBorderTriangles)
>                                          .map(PGS_CirclePacking::centroid)
>                                          .collect(Collectors.toList());
213,214c208
<                 // Model shape vertices as circles of radius 0, to constrain packed circles
<                 // within shape edge
---
>         // Model shape vertices as circles of radius 0, to constrain packed circles within shape edge
217c211
<                 vertices.forEach(p -> tree.insert(new double[] { p.x, p.y, 0 }, p));
---
>         vertices.forEach(p -> tree.insert(new PVector(p.x, p.y, 0)));
219,222d212
<                 /*
<                  * "To find the circle nearest to a center (x, y), do a proximity search at (x,
<                  * y, R), where R is greater than or equal to the maximum radius of a circle."
<                  */
226c216
<                         final PointEntryDist<PVector> nn = tree.query1NN(new double[] { p.x, p.y, largestR }); // find nearest-neighbour circle
---
>             SimplePointEntry<PVector> nn = tree.query1NN(new double[] { p.x, p.y, largestR }); // find nearest-neighbour circle
239c229
<                                 tree.insert(new double[] { p.x, p.y, radius }, p); // insert circle into tree
---
>                 tree.insert(new PVector(p.x, p.y, radius)); // insert circle into tree
627,656d616
<          * Calculate the distance between two points in 3D space, where each point
<          * represents a circle with (x, y, r) coordinates. This custom metric considers
<          * both the Euclidean distance between the centers of the circles and the
<          * absolute difference of their radii.
<          * <p>
<          * The metric is defined as follows: Given two points A and B, representing
<          * circles centered at (x1, y1) and (x2, y2) with radii r1 and r2 respectively,
<          * the distance is calculated as sqrt((x1 - x2)^2 + (y1 - y2)^2) + |r1 - r2|.
<          * <p>
<          * This metric can be used to find the nearest circle to a given center (x, y)
<          * in a proximity search. To perform the search, use a point (x, y, R) where R
<          * is greater than or equal to the maximum radius of a circle in the proximity
<          * structure.
<          *
<          * @param p1 3D point representing the first circle (x1, y1, r1)
<          * @param p2 3D point representing the second circle (x2, y2, r2)
<          * @return the distance between the two points based on the custom metric
<          */
<         private static final PointDistanceFunction circleDistanceMetric = (p1, p2) -> {
<                 // from https://stackoverflow.com/a/21975136/
<                 final double dx = p1[0] - p2[0];
<                 final double dy = p1[1] - p2[1];
<                 final double dz = p1[2] - p2[2];
< 
<                 double euclideanDistance = Math.sqrt(dx * dx + dy * dy);
<                 double absZDifference = Math.abs(dz);
<                 return euclideanDistance + absZDifference; // negative if inside
<         };
< 
<         /**
663a624,678
>     private static Geometry fromPShape(PShape shape) {
>         // Assume this method converts PShape to Geometry.
>         // This is a placeholder that calls the conversion utility.
>         return PGS_Conversion.fromPShape(shape);
>     }
> 
>     // ------------------------------------------------------------------------
>     // Simple index implementation replacing the removed tinspin CoverTree API.
>     // ------------------------------------------------------------------------
>     
>     private static class SimpleCircleIndex {
>         private final List<PVector> circles = new ArrayList<>();
> 
>         public void insert(PVector circle) {
>             circles.add(circle);
>         }
> 
>         public SimplePointEntry<PVector> query1NN(double[] query) {
>             double qx = query[0];
>             double qy = query[1];
>             double qr = query[2];
>             double bestDistance = Double.MAX_VALUE;
>             PVector bestCircle = null;
>             for (PVector c : circles) {
>                 double dx = c.x - qx;
>                 double dy = c.y - qy;
>                 double dEuclid = Math.sqrt(dx * dx + dy * dy);
>                 double dRadius = Math.abs(c.z - qr);
>                 double total = dEuclid + dRadius;
>                 if (total < bestDistance) {
>                     bestDistance = total;
>                     bestCircle = c;
>                 }
>             }
>             return new SimplePointEntry<>(bestCircle, bestDistance);
>         }
>     }
> 
>     private static class SimplePointEntry<T> {
>         private final T value;
>         private final double distance;
> 
>         public SimplePointEntry(T value, double distance) {
>             this.value = value;
>             this.distance = distance;
>         }
> 
>         public T value() {
>             return value;
>         }
> 
>         public double dist() {
>             return distance;
>         }
>     }
