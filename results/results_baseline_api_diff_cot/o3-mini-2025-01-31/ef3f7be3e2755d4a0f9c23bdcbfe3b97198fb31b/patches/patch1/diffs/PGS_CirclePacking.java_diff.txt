26,28d25
< import org.tinspin.index.PointDistanceFunction;
< import org.tinspin.index.PointEntryDist;
< import org.tinspin.index.covertree.CoverTree;
165d161
<          * 
203c199,201
<                 final CoverTree<PVector> tree = CoverTree.create(3, 2, circleDistanceMetric);
---
>                 // Instead of using a specialized spatial index (e.g. CoverTree),
>                 // we maintain a simple list of circles and use a linear scan for nearest-neighbor queries.
>                 List<PVector> treeList = new ArrayList<>();
209,210c207,210
<                         steinerPoints = StreamSupport.stream(tin.triangles().spliterator(), false).filter(filterBorderTriangles)
<                                         .map(PGS_CirclePacking::centroid).collect(Collectors.toList());
---
>                         steinerPoints = StreamSupport.stream(tin.triangles().spliterator(), false)
>                                         .filter(filterBorderTriangles)
>                                         .map(PGS_CirclePacking::centroid)
>                                         .collect(Collectors.toList());
213,214c213
<                 // Model shape vertices as circles of radius 0, to constrain packed circles
<                 // within shape edge
---
>                 // Model shape vertices as circles of radius 0, to constrain packed circles within shape edge
216,217c215,219
<                 Collections.shuffle(vertices); // shuffle vertices to reduce tree imbalance during insertion
<                 vertices.forEach(p -> tree.insert(new double[] { p.x, p.y, 0 }, p));
---
>                 Collections.shuffle(vertices); // shuffle vertices to reduce bias during insertion
>                 vertices.forEach(p -> {
>                         PVector vertexCircle = new PVector(p.x, p.y, 0);
>                         treeList.add(vertexCircle);
>                 });
220,221c222,225
<                  * "To find the circle nearest to a center (x, y), do a proximity search at (x,
<                  * y, R), where R is greater than or equal to the maximum radius of a circle."
---
>                  * Emulate a nearest-neighbor query by performing a linear search over the list.
>                  * For each candidate circle, we compute the value:
>                  *    distance = sqrt((p.x - candidate.x)^2 + (p.y - candidate.y)^2) - candidate.z
>                  * and choose the candidate that minimizes this value.
223c227
<                 float largestR = 0; // the radius of the largest circle in the tree
---
>                 float largestR = 0; // the radius of the largest circle in the list
226,235c230,244
<                         final PointEntryDist<PVector> nn = tree.query1NN(new double[] { p.x, p.y, largestR }); // find nearest-neighbour circle
< 
<                         /*
<                          * nn.dist() does not return the radius (since it's a distance metric used to
<                          * find nearest circle), so calculate maximum radius for candidate circle using
<                          * 2d euclidean distance between center points minus radius of nearest circle.
<                          */
<                         final float dx = p.x - nn.value().x;
<                         final float dy = p.y - nn.value().y;
<                         final float radius = (float) (Math.sqrt(dx * dx + dy * dy) - nn.value().z);
---
>                         double bestMetric = Double.MAX_VALUE;
>                         PVector nearestCircle = null;
>                         for (PVector candidate : treeList) {
>                                 double dx = p.x - candidate.x;
>                                 double dy = p.y - candidate.y;
>                                 double metric = Math.hypot(dx, dy) - candidate.z;
>                                 if (metric < bestMetric) {
>                                         bestMetric = metric;
>                                         nearestCircle = candidate;
>                                 }
>                         }
>                         // Calculate maximum possible radius for circle centered at p
>                         float dx = p.x - nearestCircle.x;
>                         float dy = p.y - nearestCircle.y;
>                         final float radius = (float) (Math.hypot(dx, dy) - nearestCircle.z);
237c246,248
<                                 largestR = (radius >= largestR) ? radius : largestR;
---
>                                 if (radius >= largestR) {
>                                         largestR = radius;
>                                 }
239,240c250,253
<                                 tree.insert(new double[] { p.x, p.y, radius }, p); // insert circle into tree
<                                 out.add(p);
---
>                                 // Add a new instance into our circle list and result output.
>                                 PVector circle = new PVector(p.x, p.y, radius);
>                                 treeList.add(circle);
>                                 out.add(circle);
285,287c298
< 
<                                 // if center point not in circle, check whether circle overlaps with shape using
<                                 // intersects() (somewhat slower)
---
>                                 // if center point not in circle, check whether circle overlaps with shape using intersects() (somewhat slower)
293d303
< 
322d331
< 
355d363
< 
362d369
<          * 
509d515
< 
538d543
< 
576d580
< 
609d612
< 
611d613
< 
627,656d628
<          * Calculate the distance between two points in 3D space, where each point
<          * represents a circle with (x, y, r) coordinates. This custom metric considers
<          * both the Euclidean distance between the centers of the circles and the
<          * absolute difference of their radii.
<          * <p>
<          * The metric is defined as follows: Given two points A and B, representing
<          * circles centered at (x1, y1) and (x2, y2) with radii r1 and r2 respectively,
<          * the distance is calculated as sqrt((x1 - x2)^2 + (y1 - y2)^2) + |r1 - r2|.
<          * <p>
<          * This metric can be used to find the nearest circle to a given center (x, y)
<          * in a proximity search. To perform the search, use a point (x, y, R) where R
<          * is greater than or equal to the maximum radius of a circle in the proximity
<          * structure.
<          *
<          * @param p1 3D point representing the first circle (x1, y1, r1)
<          * @param p2 3D point representing the second circle (x2, y2, r2)
<          * @return the distance between the two points based on the custom metric
<          */
<         private static final PointDistanceFunction circleDistanceMetric = (p1, p2) -> {
<                 // from https://stackoverflow.com/a/21975136/
<                 final double dx = p1[0] - p2[0];
<                 final double dy = p1[1] - p2[1];
<                 final double dz = p1[2] - p2[2];
< 
<                 double euclideanDistance = Math.sqrt(dx * dx + dy * dy);
<                 double absZDifference = Math.abs(dz);
<                 return euclideanDistance + absZDifference; // negative if inside
<         };
< 
<         /**
