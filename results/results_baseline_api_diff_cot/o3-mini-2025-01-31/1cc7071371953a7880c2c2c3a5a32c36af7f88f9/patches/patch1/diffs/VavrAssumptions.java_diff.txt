24,33c24,34
< import org.assertj.core.internal.bytebuddy.ByteBuddy;
< import org.assertj.core.internal.bytebuddy.TypeCache;
< import org.assertj.core.internal.bytebuddy.TypeCache.SimpleKey;
< import org.assertj.core.internal.bytebuddy.dynamic.scaffold.TypeValidation;
< import org.assertj.core.internal.bytebuddy.implementation.Implementation;
< import org.assertj.core.internal.bytebuddy.implementation.MethodDelegation;
< import org.assertj.core.internal.bytebuddy.implementation.auxiliary.AuxiliaryType;
< import org.assertj.core.internal.bytebuddy.implementation.bind.annotation.RuntimeType;
< import org.assertj.core.internal.bytebuddy.implementation.bind.annotation.SuperCall;
< import org.assertj.core.internal.bytebuddy.implementation.bind.annotation.This;
---
> import net.bytebuddy.ByteBuddy;
> import net.bytebuddy.NamingStrategy;
> import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;
> import net.bytebuddy.dynamic.scaffold.TypeValidation;
> import net.bytebuddy.implementation.Implementation;
> import net.bytebuddy.implementation.MethodDelegation;
> import net.bytebuddy.matcher.ElementMatchers;
> import net.bytebuddy.implementation.bind.annotation.RuntimeType;
> import net.bytebuddy.implementation.bind.annotation.SuperCall;
> import net.bytebuddy.implementation.bind.annotation.This;
> import org.assertj.core.util.Arrays;
37a39
> import java.util.Map.Entry;
38a41,42
> import java.util.Map;
> import java.util.concurrent.ConcurrentHashMap;
40c44
< import static org.assertj.core.internal.bytebuddy.matcher.ElementMatchers.any;
---
> import static net.bytebuddy.matcher.ElementMatchers.any;
50,51c54,56
<     private static final ByteBuddy BYTE_BUDDY = new ByteBuddy().with(TypeValidation.DISABLED)
<             .with(new AuxiliaryType.NamingStrategy.SuffixingRandom("Assertj$Assumptions"));
---
>     private static final ByteBuddy BYTE_BUDDY = new ByteBuddy()
>             .with(TypeValidation.DISABLED)
>             .with(new NamingStrategy.SuffixingRandom("Assertj$Assumptions"));
55c60,61
<     private static final TypeCache<SimpleKey> CACHE = new TypeCache.WithInlineExpunction<>(TypeCache.Sort.SOFT);
---
>     // Replace the removed TypeCache with a simple concurrent hash map cache.
>     private static final java.util.Map<Class<?>, Class<?>> CACHE = new ConcurrentHashMap<>();
215,218c221
<         SimpleKey cacheKey = new SimpleKey(assertClass);
<         return (Class<ASSERTION>) CACHE.findOrInsert(VavrAssumptions.class.getClassLoader(),
<                 cacheKey,
<                 () -> generateAssumptionClass(assertClass));
---
>         return (Class<? extends ASSERTION>) CACHE.computeIfAbsent(assertClass, k -> generateAssumptionClass(assertClass));
