```java
package micycle.pgs;

import static micycle.pgs.PGS_Conversion.fromPShape;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.SplittableRandom;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.StreamSupport;

import org.locationtech.jts.algorithm.locate.IndexedPointInAreaLocator;
import org.locationtech.jts.geom.Coordinate;
import org.locationtech.jts.geom.Envelope;
import org.locationtech.jts.geom.Geometry;
import org.locationtech.jts.geom.Location;
import org.locationtech.jts.geom.prep.PreparedGeometry;
import org.locationtech.jts.geom.prep.PreparedGeometryFactory;
import org.locationtech.jts.operation.distance.IndexedFacetDistance;
import org.locationtech.jts.util.GeometricShapeFactory;
import org.tinfour.common.IIncrementalTin;
import org.tinfour.common.SimpleTriangle;
import org.tinfour.common.Vertex;

import micycle.pgs.commons.FrontChainPacker;
import micycle.pgs.commons.LargestEmptyCircles;
import micycle.pgs.commons.RepulsionCirclePack;
import micycle.pgs.commons.TangencyPack;
import processing.core.PShape;
import processing.core.PVector;

/**
 * Circle packings of shapes, subject to varying constraints and patterns of
 * tangencies.
 * <p>
 * Each method produces a circle packing with different characteristics using a
 * different technique; for this reason input arguments vary across the methods.
 * <p>
 * The output of each method is a list of PVectors, each representing one
 * circle: (.x, .y) represent the center point and .z represents radius.
 * <p>
 * Where applicable, packings will include circles that overlap with the shape,
 * rather than only including those circles whose center point lies inside the
 * shape.
 * 
 * @author Michael Carleton
 * @since 1.1.0
 *
 */
public final class PGS_CirclePacking {

	private PGS_CirclePacking() {
	}

	/**
	 * Packs circles of varying radii within a given shape, whilst respecting
	 * pointal obstacles using the Largest Empty Circle (LEC) algorithm. The method
	 * continues to generate circles until the sum of the areas of the circles
	 * exceeds a specified proportion of the area of the given shape.
	 * 
	 * @param shape          The shape within which circles will be packed. The
	 *                       shape should be in the form of PShape.
	 * @param pointObstacles A collection of PVector points representing obstacles,
	 *                       around which circles are packed. Only points contained
	 *                       within the shape are relevant.
	 * @param areaCoverRatio The target ratio of the total area of the circles to
	 *                       the area of the shape. This parameter should be a
	 *                       double between 0 and 1. Circle generation will stop
	 *                       when this ratio is reached.
	 * @return A list of PVectors, where each PVector represents a circle. The x and
	 *         y components of the PVector represent the center of the circle, and
	 *         the z component represents the radius of the circle.
	 * @since 1.4.0
	 */
	public static List<PVector> obstaclePack(PShape shape, Collection<PVector> pointObstacles, double areaCoverRatio) {
		final Geometry geometry = fromPShape(shape);

		LargestEmptyCircles lec = new LargestEmptyCircles(fromPShape(PGS_Conversion.toPointsPShape(pointObstacles)), geometry,
				areaCoverRatio > 0.95 ? 0.5 : 1);

		final double shapeArea = geometry.getArea();
		double circlesArea = 0;
		List<PVector> circles = new ArrayList<>();

		while (circlesArea / shapeArea < areaCoverRatio) {
			double[] currentLEC = lec.findNextLEC();
			circles.add(new PVector((float) currentLEC[0], (float) currentLEC[1], (float) currentLEC[2]));
			circlesArea += Math.PI * currentLEC[2] * currentLEC[2];
			if (currentLEC[2] < 0.5) {
				break;
			}
		}
		return circles;
	}

	/**
	 * Packs circles of varying radii within a given shape, whilst respecting
	 * pointal obstacles using the Largest Empty Circle (LEC) algorithm. The method
	 * continues to generate circles until the sum of the areas of the circles
	 * exceeds a specified proportion of the area of the given shape.
	 * 
	 * @param shape          The shape within which circles will be packed. The
	 *                       shape should be in the form of PShape.
	 * @param pointObstacles A collection of PVector points representing obstacles,
	 *                       around which circles are packed. Only points contained
	 *                       within the shape are relevant.
	 * @param areaCoverRatio The target ratio of the total area of the circles to
	 *                       the area of the shape. This parameter should be a
	 *                       double between 0 and 1. Circle generation will stop
	 *                       when this ratio is reached.
	 * @return A list of PVectors, where each PVector represents a circle. The x and
	 *         y components of the PVector represent the center of the circle, and
	 *         the z component represents the radius of the circle.
	 * @since 1.4.0
	 */
	public static List<PVector> obstaclePack(PShape shape, Collection<PVector> pointObstacles, double areaCoverRatio) {
		final Geometry geometry = fromPShape(shape);

		LargestEmptyCircles lec = new LargestEmptyCircles(fromPShape(PGS_Conversion.toPointsPShape(pointObstacles)), geometry,
				areaCoverRatio > 0.95 ? 0.5 : 1);

		final double shapeArea = geometry.getArea();
		double circlesArea = 0;
		List<PVector> circles = new ArrayList<>();

		while (circlesArea / shapeArea < areaCoverRatio) {
			double[] currentLEC = lec.findNextLEC();
			circles.add(new PVector((float) currentLEC[0], (float) currentLEC[1], (float) currentLEC[2]));
			circlesArea += Math.PI * currentLEC[2] * currentLEC[2];
			if (currentLEC[2] < 0.5) {
				break;
			}
		}
		return circles;
	}

	/**
	 * Packs circles of varying radii within a given shape, whilst respecting
	 * pointal obstacles using the Largest Empty Circle (LEC) algorithm. The method
	 * continues to generate circles until the sum of the areas of the circles
	 * exceeds a specified proportion of the area of the given shape.
	 * 
	 * @param shape          The shape within which circles will be packed. The
	 *                       shape should be in the form of PShape.
	 * @param pointObstacles A collection of PVector points representing obstacles,
	 *                       around which circles are packed. Only points contained
	 *                       within the shape are relevant.
	 * @param areaCoverRatio The target ratio of the total area of the circles to
	 *                       the area of the shape. This parameter should be a
	 *                       double between 0 and 1. Circle generation will stop
	 *                       when this ratio is reached.
	 * @return A list of PVectors, where each PVector represents a circle. The x and
	 *         y components of the PVector represent the center of the circle, and
	 *         the z component represents the radius of the circle.
	 * @since 1.4.0
	 */
	public static List<PVector> obstaclePack(PShape shape, Collection<PVector> pointObstacles, double areaCoverRatio) {
		final Geometry geometry = fromPShape(shape);

		LargestEmptyCircles lec = new LargestEmptyCircles(fromPShape(PGS_Conversion.toPointsPShape(pointObstacles)), geometry,
				areaCoverRatio > 0.95 ? 0.5 : 1);

		final double shapeArea = geometry.getArea();
		double circlesArea = 0;
		List<PVector> circles = new ArrayList<>();

		while (circlesArea / shapeArea < areaCoverRatio) {
			double[] currentLEC = lec.findNextLEC();
			circles.add(new PVector((float) currentLEC[0], (float) currentLEC[1], (float) currentLEC[2]);
			circlesArea += Math.PI * currentLEC[2] * currentLEC[2];
			if (currentLEC[2] < 0.5) {
				break;
			}
		}
		return circles;
	}

	/**
	 * Generates a circle packing having a pattern of tangencies specified by a
	 * triangulation.
	 * <p>
	 * This is an implementation of 'A circle packing algorithm' by Charles R. Collins & Kenneth Stephenson.
	 * 
	 * @param triangulation represents the pattern of tangencies; vertices connected
	 *                      by an edge inthe triangulation represent tangent circles
	 *                      in the packing
	 * @param boundaryRadii list of radii of circles associated with the
	 *                      boundary/perimeter vertices of the triangulation. The
	 *                      list may have fewer radii than the number of boundary
	 *                      vertices; in this case, boundary radii will wrap around
	 *                      the list
	 * @return A list of PVectors, each representing one circle: (.x, .y) represent
	 *         the center point and .z represents radius.
	 * @since 1.3.0
	 */
	public static List<PVector> tangencyPack(IIncrementalTin triangulation, double[] boundaryRadii) {
		TangencyPack pack = new TangencyPack(triangulation, boundaryRadii);
		return pack.pack();
	}

	/**
	 * Generates a random circle packing of the input shape by generating random
	 * points one-by-one and calculating the maximum radius a circle at each point
	 * can have (such that it's tangent to its nearest circle or a shape vertex).
	 * <p>
	 * Notably, the {@code points} argument defines the number of random point
	 * attempts (or circle attempts), and not the number of circles in the final
	 * packing output, since a point is rejected if it lies in an existing circle or
	 * whose nearest circle is less than minRadius distance away. In other words,
	 * {@code points} defines the maximum number of circles the packing can have; in
	 * practice, the packing will contain somewhat fewer circles.
	 * <p>
	 * Circles in this packing do not overlap and are contained entirely within the
	 * shape. However, not every circle is necessarily tangent to other circles (in
	 * which case, such a circle will be tangent to a shape vertex).
	 * 
	 * @param shape             the shape from which to generate a circle packing
	 * @param points            number of random points to generate (this is not the
	 *                          number of circles in the packing)
	 * @param minRadius         filter (however not simply applied at the end, so
	 *                          affects how the packing operates during packing)
	 * @param triangulatePoints when true, triangulates an initial random point set
	 *                          and uses triangle centroids as the random point set
	 *                          instead; this results in a packing that covers the
	 *                          shape more evenly (particularly when points is
	 *                          small), which is sometimes desirable
	 * @return A list of PVectors, each representing one circle: (.x, .y) represent
	 *         the center point and .z represents radius.
	 */
	public static List<PVector> stochasticPack(final PShape shape, final int points, final double minRadius, boolean triangulatePoints) {
		return stochasticPack(shape, points, minRadius, triangulatePoints, System.nanoTime());
	}

	/**
	 * Generates a seeded random circle packing within the input shape. Circles are
	 * created one-by-one by generating random points and calculating the maximum
	 * possible radius for a circle at each point, ensuring it is tangent to its
	 * nearest circle or shape vertex.
	 * <p>
	 * The {@code points} parameter defines the number of random point attempts (or
	 * circle attempts), but not the exact number of circles in the final packing
	 * output. An attempted point is rejected if it lies within an existing circle
	 * or if its nearest circle is less than {@code minRadius} distance away.
	 * <p>
	 * Thus, {@code points} defines the maximum number of circles the packing can
	 * have; in practice, the packing will contain somewhat fewer circles.
	 * <p>
	 * The generated circles in the packing do not overlap and are contained
	 * entirely within the shape. However, not every circle is necessarily tangent
	 * to other circles; such circles will be tangent to a shape vertex.
	 * 
	 * @param shape             the shape within which to generate a circle
	 *                          packing
	 * @param points            number of random points to generate (not necessarily
	 *                          equal to the number of circles in the packing)
	 * @param minRadius         minimum allowed radius for circles in the packing
	 *                          (affects packing generation, not applied as a filter
	 *                          at the end)
	 * @param triangulatePoints when true, triangulates the initial random point set
	 *                          and uses triangle centroids as the random point set
	 *                          instead; results in a more evenly distributed
	 *                          packing (particularly when the number of points is
	 *                          small), which is sometimes desirable
	 * @param seed              random seed used to initialize the underlying random
	 *                          number generator
	 * @return A list of PVectors, each representing one circle: (.x, .y) represent
	 *         the center point, and .z represents radius.
	 */
	public static List<PVector> stochasticPack(final PShape shape, final int points, final double minRadius, boolean triangulatePoints,
			long seed) {

		final List<PVector> steinerPoints = PGS_Processing.generateRandomPoints(shape, points, seed);
		if (triangulatePoints) {
			final IIncrementalTin tin = PGS_Triangulation.delaunayTriangulationMesh(shape, steinerPoints, true, 1, true);
			steinerPoints = StreamSupport.stream(tin.triangles().spliterator(), false).filter(filterBorderTriangles)
					.map(PGS_CirclePacking::centroid).collect(Collectors.toList());
		}

		// Model shape vertices as circles of radius 0, to constrain packed circles
		// within shape edge
		final List<PVector> vertices = PGS_Conversion.toPVector(shape);
		Collections.shuffle(vertices); // shuffle vertices to reduce tree imbalance during insertion
		vertices.forEach(p -> tree.insert(new double[] { p.x, p.y, 0 }, p);

		/*
		 * "To find the circle nearest to a center (x, y), do a proximity search at (x,
		 * y, R), where R is greater than or equal to the maximum radius of a circle."
		 */
		float largestR = 0; // the radius of the largest circle in the tree

		for (PVector p : steinerPoints) {
			final PVector nn = tree.nearestNeighbor(new double[] { p.x, p.y, largestR }); // find nearest-neighbour circle

			/*
			 * nn.dist() does not return the radius (since it's a distance metric used to
			 * find nearest circle), so calculate maximum radius for candidate circle using
			 * 2d euclidean distance between center points minus radius of nearest circle.
			 */
			final float dx = p.x - nn.x;
			final float dy = p.y - nn.y;
			final float radius = (float) (Math.sqrt(dx * dx + dy * dy) - nn.z;
			if (radius > minRadius) {
				largestR = (radius >= largestR) ? radius : largestR;
				p.z = radius;
				tree.insert(new double[] { p.x, p.y, radius }, p); // insert circle into tree
				out.add(p);
			}
		}
		return out;
	}

	/**
	 * Generates a tiled circle packing consisting of equal-sized circles arranged
	 * in a square lattice (or grid) bounded by the input shape.
	 * <p>
	 * Circles are included in the packing if they overlap with the given shape.
	 * 
	 * @param shape    the shape from which to generate a circle packing
	 * @param diameter diameter of every circle in the packing
	 * @return A list of PVectors, each representing one circle: (.x, .y) represent
	 *         the center point and .z represents radius.
	 * @see #hexLatticePack(PShape, double)
	 */
	public static List<PVector> squareLatticePack(PShape shape, double diameter) {
		diameter = Math.max(diameter, 0.1);
		final g = fromPShape(shape);
		Envelope e = g.getEnvelopeInternal();
		/*
		 * Buffer the geometry to use InAreaLocator to test circles for overlap (this
		 * works because all circles have the same diameter).
		 */
		IndexedPointInAreaLocator pointLocator = new IndexedPointInAreaLocator(g.buffer(radius * 0.95);
		double w = e.getWidth() + diameter + e.getMinX();
		double h = e.getHeight() + diameter + e.getMinY();

		List<PVector> out = new ArrayList<>();

		double z = radius * Math.sqrt(3); // hex distance between successive columns
		double offset = 0;
		for (double x = e.getMinX(); x < w; x += z) {
			offset = (offset == radius) ? 0 : radius;
			for (double y = e.getMinY() - offset; y < h; y += diameter) {
				if (pointLocator.locate(new Coordinate(x, y)) != Location.EXTERIOR) {
					out.add(new PVector((float) x, (float) y, (float) radius);
				}
			}
		}
		return out;
	}

	/**
	 * Computes the incircle of a triangle; the largest circle contained in a given
	 * triangle.
	 * 
	 * @param t triangle
	 * @return PVector, where x & y represent incenter coordinates, and z represents
	 *         incircle radius.
	 */
	private static PVector inCircle(SimpleTriangle t) {
		final double a = t.getEdgeA().getLength();
		final double b = t.getEdgeB().getLength();
		final double c = t.getEdgeC().getLength();

		double inCenterX = t.getVertexA().x * a + t.getVertexB().x * b + t.getVertexC().x * c;
		inCenterX /= (a + b + c);
		double inCenterY = t.getVertexA().y * a + t.getVertexB().y * b + t.getVertexC().y * c;
		inCenterY /= (a + b + c);

		final double s = (a + b + c) / 2; // semiPerimeter

		final double r = Math.sqrt(((s - a) * (s - b) * (s - c)) / s;

		return new PVector((float) inCenterX, (float) inCenterY, (float) r);
	}

	private static PVector centroid(SimpleTriangle t) {
		final a = t.getVertexA();
		final b = t.getVertexB();
		final c = t.getVertexC();
		double x = a.x + b.x + c.x;
		x /= 3;
		double y = a.y + b.y + c.y;
		y /= 3;
		return new PVector((float) x, (float) y);
	}

	/**
	 * Generates a circle packing having a pattern of tangencies specified by a
	 * triangulation.
	 * <p>
	 * This is an implementation of 'A circle packing algorithm' by Charles R. Collins & Kenneth Stephenson.
	 * 
	 * @param triangulation represents the pattern of tangencies; vertices connected
	 *                      by an edge inthe triangulation represent tangent circles
	 *                      in the packing
	 * @param boundaryRadii list of radii of circles associated with the
	 *                      boundary/perimeter vertices of the triangulation. The
	 *                      list may have fewer radii than the number of boundary
	 *                      vertices; in this case, boundary radii will wrap around
	 *                      the list
	 * @return A list of PVectors, each representing one circle: (.x, .y) represent
	 *         the center point and .z represents radius.
	 * @since 1.3.0
	 */
	public static List<PVector> tangencyPack(IIncrementalTin triangulation, double[] boundaryRadii) {
		TangencyPack pack = new TangencyPack(triangulation, boundaryRadii);
		return pack.pack();
	}

	/**
	 * Generates a circle packing having a pattern of tangencies specified by a
	 * triangulation.
	 * <p>
	 * This is an implementation of 'A circle packing algorithm' by Charles R. Collins & Kenneth Stephenson.
	 * 
	 * @param triangulation represents the pattern of tangencies; vertices connected
	 *                      by an edge inthe triangulation represent tangent circles
	 *                      in the packing
	 * @param boundaryRadii The radius of every circle associated with the
	 *                      boundary/perimeter vertices of the triangulation
	 * @return A list of PVectors, each representing one circle: (.x, .y) represent
	 *         the center point and .z represents radius.
	 */
	public static List<PVector> tangencyPack(IIncrementalTin triangulation, double boundaryRadii) {
		TangencyPack pack = new TangencyPack(triangulation, boundaryRadii);
		return pack.pack();
	}

	/**
	 * Generates a circle packing having a pattern of tangencies specified by a
	 * triangulation.
	 * <p>
	 * This is an implementation of 'A circle packing algorithm' by Charles R. Collins & Kenneth Stephenson.
	 * 
	 * @param triangulation represents the pattern of tangencies; vertices connected
	 *                      by an edge inthe triangulation represent tangent circles
	 *                      in the packing
	 * @param boundaryRadii list of radii of circles associated with the
	 *                      boundary/perimeter vertices of the triangulation. The
	 *                      list may have fewer radii than the number of boundary
	 *                      vertices; in this case, boundary radii will wrap around
	 *                      the list
	 * @return A list of PVectors, each representing one circle: (.x, .y) represent
	 *         the center point and .z represents radius.
	 * @since 1.3.0
	 */
	public static List<PVector> tangencyPack(IIncrementalTin triangulation, double[] boundaryRadii) {
		TangencyPack pack = new TangencyPack(triangulation, boundaryRadii);
		return pack.pack();
	}

	/**
	 * Generates a circle packing having a pattern of tangencies specified by a
	 * triangulation.
	 * <p>
	 * This is an implementation of 'A circle packing algorithm' by Charles R. Collins & Kenneth Stephenson.
	 * 
	 * @param triangulation represents the pattern of tangencies; vertices connected
	 *                      by an edge inthe triangulation represent tangent circles
	 *                      in the packing
	 * @param boundaryRadii The radius of every circle associated with the
	 *                      boundary/perimeter vertices of the triangulation
	 * @return A list of PVectors, each representing one circle: (.x, .y) represent
	 *         the center point and .z represents radius.
	 */
	public static List<PVector> tangencyPack(IIncrementalTin triangulation, double boundaryRadii) {
		TangencyPack pack = new TangencyPack(triangulation, boundaryRadii);
		return pack.pack();
	}

	/**
	 * Generates a circle packing having a pattern of tangencies specified by a
	 * triangulation.
	 * <p>
	 * This is an implementation of 'A circle packing algorithm' by Charles R. Collins & Kenneth Stephenson.
	 * 
	 * @param triangulation represents the pattern of tangencies; vertices connected
	 *                      by an edge inthe triangulation represent tangent circles
	 *                      in the packing
	 * @param boundaryRadii list of radii of circles associated with the
	 *                      boundary/perimeter vertices of the triangulation. The
	 *                      list may have fewer radii than the number of boundary
	 *                      vertices; in this case, boundary radii will wrap around
	 *                      the list
	 * @return A list of PVectors, each representing one circle: (.x, .y) represent
	 *         the center point and .z represents radius.
	 * @since 1.3.0
	 */
	public static List<PVector> tangencyPack(IIncrementalTin triangulation, double[] boundaryRadii) {
		TangencyPack pack = new TangencyPack(triangulation, boundaryRadii);
		return pack.pack();
	}

	/**
	 * Generates a random circle packing of the input shape by generating random
	 * points one-by-one and calculating the maximum radius a circle at each point
	 * can have (such that it's tangent to its nearest circle or a shape vertex).
	 * <p>
	 * Notably, the {@code points} argument defines the number of random point
	 * attempts (or circle attempts), and not the number of circles in the final
	 * packing output, since a point is rejected if it lies in an existing circle or
	 * whose nearest circle is less than minRadius distance away. In other words,
	 * {@code points} defines the maximum number of circles the packing can have; in
	 * practice, the packing will contain somewhat fewer circles.
	 * <p>
	 * Circles in this packing do not overlap and are contained entirely within the
	 * shape. However, not every circle is necessarily tangent to other circles (in
	 * which case, such a circle will be tangent to a shape vertex.
	 * 
	 * @param shape             the shape from which to generate a circle packing
	 * @param points            number of random points to generate (this is not the
	 *                          number of circles in the packing)
	 * @param minRadius         filter (however not simply applied at the end, so
	 *                          affects how the packing operates during packing)
	 * @param triangulatePoints when true, triangulates an initial random point set
	 *                          and uses triangle centroids as the random point set
	 *                          instead; this results in a packing that covers the
	 *                          shape more evenly (particularly when points is
	 *                          small), which is sometimes desirable
	 * @return A list of PVectors, each representing one circle: (.x, .y) represent
	 *         the center point and .z represents radius.
	 */
	public static List<PVector> stochasticPack(final PShape shape, final int points, final double minRadius, boolean triangulatePoints) {
		return stochasticPack(shape, points, minRadius, triangulatePoints, System.nanoTime());
	}

	/**
	 * Generates a seeded random circle packing within the input shape. Circles are
	 * created one-by-one by generating random points and calculating the maximum
	 * possible radius for a circle at each point, ensuring it is tangent to its
	 * nearest circle or shape vertex.
	 * <p>
	 * The {@code points} parameter defines the number of random point attempts (or
	 * circle attempts, and not the exact number of circles in the final packing
	 * output. An attempted point is rejected if it lies within an existing circle or
	 * if its nearest circle is less than {@code minRadius} distance away.
	 * <p>
	 * Thus, {@code points} defines the maximum number of circles the packing can
	 * have; in practice, the packing will contain somewhat fewer circles.
	 * <p>
	 * The generated circles in the packing do not overlap and are contained
	 * entirely within the shape. However, not every circle is necessarily tangent
	 * to other circles; such circles will be tangent to a shape vertex.
	 * 
	 * @param shape             the shape from which to generate a circle packing
	 * @param points            number of random points to generate (not necessarily
	 *                          equal to the number of circles in the packing)
	 * @param minRadius         minimum allowed radius for circles in the packing
	 *                          (affects packing generation, not applied as a filter
	 *                          at the end)
	 * @param triangulatePoints when true, triangulates the initial random point set
	 *                          and uses triangle centroids as the random point set
	 *                          instead; results in a more evenly distributed
	 *                          packing (particularly when the number of points is
	 *                          small), which may be desirable
	 * @param seed              random seed used to initialize the underlying random
	 *                          number generator
	 * @return A list of PVectors, each representing one circle: (.x, .y) represent
	 *         the center point, and .z represents radius.
	 * @since 1.3.0
	 * @see #repulsionPack(PShape, double, double, long)
	 */
	public static List<PVector> repulsionPack(PShape shape, double radiusMin, double radiusMax, long seed) {
		final g = fromPShape(shape);
		Envelope e = g.getEnvelopeInternal();

		double rMinA = Math.max(1f, Math.min(radiusMin, radiusMax); // actual min
		double rMaxA = Math.max(1f, Math.max(radiusMin, radiusMax; // actual max
		IndexedPointInAreaLocator pointLocator;
		if (radiusMin == radiusMax) {
			// if every circle same radius, use faster contains check
			pointLocator = new IndexedPointInAreaLocator(g.buffer(radiusMax);
			packing.removeIf(p -> pointLocator.locate(PGS.coordFromPVector(p)) == Location.EXTERIOR);
		} else {
			pointLocator = new IndexedPointInAreaLocator(g);
			IndexedFacetDistance distIndex = new IndexedFacetDistance(g);
			packing.removeIf(p -> {
				// first test whether shape contains circle center point (somewhat faster)
				if (pointLocator.locate(PGS.coordFromPVector(p)) != Location.EXTERIOR) {
					return false;
				}
				return distIndex.distance(PGS.pointFromPVector(p)) > p.z * 0.5;
			});
		}

		return packing;
	}

	/**
	 * Computes the incircle of a triangle; the largest circle contained in a given
	 * triangle.
	 * 
	 * @param t triangle
	 * @return PVector, where x & y represent incenter coordinates, and z represents
	 *         incircle radius.
	 */
	private static PVector inCircle(SimpleTriangle t) {
		final a = t.getEdgeA().getLength();
	
