```java
/*
 * Copyright 2014 Feedzai
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.feedzai.commons.sql.abstraction.engine.impl.abs;

import com.feedzai.commons.sql.abstraction.ddl.AlterColumn;
import com.feedzai.commons.sql.abstraction.ddl.DbColumn;
import com.feedzai.commons.sql.abstraction.ddl.DbColumnConstraint;
import com.feedzai.commons.sql.abstraction.ddl.DbColumnType;
import com.feedzai.commons.sql.abstraction.ddl.DbEntity;
import com.feedzai.commons.sql.abstraction.ddl.Rename;
import com.feedzai.commons.sql.abstraction.dml.K;
import com.feedzai.commons.sql.abstraction.dml.Query;
import com.feedzai.commons.sql.abstraction.dml.Truncate;
import com.feedzai.commons.sql.abstraction.dml.Update;
import com.feedzai.commons.sql.abstraction.dml.Values;
import com.feedzai.commons.sql.abstraction.dml.With;
import com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder;
import com.feedzai.commons.sql.abstraction.dml.result.ResultColumn;
import com.feedzai.commons.sql.abstraction.dml.result.ResultIterator;
import com.feedzai.commons.sql.abstraction.engine.DatabaseEngine;
import com.feedzai.commons.sql.abstraction.engine.DatabaseEngineException;
import com.feedzai.commons.sql.abstraction.engine.DatabaseEngineRuntimeException;
import com.feedzai.commons.sql.abstraction.engine.DatabaseEngineUniqueConstraintViolationException;
import com.feedzai.commons.sql.abstraction.engine.DatabaseFactory;
import com.feedzai.commons.sql.abstraction.engine.DatabaseFactoryException;
import com.feedzai.commons.sql.abstraction.engine.MappedEntity;
import com.feedzai.commons.sql.abstraction.engine.NameAlreadyExistsException;
import com.feedzai.commons.sql.abstraction.engine.OperationNotSupportedRuntimeException;
import com.feedzai.commons.sql.abstraction.engine.testconfig.BlobTest;
import com.feedzai.commons.sql.abstraction.engine.testconfig.DatabaseConfiguration;
import com.feedzai.commons.sql.abstraction.engine.testconfig.DatabaseTestUtil;
import com.feedzai.commons.sql.abstraction.entry.EntityEntry;
import com.feedzai.commons.sql.abstraction.exceptions.DatabaseEngineUniqueConstraintViolationException;
import com.feedzai.commons.sql.abstraction.util.StringUtils;
import com.feedzai.commons.sql.abstraction.engine.configuration.PdbProperties;
import java.io.ByteArrayOutputStream;
import java.io.ObjectOutputStream;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.UUID;
import java.util.concurrent.ThreadLocalRandom;
import java.util.concurrent.atomic.AtomicReference;
import java.util.stream.Collectors;
import java.util.stream.IntStream;
import org.junit.After;
import org.junit.Assume;
import org.junit.Before;
import org.junit.Test;
import org.junit.experimental.categories.Category;
import org.junit.runner.RunWith;
import org.junit.runners.Parameterized;
import org.slf4j.LoggerFactory;

// Removed references to ch.qos.logback.classic.Logger and related classes.

@RunWith(Parameterized.class)
public class EngineGeneralTest {

    protected DatabaseEngine engine;
    protected Properties properties;
    protected DatabaseConfiguration config;

    @Parameterized.Parameters
    public static Collection<DatabaseConfiguration> data() throws Exception {
        return DatabaseTestUtil.loadConfigurations();
    }

    // The original initStatic method setting the logger level has been removed
    // due to API changes in the dependency.

    @Before
    public void init() throws DatabaseFactoryException {
        properties = new Properties();
        properties.put(PdbProperties.ENGINE, config.getEngine());
        properties.put(PdbProperties.JDBC, config.getJdbc());
        properties.put(PdbProperties.USERNAME, config.getUsername());
        properties.put(PdbProperties.PASSWORD, config.getPassword());
        properties.put(PdbProperties.SCHEMA_POLICY, config.getSchemaPolicy());
        engine = DatabaseFactory.getConnection(properties);
    }

    @After
    public void cleanup() throws Exception {
        engine.close();
    }

    @Test
    public void createAndDropViewTest() throws DatabaseEngineException {
        create5ColumnsEntity();

        engine.executeUpdate(
                SqlBuilder.createView("VN").as(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")))
        );

        engine.dropView("VN");
    }

    @Test
    @Category(SkipTestCockroachDB.class)
    public void createOrReplaceViewTest() throws DatabaseEngineException {
        create5ColumnsEntity();

        engine.executeUpdate(
                SqlBuilder.createView("VN").as(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST"))).replace()
        );

        engine.dropView("VN");
    }

    @Test
    public void distinctTest() throws DatabaseEngineException {
        create5ColumnsEntity();

        engine.query(
                SqlBuilder.select(SqlBuilder.all()).distinct()
                        .from(SqlBuilder.table("TEST"))
        );
    }

    @Test
    public void distinctAndLimitTogetherTest() throws DatabaseEngineException {
        create5ColumnsEntity();

        engine.query(
                SqlBuilder.select(SqlBuilder.all()).distinct()
                        .from(SqlBuilder.table("TEST")).limit(2)
        );
    }

    @Test
    public void notEqualTest() throws DatabaseEngineException {
        create5ColumnsEntity();

        engine.query(
                SqlBuilder.select(SqlBuilder.all())
                        .from(SqlBuilder.table("TEST"))
                        .where(SqlBuilder.neq(SqlBuilder.column("COL1"), K.k(1)))
        );
    }

    @Test
    public void inTest() throws DatabaseEngineException {
        runInClauseTest(SqlBuilder.in(SqlBuilder.column("COL1"), SqlBuilder.L(K.k(1))));
    }

    @Test
    public void inSelectTest() throws DatabaseEngineException {
        runInClauseTest(SqlBuilder.in(
                SqlBuilder.column("COL1"),
                SqlBuilder.select(SqlBuilder.column("COL1")).from(SqlBuilder.table("TEST")).where(SqlBuilder.eq(SqlBuilder.column("COL1"), K.k(1)))
        ));
    }

    @Test
    public void inManyValuesTest() throws DatabaseEngineException {
        final List<SqlBuilder.Expression> numExprs = IntStream.rangeClosed(-19998, 1)
                .mapToObj(K::k)
                .collect(Collectors.toList());

        runInClauseTest(SqlBuilder.in(SqlBuilder.column("COL1"), SqlBuilder.L(numExprs)));
    }

    @Test
    public void notInTest() throws DatabaseEngineException {
        runInClauseTest(SqlBuilder.notIn(SqlBuilder.column("COL1"), SqlBuilder.L(K.k(2))));
    }

    @Test
    public void notInSelectTest() throws DatabaseEngineException {
        runInClauseTest(SqlBuilder.notIn(
                SqlBuilder.column("COL1"),
                SqlBuilder.select(SqlBuilder.column("COL1")).from(SqlBuilder.table("TEST")).where(SqlBuilder.eq(SqlBuilder.column("COL1"), K.k(2)))
        ));
    }

    @Test
    public void notInManyValuesTest() throws DatabaseEngineException {
        final List<SqlBuilder.Expression> numExprs = IntStream.rangeClosed(2, 20001)
                .mapToObj(K::k)
                .collect(Collectors.toList());

        runInClauseTest(SqlBuilder.notIn(SqlBuilder.column("COL1"), SqlBuilder.L(numExprs)));
    }

    private void runInClauseTest(final SqlBuilder.Expression whereInExpression) throws DatabaseEngineException {
        create5ColumnsEntity();

        engine.persist("TEST", EntityEntry.entry().set("COL1", 1).set("COL5", "s1").build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 2).set("COL5", "s2").build());

        final List<Map<String, ResultColumn>> results = engine.query(
                SqlBuilder.select(SqlBuilder.all())
                        .from(SqlBuilder.table("TEST"))
                        .where(whereInExpression)
        );

        org.assertj.core.api.Assertions.assertThat(results)
                .as("query should return only 1 result")
                .hasSize(1)
                .element(0)
                .as("result should have have value '1'")
                .extracting(result -> result.get("COL1").toInt())
                .isEqualTo(1);
    }

    @Test
    public void booleanTrueComparisonTest() throws DatabaseEngineException {
        create5ColumnsEntity();

        EntityEntry entry1 = EntityEntry.entry()
                .set("COL1", 1)
                .set("COL2", true)
                .set("COL3", 1)
                .set("COL4", 1)
                .set("COL5", "val 1")
                .build();
        engine.persist("TEST", entry1, false);

        EntityEntry entry2 = EntityEntry.entry()
                .set("COL1", 1)
                .set("COL2", false)
                .set("COL3", 1)
                .set("COL4", 1)
                .set("COL5", "val 1")
                .build();
        engine.persist("TEST", entry2, false);

        List<Map<String, ResultColumn>> rows = engine.query(
                SqlBuilder.select(SqlBuilder.all())
                        .from(SqlBuilder.table("TEST"))
                        .where(
                                SqlBuilder.eq(SqlBuilder.column("COL2"), K.k(true))
                        )
        );

        org.junit.Assert.assertEquals(1, rows.size());
    }

    @Test
    public void booleanFalseComparisonTest() throws DatabaseEngineException {
        create5ColumnsEntity();

        EntityEntry entry1 = EntityEntry.entry()
                .set("COL1", 1)
                .set("COL2", true)
                .set("COL3", 1)
                .set("COL4", 1)
                .set("COL5", "val 1")
                .build();
        engine.persist("TEST", entry1, false);

        EntityEntry entry2 = EntityEntry.entry()
                .set("COL1", 1)
                .set("COL2", false)
                .set("COL3", 1)
                .set("COL4", 1)
                .set("COL5", "val 1")
                .build();
        engine.persist("TEST", entry2, false);

        List<Map<String, ResultColumn>> rows = engine.query(
                SqlBuilder.select(SqlBuilder.all())
                        .from(SqlBuilder.table("TEST"))
                        .where(
                                SqlBuilder.eq(SqlBuilder.column("COL2"), K.k(false))
                        )
        );

        org.junit.Assert.assertEquals(1, rows.size());
    }

    @Test
    public void coalesceTest() throws DatabaseEngineException {
        create5ColumnsEntity();

        engine.query(
                SqlBuilder.select(SqlBuilder.all())
                        .from(SqlBuilder.table("TEST"))
                        .where(
                                SqlBuilder.eq(SqlBuilder.coalesce(SqlBuilder.column("COL2"), K.k(false)), K.k(false))
                        )
        );
    }

    @Test
    public void multipleCoalesceTest() throws DatabaseEngineException {
        create5ColumnsEntity();

        engine.query(
                SqlBuilder.select(SqlBuilder.all())
                        .from(SqlBuilder.table("TEST"))
                        .where(
                                SqlBuilder.eq(SqlBuilder.coalesce(SqlBuilder.column("COL2"), K.k(false), K.k(true)), K.k(false))
                        )
        );
    }

    @Test
    public void betweenTest() throws DatabaseEngineException {
        create5ColumnsEntity();

        engine.query(
                SqlBuilder.select(SqlBuilder.all())
                        .from(SqlBuilder.table("TEST"))
                        .where(
                                SqlBuilder.between(SqlBuilder.column("COL1"), K.k(1), K.k(2))
                        )
        );
    }

    @Test
    public void testCast() throws DatabaseEngineException {

        final Query query = SqlBuilder.select(
                SqlBuilder.cast(K.k("22"), DbColumnType.INT).alias("int"),
                SqlBuilder.cast(K.k(22), DbColumnType.STRING).alias("string"),
                SqlBuilder.cast(K.k("1"), DbColumnType.BOOLEAN).alias("bool"),
                SqlBuilder.cast(K.k("22"), DbColumnType.DOUBLE).alias("double"),
                SqlBuilder.cast(K.k(22), DbColumnType.LONG).alias("long")
        );

        final Map<String, ResultColumn> result = engine.query(query).get(0);

        org.junit.Assert.assertEquals("Result must be 22", new Integer(22), result.get("int").toInt());
        org.junit.Assert.assertEquals("Result must be '22'", "22", result.get("string").toString());
        org.junit.Assert.assertEquals("Result must be true", true, result.get("bool").toBoolean());
        org.junit.Assert.assertEquals("Result must be 22.0", new Double(22), result.get("double").toDouble());
        org.junit.Assert.assertEquals("Result must be 22", new Long(22), result.get("long").toLong());
    }

    @Test
    public void testCastColumns() throws DatabaseEngineException {

        final DbEntity entity = SqlBuilder.dbEntity()
                .name("TEST")
                .addColumn("COL_INT", DbColumnType.INT)
                .addColumn("COL_STRING", DbColumnType.STRING)
                .addColumn("COL_CAST_INT", DbColumnType.INT)
                .addColumn("COL_CAST_STRING", DbColumnType.STRING)
                .pkFields("COL_INT")
                .build();

        engine.addEntity(entity);

        EntityEntry entry = EntityEntry.entry()
                .set("COL_INT", 123)
                .set("COL_STRING", "321")
                .build();

        engine.persist("TEST", entry);

        final Update update = SqlBuilder.update(SqlBuilder.table("TEST"))
                .set(
                        SqlBuilder.eq(SqlBuilder.column("COL_CAST_INT"), SqlBuilder.cast(K.k("3211"), DbColumnType.INT)),
                        SqlBuilder.eq(SqlBuilder.column("COL_CAST_STRING"), SqlBuilder.cast(K.k(1233), DbColumnType.STRING))
                )
                .where(SqlBuilder.eq(SqlBuilder.column("COL_INT"), K.k(123)));

        engine.executeUpdate(update);

        Query query =
                SqlBuilder.select(
                        SqlBuilder.cast(SqlBuilder.column("COL_INT"), DbColumnType.STRING).alias("COL_INT_string"),
                        SqlBuilder.cast(SqlBuilder.column("COL_STRING"), DbColumnType.INT).alias("COL_STRING_int"),
                        SqlBuilder.column("COL_CAST_INT"),
                        SqlBuilder.column("COL_CAST_STRING")
                ).from(SqlBuilder.table("TEST"));

        Map<String, ResultColumn> result = engine.query(query).get(0);

        org.junit.Assert.assertEquals("The value of COL_INT cast to string must be '123'", "123", result.get("COL_INT_string").toString());
        org.junit.Assert.assertEquals("The value of COL_STRING cast to int must be 321", new Integer(321), result.get("COL_STRING_int").toInt());
        org.junit.Assert.assertEquals("The value of COL_CAST_INT must be 3211", Integer.valueOf(3211), result.get("COL_CAST_INT").toInt());
        org.junit.Assert.assertEquals("The value of COL_CAST_STRING must be '1233'", "1233", result.get("COL_CAST_STRING").toString());

        entry = EntityEntry.entry()
                .set("COL_INT", 1000)
                .set("COL_STRING", "321000")
                .build();

        engine.persist("TEST", entry);

        query = SqlBuilder.select(SqlBuilder.column("COL_INT")).from(SqlBuilder.table("TEST")).orderby(SqlBuilder.column("COL_INT"));
        String firstResult = engine.query(query).get(0).get("COL_INT").toString();
        org.junit.Assert.assertEquals("sorting should have considered the sort column as a number (123 < 1000)", "123", firstResult);

        query = SqlBuilder.select(SqlBuilder.column("COL_INT"), SqlBuilder.cast(SqlBuilder.column("COL_INT"), DbColumnType.STRING).alias("COL_INT_string"))
                .from(SqlBuilder.table("TEST"))
                .orderby(SqlBuilder.column("COL_INT_string"));
        firstResult = engine.query(query).get(0).get("COL_INT").toString();
        org.junit.Assert.assertEquals("sorting should have considered the sort column as a string (1000 < 123)", "1000", firstResult);
    }

    @Test(expected = OperationNotSupportedRuntimeException.class)
    public void testCastUnsupported() throws DatabaseEngineException {
        engine.query(SqlBuilder.select(SqlBuilder.cast(K.k("22"), DbColumnType.BLOB)));
    }

    @Test
    public void testWith() throws DatabaseEngineException {
        Assume.assumeFalse("MySQL doesn't support WITH", engine.getDialect() == SqlBuilder.Dialect.MYSQL);

        create5ColumnsEntity();

        engine.persist("TEST", EntityEntry.entry().set("COL1", 1).set("COL5", "manuel")
                .build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 2).set("COL5", "ana")
                .build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 3).set("COL5", "rita")
                .build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 4).set("COL5", "rui")
                .build());

        final With with = SqlBuilder.with("friends", SqlBuilder.select(SqlBuilder.all())
                                                .from(SqlBuilder.table("TEST")))
                .then(
                        SqlBuilder.select(SqlBuilder.column("COL5").alias("name"))
                        .from(SqlBuilder.table("friends"))
                        .where(SqlBuilder.eq(SqlBuilder.column("COL1"), K.k(1))));

        final List<Map<String, ResultColumn>> result = engine.query(with);

        org.junit.Assert.assertEquals("Name must be 'manuel'", "manuel", result.get(0).get("name").toString());
    }

    @Test
    public void testWithAll() throws DatabaseEngineException {
        Assume.assumeFalse("MySQL doesn't support WITH", engine.getDialect() == SqlBuilder.Dialect.MYSQL);

        create5ColumnsEntity();

        engine.persist("TEST", EntityEntry.entry().set("COL1", 1).set("COL5", "manuel")
                .build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 2).set("COL5", "ana")
                .build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 3).set("COL5", "rita")
                .build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 4).set("COL5", "rui")
                .build());

        final With with =
                SqlBuilder.with("friends",
                        SqlBuilder.select(SqlBuilder.all())
                        .from(SqlBuilder.table("TEST")))
                .then(
                        SqlBuilder.select(SqlBuilder.column("COL5").alias("name"))
                        .from(SqlBuilder.table("friends"))
                        .orderby(SqlBuilder.column("COL5")));

        final List<Map<String, ResultColumn>> result = engine.query(with);

        org.junit.Assert.assertEquals("Name must be 'ana'", "ana", result.get(0).get("name").toString());
        org.junit.Assert.assertEquals("Name must be 'manuel'", "manuel", result.get(1).get("name").toString());
        org.junit.Assert.assertEquals("Name must be 'rita'", "rita", result.get(2).get("name").toString());
        org.junit.Assert.assertEquals("Name must be 'rui'", "rui", result.get(3).get("name").toString());
    }

    @Test
    public void testWithMultiple() throws DatabaseEngineException {
        Assume.assumeFalse("MySQL doesn't support WITH", engine.getDialect() == SqlBuilder.Dialect.MYSQL);

        create5ColumnsEntity();

        engine.persist("TEST", EntityEntry.entry().set("COL1", 1).set("COL5", "manuel")
                .build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 2).set("COL5", "ana")
                .build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 3).set("COL5", "rita")
                .build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 4).set("COL5", "rui")
                .build());

        final With with =
                SqlBuilder.with("friendsA",
                        SqlBuilder.select(SqlBuilder.all())
                        .from(SqlBuilder.table("TEST"))
                        .where(SqlBuilder.or(SqlBuilder.eq(SqlBuilder.column("COL1"), K.k(1)), SqlBuilder.eq(SqlBuilder.column("COL1"), K.k(2)))))
                .andWith("friendsB",
                        SqlBuilder.select(SqlBuilder.all())
                        .from(SqlBuilder.table("TEST"))
                        .where(SqlBuilder.or(SqlBuilder.eq(SqlBuilder.column("COL1"), K.k(3)), SqlBuilder.eq(SqlBuilder.column("COL1"), K.k(4)))))
                .then(
                        SqlBuilder.union(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("friendsA")),
                                       SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("friendsB")))
                );

        final List<Map<String, ResultColumn>> result = engine.query(with);

        final List<String> resultSorted = result.stream()
                .map(row -> row.get("COL5").toString())
                .sorted()
                .collect(Collectors.toList());

        org.junit.Assert.assertEquals("Name must be 'ana'", "ana", resultSorted.get(0));
        org.junit.Assert.assertEquals("Name must be 'manuel'", "manuel", resultSorted.get(1));
        org.junit.Assert.assertEquals("Name must be 'rita'", "rita", resultSorted.get(2));
        org.junit.Assert.assertEquals("Name must be 'rui'", "rui", resultSorted.get(3));
    }

    @Test
    public void testCaseWhen() throws DatabaseEngineException {
        create5ColumnsEntity();

        engine.persist("TEST", EntityEntry.entry().set("COL1", 1).set("COL5", "teste").build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 2).set("COL5", "xpto").build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 3).set("COL5", "xpto").build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 4).set("COL5", "teste").build());

        List<Map<String, ResultColumn>> result = engine.query(
                SqlBuilder.select(SqlBuilder.caseWhen().when(SqlBuilder.eq(SqlBuilder.column("COL5"), K.k("teste")), K.k("LOL")).alias("case"))
                        .from(SqlBuilder.table("TEST"))
        );

        org.junit.Assert.assertEquals("COL5 must be LOL", "LOL", result.get(0).get("case").toString());
        org.junit.Assert.assertEquals("COL5 must be LOL", "LOL", result.get(3).get("case").toString());
    }

    @Test
    public void testCaseWhenElse() throws DatabaseEngineException {
        create5ColumnsEntity();
        engine.persist("TEST", EntityEntry.entry().set("COL1", 1).set("COL5", "teste").build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 2).set("COL5", "xpto").build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 3).set("COL5", "xpto").build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 4).set("COL5", "teste").build());

        List<Map<String, ResultColumn>> result = engine.query(
                SqlBuilder.select(
                        SqlBuilder.caseWhen().when(SqlBuilder.eq(SqlBuilder.column("COL5"), K.k("teste")), K.k("LOL"))
                                .otherwise(K.k("ROFL")).alias("case"))
                        .from(SqlBuilder.table("TEST"))
        );

        org.junit.Assert.assertEquals("COL5 must be LOL", "LOL", result.get(0).get("case").toString());
        org.junit.Assert.assertEquals("COL5 must be ROFL", "ROFL", result.get(1).get("case").toString());
        org.junit.Assert.assertEquals("COL5 must be ROFL", "ROFL", result.get(2).get("case").toString());
        org.junit.Assert.assertEquals("COL5 must be LOL", "LOL", result.get(3).get("case").toString());
    }

    @Test
    public void testCaseMultipleWhenElse() throws DatabaseEngineException {
        create5ColumnsEntity();
        engine.persist("TEST", EntityEntry.entry().set("COL1", 1).set("COL5", "teste").build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 2).set("COL5", "xpto").build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 3).set("COL5", "xpto").build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 4).set("COL5", "teste").build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 5).set("COL5", "pomme de terre").build());

        List<Map<String, ResultColumn>> result = engine.query(
                SqlBuilder.select(SqlBuilder.caseWhen().when(SqlBuilder.eq(SqlBuilder.column("COL5"), K.k("teste")), K.k("LOL"))
                                .when(SqlBuilder.eq(SqlBuilder.column("COL5"), K.k("pomme de terre")), K.k("KEK"))
                                .otherwise(K.k("ROFL")).alias("case"))
                        .from(SqlBuilder.table("TEST"))
        );

        org.junit.Assert.assertEquals("COL5 must be LOL", "LOL", result.get(0).get("case").toString());
        org.junit.Assert.assertEquals("COL5 must be ROFL", "ROFL", result.get(1).get("case").toString());
        org.junit.Assert.assertEquals("COL5 must be ROFL", "ROFL", result.get(2).get("case").toString());
        org.junit.Assert.assertEquals("COL5 must be LOL", "LOL", result.get(3).get("case").toString());
        org.junit.Assert.assertEquals("COL5 must be KEK", "KEK", result.get(4).get("case").toString());
    }

    @Test
    public void testConcat() throws DatabaseEngineException {
        final List<Map<String, ResultColumn>> result = queryConcat(K.k("."));

        org.junit.Assert.assertEquals("teste.teste", result.get(0).get("concat").toString());
        org.junit.Assert.assertEquals("xpto.xpto", result.get(1).get("concat").toString());
        org.junit.Assert.assertEquals("xpto.xpto", result.get(2).get("concat").toString());
        org.junit.Assert.assertEquals("teste.teste", result.get(3).get("concat").toString());
        org.junit.Assert.assertEquals("pomme de terre.pomme de terre", result.get(4).get("concat").toString());
    }

    @Test
    public void testConcatEmpty() throws DatabaseEngineException {
        final List<Map<String, ResultColumn>> result = queryConcat(K.k(""));

        org.junit.Assert.assertEquals("testeteste", result.get(0).get("concat").toString());
        org.junit.Assert.assertEquals("xptoxpto", result.get(1).get("concat").toString());
        org.junit.Assert.assertEquals("xptoxpto", result.get(2).get("concat").toString());
        org.junit.Assert.assertEquals("testeteste", result.get(3).get("concat").toString());
        org.junit.Assert.assertEquals("pomme de terrepomme de terre", result.get(4).get("concat").toString());
    }

    @Test
    public void testConcatNullExpressions() throws DatabaseEngineException {
        final Query query = SqlBuilder.select(SqlBuilder.concat(K.k(","), K.k("lol"), K.k(null), K.k("rofl")).alias("concat"));
        final List<Map<String, ResultColumn>> result = engine.query(query);
        org.junit.Assert.assertEquals("lol,rofl", result.get(0).get("concat").toString());
    }

    @Test
    public void testConcatNullDelimiter() throws DatabaseEngineException {
        final Query query = SqlBuilder.select(SqlBuilder.concat(K.k(null), K.k("lol"), K.k("nop"), K.k("rofl")).alias("concat"));
        final List<Map<String, ResultColumn>> result = engine.query(query);
        org.junit.Assert.assertEquals("lolnoprofl", result.get(0).get("concat").toString());
    }

    @Test
    public void testConcatColumn() throws DatabaseEngineException {
        final List<Map<String, ResultColumn>> result = queryConcat(SqlBuilder.column("COL2"));

        org.junit.Assert.assertEquals("testetesteteste", result.get(0).get("concat").toString());
        org.junit.Assert.assertEquals("xptoxptoxpto", result.get(1).get("concat").toString());
        org.junit.Assert.assertEquals("xptoxptoxpto", result.get(2).get("concat").toString());
        org.junit.Assert.assertEquals("testetesteteste", result.get(3).get("concat").toString());
        org.junit.Assert.assertEquals("pomme de terrepomme de terrepomme de terre", result.get(4).get("concat").toString());
    }

    private List<Map<String, ResultColumn>> queryConcat(final SqlBuilder.Expression delimiter) throws DatabaseEngineException {
        final DbEntity entity = SqlBuilder.dbEntity()
                .name("TEST")
                .addColumn("COL1", DbColumnType.INT)
                .addColumn("COL2", DbColumnType.STRING)
                .addColumn("COL3", DbColumnType.STRING)
                .build();

        engine.addEntity(entity);

        engine.persist("TEST", EntityEntry.entry().set("COL1", 1).set("COL2", "teste").set("COL3", "teste").build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 2).set("COL2", "xpto").set("COL3", "xpto").build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 3).set("COL2", "xpto").set("COL3", "xpto").build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 4).set("COL2", "teste").set("COL3", "teste").build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 5).set("COL2", "pomme de terre").set("COL3", "pomme de terre").build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 6).set("COL2", "lol").set("COL3", null).build());

        final Query query =
                SqlBuilder.select(SqlBuilder.concat(delimiter, SqlBuilder.column("COL2"), SqlBuilder.column("COL3")).alias("concat"))
                .from(SqlBuilder.table("TEST"));

        return engine.query(query);
    }

    @Test
    public void closingAnEngineUsingTheCreateDropPolicyShouldDropAllEntities()
            throws DatabaseEngineException, DatabaseFactoryException {

        properties.setProperty(PdbProperties.SCHEMA_POLICY, "create-drop");
        engine = DatabaseFactory.getConnection(properties);

        engine.addEntity(SqlBuilder.buildEntity("ENTITY-1"));
        engine.addEntity(SqlBuilder.buildEntity("ENTITY-2"));

        new com.feedzai.commons.sql.abstraction.engine.impl.abs.Expectations(engine) {};

        engine.close();

        new com.feedzai.commons.sql.abstraction.engine.impl.abs.Verifications() {{
            engine.dropEntity((DbEntity) any); times = 2;
        }};
    }

    @Test
    public void doesRowCountIncrementTest() throws DatabaseEngineException {
        create5ColumnsEntity();

        for (int i = 0; i < 4; i++) {
            engine.persist("TEST", EntityEntry.entry().set("COL1", i).build());
        }

        final ResultIterator resultIterator = engine.iterator(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")));

        org.junit.Assert.assertEquals("The current row count should be 0 if the iteration hasn't started", 0, resultIterator.getCurrentRowCount());

        resultIterator.next();

        org.junit.Assert.assertEquals("The current row count is equal to 1", 1, resultIterator.getCurrentRowCount());

        for (int i = 0; i < 3; i++) {
            resultIterator.nextResult();
        }

        org.junit.Assert.assertEquals("The current row count is equal to 4", 4, resultIterator.getCurrentRowCount());
    }

    @Test
    public void kEnumTest() throws DatabaseEngineException {
        create5ColumnsEntity();

        engine.persist("TEST", EntityEntry.entry().set("COL5", TestEnum.TEST_ENUM_VAL).build());

        engine.persist("TEST", EntityEntry.entry().set("COL5", "something else").build());

        final List<Map<String, ResultColumn>> results = engine.query(
                SqlBuilder.select(SqlBuilder.all())
                        .from(SqlBuilder.table("TEST"))
                        .where(SqlBuilder.eq(SqlBuilder.column("COL5"), K.k(TestEnum.TEST_ENUM_VAL)))
        );

        org.assertj.core.api.Assertions.assertThat(results)
                .as("One (and only one) result expected.")
                .hasSize(1)
                .element(0)
                .extracting(element -> element.get("COL5").toString())
                .as("An enum value should be persisted as its string representation")
                .isEqualTo(TestEnum.TEST_ENUM_VAL.name());
    }

    @Test
    public void insertDuplicateDBError() throws Exception {
        create5ColumnsEntityWithPrimaryKey();

        EntityEntry entry = EntityEntry.entry().set("COL1", 2)
                                   .set("COL2", false)
                                   .set("COL3", 2D)
                                   .set("COL4", 3L)
                                   .set("COL5", "ADEUS")
                                   .build();

        engine.persist("TEST", entry);
        org.assertj.core.api.Assertions.assertThatCode(() -> engine.persist("TEST", entry))
                .as("Is unique constraint violation exception")
                .isInstanceOf(DatabaseEngineUniqueConstraintViolationException.class)
                .as("Encapsulated exception is SQLException")
                .hasCauseInstanceOf(SQLException.class)
                .hasMessage("Something went wrong persisting the entity [unique_constraint_violation]");
    }

    @Test
    public void batchInsertDuplicateDBError() throws DatabaseEngineException {
        create5ColumnsEntityWithPrimaryKey();

        EntityEntry entry = EntityEntry.entry().set("COL1", 2)
                                   .set("COL2", false)
                                   .set("COL3", 2D)
                                   .set("COL4", 3L)
                                   .set("COL5", "ADEUS")
                                   .build();

        engine.addBatch("TEST", entry);
        engine.addBatch("TEST", entry);

        org.assertj.core.api.Assertions.assertThatCode(() -> engine.flush())
                .as("Is unique constraint violation exception")
                .isInstanceOf(DatabaseEngineUniqueConstraintViolationException.class)
                .as("Encapsulated exception is SQLException")
                .hasCauseInstanceOf(SQLException.class)
                .hasMessage("Something went wrong while flushing [unique_constraint_violation]");
    }

    private void create5ColumnsEntity() throws DatabaseEngineException {
        final DbEntity entity = SqlBuilder.dbEntity()
                .name("TEST")
                .addColumn("COL1", DbColumnType.INT)
                .addColumn("COL2", DbColumnType.BOOLEAN)
                .addColumn("COL3", DbColumnType.DOUBLE)
                .addColumn("COL4", DbColumnType.LONG)
                .addColumn("COL5", DbColumnType.STRING)
                .build();

        engine.addEntity(entity);
    }

    private void create5ColumnsEntityWithPrimaryKey() throws DatabaseEngineException {
        final DbEntity entity = SqlBuilder.dbEntity().name("TEST")
                                          .addColumn("COL1", DbColumnType.INT)
                                          .addColumn("COL2", DbColumnType.BOOLEAN)
                                          .addColumn("COL3", DbColumnType.DOUBLE)
                                          .addColumn("COL4", DbColumnType.LONG)
                                          .addColumn("COL5", DbColumnType.STRING)
                                          .pkFields("COL1")
                                          .build();

        engine.addEntity(entity);
    }

    protected void userRolePermissionSchema() throws DatabaseEngineException {
        DbEntity entity = SqlBuilder.dbEntity()
                .name("USER")
                .addColumn("COL1", DbColumnType.INT, true)
                .pkFields("COL1")
                .build();

        engine.addEntity(entity);

        entity = SqlBuilder.dbEntity()
                .name("ROLE")
                .addColumn("COL1", DbColumnType.INT, true)
                .pkFields("COL1")
                .build();

        engine.addEntity(entity);

        entity = SqlBuilder.dbEntity()
                .name("USER_ROLE")
                .addColumn("COL1", DbColumnType.INT)
                .addColumn("COL2", DbColumnType.INT)
                .addFk(SqlBuilder.dbFk()
                                .addColumn("COL1")
                                .referencedTable("USER")
                                .addReferencedColumn("COL1")
                                .build(),
                        SqlBuilder.dbFk()
                                .addColumn("COL2")
                                .referencedTable("ROLE")
                                .addReferencedColumn("COL1")
                                .build()
                )
                .pkFields("COL1", "COL2")
                .build();

        engine.addEntity(entity);
    }

    @Test
    public void testAndWhere() throws DatabaseEngineException {
        create5ColumnsEntity();

        engine.persist("TEST", EntityEntry.entry().set("COL1", 1).set("COL5", "teste").build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 1).set("COL5", "teste").build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 1).set("COL5", "teste").build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 1).set("COL5", "teste").build());

        final List<Map<String, ResultColumn>> query = engine.query(
                SqlBuilder.select(SqlBuilder.all())
                        .from(SqlBuilder.table("TEST"))
                        .where(SqlBuilder.eq(SqlBuilder.column("COL1"), K.k(1)))
                        .andWhere(SqlBuilder.eq(SqlBuilder.column("COL5"), K.k("teste")))
        );

        org.junit.Assert.assertEquals("Resultset must have only one result", 1, query.size());
        org.junit.Assert.assertEquals("COL1 must be 1", 1, query.get(0).get("COL1").toInt().intValue());
        org.junit.Assert.assertEquals("COL5 must be teste", "teste", query.get(0).get("COL5").toString());
    }

    @Test
    public void testAndWhereMultiple() throws DatabaseEngineException {
        create5ColumnsEntity();

        engine.persist("TEST", EntityEntry.entry().set("COL1", 1).set("COL5", "teste").build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 2).set("COL5", "TESTE").build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 3).set("COL5", "TeStE").build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 4).set("COL5", "tesTte").build());

        final List<Map<String, ResultColumn>> query = engine.query(
                SqlBuilder.select(SqlBuilder.all())
                        .from(SqlBuilder.table("TEST"))
                        .where(SqlBuilder.or(SqlBuilder.eq(SqlBuilder.column("COL1"), K.k(1)),
                                             SqlBuilder.eq(SqlBuilder.column("COL1"), K.k(4))))
                        .andWhere(SqlBuilder.or(SqlBuilder.eq(SqlBuilder.column("COL5"), K.k("teste")),
                                                SqlBuilder.eq(SqlBuilder.column("COL5"), K.k("TESTE"))))
        );

        org.junit.Assert.assertEquals("Resultset must have only one result", 1, query.size());
        org.junit.Assert.assertEquals("COL1 must be 1", 1, query.get(0).get("COL1").toInt().intValue());
        org.junit.Assert.assertEquals("COL5 must be teste", "teste", query.get(0).get("COL5").toString());
    }

    @Test
    public void testAndWhereMultipleCheckAndEnclosed() throws DatabaseEngineException {
        create5ColumnsEntity();

        engine.persist("TEST", EntityEntry.entry().set("COL1", 1).set("COL5", "teste").build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 2).set("COL5", "TESTE").build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 3).set("COL5", "TeStE").build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 4).set("COL5", "tesTte").build());

        final List<Map<String, ResultColumn>> query = engine.query(
                SqlBuilder.select(SqlBuilder.all())
                        .from(SqlBuilder.table("TEST"))
                        .where(SqlBuilder.or(SqlBuilder.eq(SqlBuilder.column("COL1"), K.k(1)),
                                             SqlBuilder.eq(SqlBuilder.column("COL1"), K.k(4))))
                        .andWhere(SqlBuilder.or(SqlBuilder.eq(SqlBuilder.column("COL5"), K.k("teste")),
                                                SqlBuilder.eq(SqlBuilder.column("COL5"), K.k("tesTte"))))
        );

        org.junit.Assert.assertEquals("Resultset must have only one result", 2, query.size());
        org.junit.Assert.assertEquals("COL1 must be 1", 1, query.get(0).get("COL1").toInt().intValue());
        org.junit.Assert.assertEquals("COL5 must be teste", "teste", query.get(0).get("COL5").toString());
        org.junit.Assert.assertEquals("COL1 must be 1", 4, query.get(1).get("COL1").toInt().intValue());
        org.junit.Assert.assertEquals("COL5 must be teste", "tesTte", query.get(1).get("COL5").toString());
    }

    @Test
    public void testStringAgg() throws DatabaseEngineException {
        create5ColumnsEntity();

        engine.persist("TEST", EntityEntry.entry().set("COL1", 1).set("COL5", "TESTE").build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 1).set("COL5", "teste").build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 2).set("COL5", "TeStE").build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 2).set("COL5", "tesTte").build());

        final List<Map<String, ResultColumn>> query = engine.query(
                SqlBuilder.select(SqlBuilder.column("COL1"), SqlBuilder.stringAgg(SqlBuilder.column("COL5")).alias("agg"))
                        .from(SqlBuilder.table("TEST"))
                        .groupby(SqlBuilder.column("COL1"))
                        .orderby(SqlBuilder.column("COL1").asc())
        );

        org.junit.Assert.assertEquals("Resultset must have only 2 results", 2, query.size());
        org.junit.Assert.assertEquals("COL1 must be 1", 1, query.get(0).get("COL1").toInt().intValue());
        org.junit.Assert.assertEquals("COL5 must be TESTE,teste", "TESTE,teste", query.get(0).get("agg").toString());
        org.junit.Assert.assertEquals("COL1 must be 2", 2, query.get(1).get("COL1").toInt().intValue());
        org.junit.Assert.assertEquals("COL5 must be TeStE,tesTte", "TeStE,tesTte", query.get(1).get("agg").toString());
    }

    @Test
    public void testStringAggDelimiter() throws DatabaseEngineException {
        create5ColumnsEntity();

        engine.persist("TEST", EntityEntry.entry().set("COL1", 1).set("COL5", "TESTE").build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 1).set("COL5", "teste").build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 2).set("COL5", "TeStE").build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 2).set("COL5", "tesTte").build());

        final List<Map<String, ResultColumn>> query = engine.query(
                SqlBuilder.select(SqlBuilder.column("COL1"), SqlBuilder.stringAgg(SqlBuilder.column("COL5")).delimiter(';').alias("agg"))
                        .from(SqlBuilder.table("TEST"))
                        .groupby(SqlBuilder.column("COL1"))
                        .orderby(SqlBuilder.column("COL1").asc())
        );

        org.junit.Assert.assertEquals("Resultset must have only 2 results", 2, query.size());
        org.junit.Assert.assertEquals("COL1 must be 1", 1, query.get(0).get("COL1").toInt().intValue());
        org.junit.Assert.assertEquals("COL5 must be TESTE;teste", "TESTE;teste", query.get(0).get("agg").toString());
        org.junit.Assert.assertEquals("COL1 must be 2", 2, query.get(1).get("COL1").toInt().intValue());
        org.junit.Assert.assertEquals("COL5 must be TeStE;tesTte", "TeStE;tesTte", query.get(1).get("agg").toString());
    }

    @Test
    public void testStringAggDistinct() throws DatabaseEngineException {
        Assume.assumeTrue("This test is only valid for engines that support StringAggDistinct",
                engine.isStringAggDistinctCapable());

        create5ColumnsEntity();

        engine.persist("TEST", EntityEntry.entry().set("COL1", 1).set("COL5", "teste").build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 1).set("COL5", "teste").build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 2).set("COL5", "TeStE").build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 2).set("COL5", "tesTte").build());

        final List<Map<String, ResultColumn>> query = engine.query(
                SqlBuilder.select(SqlBuilder.column("COL1"), SqlBuilder.stringAgg(SqlBuilder.column("COL5")).distinct().alias("agg"))
                        .from(SqlBuilder.table("TEST"))
                        .groupby(SqlBuilder.column("COL1"))
                        .orderby(SqlBuilder.column("COL1").asc())
        );

        org.junit.Assert.assertEquals("Resultset must have only 2 results", 2, query.size());
        org.junit.Assert.assertEquals("COL1 must be 1", 1, query.get(0).get("COL1").toInt().intValue());
        org.junit.Assert.assertEquals("COL5 must be teste", "teste", query.get(0).get("agg").toString());
        org.junit.Assert.assertEquals("COL1 must be 2", 2, query.get(1).get("COL1").toInt().intValue());
        org.junit.Assert.assertEquals("COL5 must be TeStE,tesTte", "TeStE,tesTte", query.get(1).get("agg").toString());
    }

    @Test
    public void testStringAggNotStrings() throws DatabaseEngineException {
        create5ColumnsEntity();

        engine.persist("TEST", EntityEntry.entry().set("COL1", 1).set("COL5", "TESTE").build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 1).set("COL5", "teste").build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 2).set("COL5", "TeStE").build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 2).set("COL5", "tesTte").build());

        final List<Map<String, ResultColumn>> query = engine.query(
                SqlBuilder.select(SqlBuilder.column("COL1"), SqlBuilder.stringAgg(SqlBuilder.column("COL1")).alias("agg"))
                        .from(SqlBuilder.table("TEST"))
                        .groupby(SqlBuilder.column("COL1"))
                        .orderby(SqlBuilder.column("COL1").asc())
        );

        org.junit.Assert.assertEquals("Resultset must have only 2 results", 2, query.size());
        org.junit.Assert.assertEquals("COL1 must be 1", 1, query.get(0).get("COL1").toInt().intValue());
        org.junit.Assert.assertEquals("COL5 must be 1,1", "1,1", query.get(0).get("agg").toString());
        org.junit.Assert.assertEquals("COL1 must be 2", 2, query.get(1).get("COL1").toInt().intValue());
        org.junit.Assert.assertEquals("COL5 must be 2,2", "2,2", query.get(1).get("agg").toString());
    }

    @Test
    @Category(SkipTestCockroachDB.class)
    public void dropPrimaryKeyWithOneColumnTest() throws Exception {
        DbEntity entity =
                SqlBuilder.dbEntity()
                        .name("TEST")
                        .addColumn("COL1", DbColumnType.INT)
                        .addColumn("COL2", DbColumnType.BOOLEAN)
                        .addColumn("COL3", DbColumnType.DOUBLE)
                        .addColumn("COL4", DbColumnType.LONG)
                        .addColumn("COL5", DbColumnType.STRING)
                        .pkFields("COL1")
                        .build();
        engine.addEntity(entity);
        engine.executeUpdate(SqlBuilder.dropPK(SqlBuilder.table("TEST")));
    }

    @Test
    @Category(SkipTestCockroachDB.class)
    public void dropPrimaryKeyWithTwoColumnsTest() throws Exception {
        DbEntity entity =
                SqlBuilder.dbEntity()
                        .name("TEST")
                        .addColumn("COL1", DbColumnType.INT)
                        .addColumn("COL2", DbColumnType.BOOLEAN)
                        .addColumn("COL3", DbColumnType.DOUBLE)
                        .addColumn("COL4", DbColumnType.LONG)
                        .addColumn("COL5", DbColumnType.STRING)
                        .pkFields("COL1", "COL4")
                        .build();
        engine.addEntity(entity);
        engine.executeUpdate(SqlBuilder.dropPK(SqlBuilder.table("TEST")));
    }

    @Test
    public void alterColumnWithConstraintTest() throws DatabaseEngineException {
        DbEntity entity =
                SqlBuilder.dbEntity()
                        .name("TEST")
                        .addColumn("COL1", DbColumnType.INT)
                        .addColumn("COL2", DbColumnType.BOOLEAN)
                        .addColumn("COL3", DbColumnType.DOUBLE)
                        .addColumn("COL4", DbColumnType.LONG)
                        .addColumn("COL5", DbColumnType.STRING)
                        .build();

        engine.addEntity(entity);

        engine.executeUpdate(new AlterColumn(SqlBuilder.table("TEST"), new DbColumn.Builder().name("COL1").type(DbColumnType.INT).addConstraint(DbColumnConstraint.NOT_NULL)
                .build()));
    }

    @Test
    @Category(SkipTestCockroachDB.class)
    public void alterColumnToDifferentTypeTest() throws DatabaseEngineException {
        DbEntity entity =
                SqlBuilder.dbEntity()
                        .name("TEST")
                        .addColumn("COL1", DbColumnType.INT)
                        .addColumn("COL2", DbColumnType.BOOLEAN)
                        .addColumn("COL3", DbColumnType.DOUBLE)
                        .addColumn("COL4", DbColumnType.LONG)
                        .addColumn("COL5", DbColumnType.STRING)
                        .build();

        engine.addEntity(entity);

        engine.executeUpdate(new AlterColumn(SqlBuilder.table("TEST"), SqlBuilder.dbColumn().name("COL1").type(DbColumnType.STRING)
                .build()));
    }

    @Test
    public void createTableWithDefaultsTest() throws DatabaseEngineException, DatabaseFactoryException {
        DbEntity.Builder entity =
                SqlBuilder.dbEntity()
                        .name("TEST")
                        .addColumn("COL1", DbColumnType.INT, K.k(1))
                        .addColumn("COL2", DbColumnType.BOOLEAN, K.k(false))
                        .addColumn("COL3", DbColumnType.DOUBLE, K.k(2.2d))
                        .addColumn("COL4", DbColumnType.LONG, K.k(3L))
                        .pkFields("COL1");

        engine.addEntity(entity.build());

        final String ec = engine.escapeCharacter();
        engine.executeUpdate("INSERT INTO " + StringUtils.quotize("TEST", ec) + " (" + StringUtils.quotize("COL1", ec) + ") VALUES (10)");

        List<Map<String, ResultColumn>> test = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")));
        org.junit.Assert.assertEquals("Check size of records", 1, test.size());
        Map<String, ResultColumn> record = test.get(0);
        org.junit.Assert.assertEquals("Check COL1", 10, record.get("COL1").toInt().intValue());
        org.junit.Assert.assertEquals("Check COL2", false, record.get("COL2").toBoolean());
        org.junit.Assert.assertEquals("Check COL3", 2.2d, record.get("COL3").toDouble(), 0);
        org.junit.Assert.assertEquals("Check COL4", 3L, record.get("COL4").toLong().longValue());

        final DbEntity entity1 = entity
                .addColumn("COL5", DbColumnType.STRING, K.k("mantorras"), DbColumnConstraint.NOT_NULL)
                .addColumn("COL6", DbColumnType.BOOLEAN, K.k(true), DbColumnConstraint.NOT_NULL)
                .addColumn("COL7", DbColumnType.INT, K.k(7), DbColumnConstraint.NOT_NULL)
                .build();

        final Properties propertiesCreate = new Properties();
        for (Map.Entry<Object, Object> prop : properties.entrySet()) {
            propertiesCreate.setProperty(prop.getKey().toString(), prop.getValue().toString());
        }
        propertiesCreate.setProperty(PdbProperties.SCHEMA_POLICY, "create");

        final DatabaseEngine connection2 = DatabaseFactory.getConnection(propertiesCreate);
        connection2.updateEntity(entity1);

        test = connection2.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")));
        org.junit.Assert.assertEquals("Check size of records", 1, test.size());
        record = test.get(0);
        org.junit.Assert.assertEquals("Check COL1", 10, record.get("COL1").toInt().intValue());
        org.junit.Assert.assertEquals("Check COL2", false, record.get("COL2").toBoolean());
        org.junit.Assert.assertEquals("Check COL3", 2.2d, record.get("COL3").toDouble(), 1e-9);
        org.junit.Assert.assertEquals("Check COL4", 3L, record.get("COL4").toLong().longValue());
        org.junit.Assert.assertEquals("Check COL5", "mantorras", record.get("COL5").toString());
        org.junit.Assert.assertEquals("Check COL6", true, record.get("COL6").toBoolean());
        org.junit.Assert.assertEquals("Check COL7", 7, record.get("COL7").toInt().intValue());
        connection2.close();
    }

    @Test
    public void defaultValueOnBooleanColumnsTest() throws DatabaseEngineException {
        DbEntity.Builder entity =
                SqlBuilder.dbEntity()
                        .name("TEST")
                        .addColumn("COL1", DbColumnType.INT, K.k(1))
                        .addColumn("COL2", DbColumnType.BOOLEAN, K.k(false), DbColumnConstraint.NOT_NULL)
                        .addColumn("COL3", DbColumnType.DOUBLE, K.k(2.2d))
                        .addColumn("COL4", DbColumnType.LONG, K.k(3L))
                        .pkFields("COL1");

        engine.addEntity(entity.build());

        engine.persist("TEST", EntityEntry.entry().build());
        Map<String, ResultColumn> row = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST"))).get(0);

        org.junit.Assert.assertEquals("", 1, row.get("COL1").toInt().intValue());
        org.junit.Assert.assertFalse("", row.get("COL2").toBoolean());
        org.junit.Assert.assertEquals("", 2.2d, row.get("COL3").toDouble(), 0D);
        org.junit.Assert.assertEquals("", 3L, row.get("COL4").toLong().longValue());
    }

    @Test
    public void upperTest() throws DatabaseEngineException {
        create5ColumnsEntity();
        engine.persist("TEST", EntityEntry.entry().set("COL5", "ola").build());
        org.junit.Assert.assertEquals("text is uppercase", "OLA", engine.query(SqlBuilder.select(SqlBuilder.upper(SqlBuilder.column("COL5")).alias("RES")).from(SqlBuilder.table("TEST"))).get(0).get("RES").toString());
    }

    @Test
    public void lowerTest() throws DatabaseEngineException {
        create5ColumnsEntity();
        engine.persist("TEST", EntityEntry.entry().set("COL5", "OLA").build());
        org.junit.Assert.assertEquals("text is lowercase", "ola", engine.query(SqlBuilder.select(SqlBuilder.lower(SqlBuilder.column("COL5")).alias("RES")).from(SqlBuilder.table("TEST"))).get(0).get("RES").toString());
    }

    @Test
    public void internalFunctionTest() throws DatabaseEngineException {
        create5ColumnsEntity();
        engine.persist("TEST", EntityEntry.entry().set("COL5", "OLA").build());
        org.junit.Assert.assertEquals("text is uppercase", "ola", engine.query(SqlBuilder.select(SqlBuilder.f("LOWER", SqlBuilder.column("COL5")).alias("RES")).from(SqlBuilder.table("TEST"))).get(0).get("RES").toString());
    }

    @Test
    public void entityEntryHashcodeTest() {
        Map<String, Object> map = new HashMap<>();
        map.put("id1", "val1");
        map.put("id2", "val2");
        map.put("id3", "val3");
        map.put("id4", "val4");

        EntityEntry entry = EntityEntry.entry()
                .set(map)
                .build();

        org.junit.Assert.assertEquals("entry's hashCode() matches map's hashCode()", map.hashCode(), entry.hashCode());
    }

    @Test
    public void tryWithResourcesClosesEngine() throws Exception {
        final AtomicReference<Connection> connReference = new AtomicReference<>();

        try (final DatabaseEngine tryEngine = this.engine) {
            connReference.set(tryEngine.getConnection());
            org.junit.Assert.assertFalse("close() method should not be called within the try-with-resources block, for an existing DatabaseEngine",
                    connReference.get().isClosed());
        }

        org.junit.Assert.assertTrue("close() method should be called after exiting try-with-resources block, for an existing DatabaseEngine",
                connReference.get().isClosed());

        try (final DatabaseEngine tryEngine = DatabaseFactory.getConnection(properties)) {
            connReference.set(tryEngine.getConnection());
            org.junit.Assert.assertFalse("close() method should not be called within the try-with-resources block, for a DatabaseEngine created in the block",
                    connReference.get().isClosed());
        }

        org.junit.Assert.assertTrue("close() method should be called after exiting try-with-resources block, for a DatabaseEngine created in the block",
                connReference.get().isClosed());

    }

    @Test
    public void closingAnEngineUsingTheCreateDropPolicyShouldDropAllEntities()
            throws DatabaseEngineException, DatabaseFactoryException {

        properties.setProperty(PdbProperties.SCHEMA_POLICY, "create-drop");
        engine = DatabaseFactory.getConnection(properties);

        engine.addEntity(SqlBuilder.buildEntity("ENTITY-1"));
        engine.addEntity(SqlBuilder.buildEntity("ENTITY-2"));

        new com.feedzai.commons.sql.abstraction.engine.impl.abs.Expectations(engine) {};

        engine.close();

        new com.feedzai.commons.sql.abstraction.engine.impl.abs.Verifications() {{
            engine.dropEntity((DbEntity) any); times = 2;
        }};

    }

    @Test
    public void doesRowCountIncrementTest() throws DatabaseEngineException {
        create5ColumnsEntity();

        for (int i = 0; i < 4; i++) {
            engine.persist("TEST", EntityEntry.entry().set("COL1", i).build());
        }

        final ResultIterator resultIterator = engine.iterator(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")));

        org.junit.Assert.assertEquals("The current row count should be 0 if the iteration hasn't started", 0, resultIterator.getCurrentRowCount());

        resultIterator.next();

        org.junit.Assert.assertEquals("The current row count is equal to 1", 1, resultIterator.getCurrentRowCount());

        for (int i = 0; i < 3; i++) {
            resultIterator.nextResult();
        }

        org.junit.Assert.assertEquals("The current row count is equal to 4", 4, resultIterator.getCurrentRowCount());
    }

    @Test
    public void kEnumTest() throws DatabaseEngineException {
        create5ColumnsEntity();

        engine.persist("TEST", EntityEntry.entry().set("COL5", TestEnum.TEST_ENUM_VAL).build());

        engine.persist("TEST", EntityEntry.entry().set("COL5", "something else").build());

        final List<Map<String, ResultColumn>> results = engine.query(
                SqlBuilder.select(SqlBuilder.all())
                        .from(SqlBuilder.table("TEST"))
                        .where(SqlBuilder.eq(SqlBuilder.column("COL5"), K.k(TestEnum.TEST_ENUM_VAL)))
        );

        org.assertj.core.api.Assertions.assertThat(results)
                .as("One (and only one) result expected.")
                .hasSize(1)
                .element(0)
                .extracting(element -> element.get("COL5").toString())
                .as("An enum value should be persisted as its string representation")
                .isEqualTo(TestEnum.TEST_ENUM_VAL.name());
    }

    @Test
    public void insertDuplicateDBError() throws Exception {
        create5ColumnsEntityWithPrimaryKey();

        EntityEntry entry = EntityEntry.entry().set("COL1", 2)
                                   .set("COL2", false)
                                   .set("COL3", 2D)
                                   .set("COL4", 3L)
                                   .set("COL5", "ADEUS")
                                   .build();

        engine.persist("TEST", entry);
        org.assertj.core.api.Assertions.assertThatCode(() -> engine.persist("TEST", entry))
                .as("Is unique constraint violation exception")
                .isInstanceOf(DatabaseEngineUniqueConstraintViolationException.class)
                .as("Encapsulated exception is SQLException")
                .hasCauseInstanceOf(SQLException.class)
                .hasMessage("Something went wrong persisting the entity [unique_constraint_violation]");
    }

    @Test
    public void batchInsertDuplicateDBError() throws DatabaseEngineException {
        create5ColumnsEntityWithPrimaryKey();

        EntityEntry entry = EntityEntry.entry().set("COL1", 2)
                                   .set("COL2", false)
                                   .set("COL3", 2D)
                                   .set("COL4", 3L)
                                   .set("COL5", "ADEUS")
                                   .build();

        engine.addBatch("TEST", entry);
        engine.addBatch("TEST", entry);

        org.assertj.core.api.Assertions.assertThatCode(() -> engine.flush())
                .as("Is unique constraint violation exception")
                .isInstanceOf(DatabaseEngineUniqueConstraintViolationException.class)
                .as("Encapsulated exception is SQLException")
                .hasCauseInstanceOf(SQLException.class)
                .hasMessage("Something went wrong while flushing [unique_constraint_violation]");
    }

    @Test
    public void testPersistOverrideAutoIncrement() throws Exception {
        DbEntity entity = SqlBuilder.dbEntity()
                .name("MYTEST")
                .addColumn("COL1", DbColumnType.INT, true)
                .addColumn("COL2", DbColumnType.STRING)
                .build();

        engine.addEntity(entity);

        EntityEntry ent = EntityEntry.entry().set("COL2", "CENAS1")
                .build();
        engine.persist("MYTEST", ent);
        ent = EntityEntry.entry().set("COL2", "CENAS2")
                .build();
        engine.persist("MYTEST", ent);

        ent = EntityEntry.entry().set("COL2", "CENAS3").set("COL1", 3)
                .build();
        engine.persist("MYTEST", ent, false);

        ent = EntityEntry.entry().set("COL2", "CENAS5").set("COL1", 5)
                .build();
        engine.persist("MYTEST", ent, false);

        ent = EntityEntry.entry().set("COL2", "CENAS6")
                .build();
        engine.persist("MYTEST", ent);

        ent = EntityEntry.entry().set("COL2", "CENAS7")
                .build();
        engine.persist("MYTEST", ent);

        final List<Map<String, ResultColumn>> query = engine.query("SELECT * FROM " + StringUtils.quotize("MYTEST", engine.escapeCharacter()));
        for (Map<String, ResultColumn> stringResultColumnMap : query) {
            org.junit.Assert.assertTrue(stringResultColumnMap.get("COL2").toString().endsWith(stringResultColumnMap.get("COL1").toString()));
        }
        engine.close();
    }

    @Test
    public void testPersistOverrideAutoIncrement2() throws Exception {
        String APP_ID = "APP_ID";
        DbColumn APP_ID_COLUMN = new DbColumn.Builder().name(APP_ID).type(DbColumnType.INT).build();
        String STM_TABLE = "FDZ_APP_STREAM";
        String STM_ID = "STM_ID";
        String STM_NAME = "STM_NAME";
        DbEntity STREAM = SqlBuilder.dbEntity().name(STM_TABLE)
                .addColumn(APP_ID_COLUMN)
                .addColumn(STM_ID, DbColumnType.INT, true)
                .addColumn(STM_NAME, DbColumnType.STRING, DbColumnConstraint.NOT_NULL)
                .pkFields(STM_ID, APP_ID)
                .build();

        engine.addEntity(STREAM);

        EntityEntry ent = EntityEntry.entry().set(APP_ID, 1).set(STM_ID, 1).set(STM_NAME, "NAME1")
                .build();
        engine.persist(STM_TABLE, ent);

        ent = EntityEntry.entry().set(APP_ID, 2).set(STM_ID, 1).set(STM_NAME, "NAME1")
                .build();
        engine.persist(STM_TABLE, ent, false);

        ent = EntityEntry.entry().set(APP_ID, 2).set(STM_ID, 2).set(STM_NAME, "NAME2")
                .build();
        engine.persist(STM_TABLE, ent);

        ent = EntityEntry.entry().set(APP_ID, 1).set(STM_ID, 10).set(STM_NAME, "NAME10")
                .build();
        engine.persist(STM_TABLE, ent, false);

        ent = EntityEntry.entry().set(APP_ID, 1).set(STM_ID, 2).set(STM_NAME, "NAME11")
                .build();
        engine.persist(STM_TABLE, ent);

        ent = EntityEntry.entry().set(APP_ID, 2).set(STM_ID, 11).set(STM_NAME, "NAME11")
                .build();
        engine.persist(STM_TABLE, ent, false);

        final List<Map<String, ResultColumn>> query = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table(STM_TABLE)));
        for (Map<String, ResultColumn> stringResultColumnMap : query) {
            System.out.println(stringResultColumnMap);
            org.junit.Assert.assertTrue("Assert Stream Name with id", stringResultColumnMap.get(STM_NAME).toString().endsWith(stringResultColumnMap.get(STM_ID).toString()));
        }
    }

    @Test
    public void testPersistOverrideAutoIncrement3() throws Exception {
        DbEntity entity = SqlBuilder.dbEntity()
                .name("MYTEST")
                .addColumn("COL1", DbColumnType.INT, true)
                .addColumn("COL2", DbColumnType.STRING)
                .build();

        engine.addEntity(entity);

        EntityEntry ent = EntityEntry.entry().set("COL2", "CENAS1").set("COL1", 1)
                .build();
        engine.persist("MYTEST", ent, false);

        ent = EntityEntry.entry().set("COL2", "CENAS2")
                .build();
        engine.persist("MYTEST", ent);

        ent = EntityEntry.entry().set("COL2", "CENAS5").set("COL1", 5)
                .build();
        engine.persist("MYTEST", ent, false);

        ent = EntityEntry.entry().set("COL2", "CENAS6")
                .build();
        engine.persist("MYTEST", ent);

        final List<Map<String, ResultColumn>> query = engine.query("SELECT * FROM " + StringUtils.quotize("MYTEST", engine.escapeCharacter()));
        for (Map<String, ResultColumn> stringResultColumnMap : query) {
            System.out.println(stringResultColumnMap);
            org.junit.Assert.assertTrue(stringResultColumnMap.get("COL2").toString().endsWith(stringResultColumnMap.get("COL1").toString()));
        }
        engine.close();
    }

    @Test
    public void testTruncateTable() throws Exception {
        create5ColumnsEntity();

        engine.persist("TEST", EntityEntry.entry().set("COL1", 5).build());

        Truncate truncate = new Truncate(SqlBuilder.table("TEST"));

        engine.executeUpdate(truncate);

        final List<Map<String, ResultColumn>> test = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")));
        org.junit.Assert.assertTrue("Test truncate query empty?", test.isEmpty());
    }

    @Test
    public void testRenameTables() throws Exception {
        String oldName = "TBL_OLD";
        String newName = "TBL_NEW";

        dropSilently(oldName, newName);

        DbEntity entity = SqlBuilder.dbEntity()
                .name(oldName)
                .addColumn("timestamp", DbColumnType.INT)
                .build();
        engine.addEntity(entity);
        engine.persist(oldName, EntityEntry.entry().set("timestamp", 20).build());

        Rename rename = new Rename(SqlBuilder.table(oldName), SqlBuilder.table(newName));
        engine.executeUpdate(rename);

        final Map<String, DbColumnType> metaMap = new LinkedHashMap<>();
        metaMap.put("timestamp", DbColumnType.INT);
        org.junit.Assert.assertEquals("Metamap ok?", metaMap, engine.getMetadata(newName));

        List<Map<String, ResultColumn>> resultSet = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table(newName)));
        org.junit.Assert.assertEquals("Count ok?", 1, resultSet.size());

        org.junit.Assert.assertEquals("Content ok?", 20, (int) resultSet.get(0).get("timestamp").toInt());

        dropSilently(newName);
    }

    private void dropSilently(String... tables) {
        for (String table : tables) {
            try {
                engine.dropEntity(SqlBuilder.dbEntity().name(table).build());
            } catch (Throwable e) {
                // ignore
            }
        }
    }

    @Test
    public void testLikeWithTransformation() throws Exception {
        create5ColumnsEntity();
        engine.persist("TEST", EntityEntry.entry().set("COL1", 5).set("COL5", "teste").build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 5).set("COL5", "TESTE").build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 5).set("COL5", "TeStE").build());
        engine.persist("TEST", EntityEntry.entry().set("COL1", 5).set("COL5", "tesTte").build());

        List<Map<String, ResultColumn>> query = engine.query(
            SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")).where(SqlBuilder.like(SqlBuilder.udf("lower", SqlBuilder.column("COL5")), K.k("%teste%")))
        );
        org.junit.Assert.assertEquals(3, query.size());
        query = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")).where(SqlBuilder.like(SqlBuilder.udf("lower", SqlBuilder.column("COL5")), K.k("%tt%"))));
        org.junit.Assert.assertEquals(1, query.size());
    }

    @Test
    public void createSequenceOnLongColumnTest() throws Exception {
        DbEntity entity = SqlBuilder.dbEntity()
                .name("TEST")
                .addColumn("COL1", DbColumnType.INT)
                .addColumn("COL2", DbColumnType.BOOLEAN)
                .addColumn("COL3", DbColumnType.DOUBLE)
                .addColumn("COL4", DbColumnType.LONG, true)
                .addColumn("COL5", DbColumnType.STRING)
                .build();
        engine.addEntity(entity);
        engine.persist("TEST", EntityEntry.entry().set("COL1", 1).set("COL2", true).build());
        List<Map<String, ResultColumn>> test = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")));
        org.junit.Assert.assertEquals("col1 ok?", 1, (int) test.get(0).get("COL1").toInt());
        org.junit.Assert.assertTrue("col2 ok?", test.get(0).get("COL2").toBoolean());
        org.junit.Assert.assertEquals("col4 ok?", 1L, (long) test.get(0).get("COL4").toLong());
    }

    @Test
    public void insertWithNoAutoIncAndThatResumeTheAutoIncTest() throws DatabaseEngineException {
        DbEntity entity = SqlBuilder.dbEntity()
                .name("TEST")
                .addColumn("COL1", DbColumnType.INT)
                .addColumn("COL2", DbColumnType.BOOLEAN)
                .addColumn("COL3", DbColumnType.DOUBLE)
                .addColumn("COL4", DbColumnType.LONG, true)
                .addColumn("COL5", DbColumnType.STRING)
                .build();
        engine.addEntity(entity);
        engine.persist("TEST", EntityEntry.entry().set("COL1", 1).set("COL2", true).build());
        List<Map<String, ResultColumn>> test = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")).orderby(SqlBuilder.column("COL4")));
        org.junit.Assert.assertEquals("col4 ok?", 1L, (long) test.get(0).get("COL4").toLong());

        engine.persist("TEST", EntityEntry.entry().set("COL1", 1).set("COL2", true).set("COL4", 2).build(), false);
        test = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")).orderby(SqlBuilder.column("COL4")));
        org.junit.Assert.assertEquals("col4 ok?", 2L, (long) test.get(1).get("COL4").toLong());

        engine.persist("TEST", EntityEntry.entry().set("COL1", 1).set("COL2", true).build());
        test = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")).orderby(SqlBuilder.column("COL4")));
        org.junit.Assert.assertEquals("col4 ok?", 3L, (long) test.get(2).get("COL4").toLong());

        engine.persist("TEST", EntityEntry.entry().set("COL1", 1).set("COL2", true).set("COL4", 4).build(), false);
        test = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")).orderby(SqlBuilder.column("COL4")));
        org.junit.Assert.assertEquals("col4 ok?", 4L, (long) test.get(3).get("COL4").toLong());

        engine.persist("TEST", EntityEntry.entry().set("COL1", 1).set("COL2", true).build());
        test = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")).orderby(SqlBuilder.column("COL4")));
        org.junit.Assert.assertEquals("col4 ok?", 5L, (long) test.get(4).get("COL4").toLong());

        engine.persist("TEST", EntityEntry.entry().set("COL1", 1).set("COL2", true).set("COL4", 6).build(), false);
        test = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")).orderby(SqlBuilder.column("COL4")));
        org.junit.Assert.assertEquals("col4 ok?", 6L, (long) test.get(5).get("COL4").toLong());

        engine.persist("TEST", EntityEntry.entry().set("COL1", 1).set("COL2", true).set("COL4", 7).build(), false);
        test = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")).orderby(SqlBuilder.column("COL4")));
        org.junit.Assert.assertEquals("col4 ok?", 7L, (long) test.get(6).get("COL4").toLong());

        engine.persist("TEST", EntityEntry.entry().set("COL1", 1).set("COL2", true).build());
        test = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")).orderby(SqlBuilder.column("COL4")));
        org.junit.Assert.assertEquals("col4 ok?", 8L, (long) test.get(7).get("COL4").toLong());
    }

    private enum TestEnum {
        TEST_ENUM_VAL;

        @Override
        public String toString() {
            return super.toString() + " description";
        }
    }
}
```
