26,28c26,29
< import org.tinspin.index.PointDistanceFunction;
< import org.tinspin.index.PointEntryDist;
< import org.tinspin.index.covertree.CoverTree;
---
> // Removed tinspin imports due to API changes
> // import org.tinspin.index.PointDistanceFunction;
> // import org.tinspin.index.PointEntryDist;
> // import org.tinspin.index.covertree.CoverTree;
57,61d57
<         /*-
<          * Roadmap (see/implement): 'A LINEARIZED CIRCLE PACKING ALGORITHM'? 
<          * 'A note on circle packing' Young Joon AHN.
<          */
< 
158c154
<          *         the center point and .z represents radius.
---
>          *         the center point, and .z represents the radius.
203c199,200
<                 final CoverTree<PVector> tree = CoverTree.create(3, 2, circleDistanceMetric);
---
>                 // Replacing CoverTree with a simple list-based structure due to API changes.
>                 final List<PVector> tree = new ArrayList<>();
213,214c210
<                 // Model shape vertices as circles of radius 0, to constrain packed circles
<                 // within shape edge
---
>                 // Model shape vertices as circles of radius 0, to constrain packed circles within shape edge
217c213
<                 vertices.forEach(p -> tree.insert(new double[] { p.x, p.y, 0 }, p));
---
>                 vertices.forEach(p -> tree.add(p));
219,222d214
<                 /*
<                  * "To find the circle nearest to a center (x, y), do a proximity search at (x,
<                  * y, R), where R is greater than or equal to the maximum radius of a circle."
<                  */
226,235c218,221
<                         final PointEntryDist<PVector> nn = tree.query1NN(new double[] { p.x, p.y, largestR }); // find nearest-neighbour circle
< 
<                         /*
<                          * nn.dist() does not return the radius (since it's a distance metric used to
<                          * find nearest circle), so calculate maximum radius for candidate circle using
<                          * 2d euclidean distance between center points minus radius of nearest circle.
<                          */
<                         final float dx = p.x - nn.value().x;
<                         final float dy = p.y - nn.value().y;
<                         final float radius = (float) (Math.sqrt(dx * dx + dy * dy) - nn.value().z);
---
>                         PVector nn = getNearest(tree, p.x, p.y, largestR);
>                         final float dx = p.x - nn.x;
>                         final float dy = p.y - nn.y;
>                         final float radius = (float) (Math.sqrt(dx * dx + dy * dy) - nn.z);
237c223,225
<                                 largestR = (radius >= largestR) ? radius : largestR;
---
>                                 if (radius >= largestR) {
>                                         largestR = radius;
>                                 }
239c227
<                                 tree.insert(new double[] { p.x, p.y, radius }, p); // insert circle into tree
---
>                                 tree.add(p);
247c235
<          * Generates a random circle packing of tangential circles with varying radii
---
>          * Generates a circle packing of tangential circles with varying radii
285,287c273
< 
<                                 // if center point not in circle, check whether circle overlaps with shape using
<                                 // intersects() (somewhat slower)
---
>                                 // if center point not in circle, check whether circle overlaps with shape using intersects() (somewhat slower)
333c319
<          *
---
>          * <p>
362d347
<          * 
398d382
<          * @since 1.3.0
413c397
<          * 
---
>          * <p>
431,435d414
<                 /*
<                  * We want spawn N circles, such that there are enough to (theoretically) cover
<                  * the envelope exactly without any overlap, assuming a packing efficiency of
<                  * ~85% (close to optimum).
<                  */
437,441d415
<                 /*
<                  * Average area is not a simple mean since circle area is quadratic with regards
<                  * to radius. The actual average area of circles with radii a...b is an integral
<                  * of: pi*r^2 dr from r=a to b.
<                  */
464,468d437
<          * Repulsion-packing involves iterative pair-repulsion, in which overlapping
<          * circles move away from each other until there is no overlap. A packing is
<          * first computed for the envelope of the shape, and then any circles which do
<          * not overlap with the shape are discarded.
<          * 
491c460
<                 final List<PVector> packing = packer.getPacking(); // packing result
---
>                 final List<PVector> packing = packer.getPacking();
495d463
<                         // if every circle same radius, use faster contains check
502d469
<                                 // first test whether shape contains circle center point (somewhat faster)
531,532d497
<                 // buffer the geometry to use InAreaLocator to test circles for overlap (this
<                 // works because all circles have the same diameter)
567,570d531
<                 /*
<                  * Buffer the geometry to use InAreaLocator to test circles for overlap (this
<                  * works because all circles have the same diameter).
<                  */
577c538
<                 final double z = radius * Math.sqrt(3); // hex distance between successive columns
---
>                 final double z = radius * Math.sqrt(3);
608c569
<                 final double s = (a + b + c) / 2; // semiPerimeter
---
>                 final double s = (a + b + c) / 2;
626,659d586
<         /**
<          * Calculate the distance between two points in 3D space, where each point
<          * represents a circle with (x, y, r) coordinates. This custom metric considers
<          * both the Euclidean distance between the centers of the circles and the
<          * absolute difference of their radii.
<          * <p>
<          * The metric is defined as follows: Given two points A and B, representing
<          * circles centered at (x1, y1) and (x2, y2) with radii r1 and r2 respectively,
<          * the distance is calculated as sqrt((x1 - x2)^2 + (y1 - y2)^2) + |r1 - r2|.
<          * <p>
<          * This metric can be used to find the nearest circle to a given center (x, y)
<          * in a proximity search. To perform the search, use a point (x, y, R) where R
<          * is greater than or equal to the maximum radius of a circle in the proximity
<          * structure.
<          *
<          * @param p1 3D point representing the first circle (x1, y1, r1)
<          * @param p2 3D point representing the second circle (x2, y2, r2)
<          * @return the distance between the two points based on the custom metric
<          */
<         private static final PointDistanceFunction circleDistanceMetric = (p1, p2) -> {
<                 // from https://stackoverflow.com/a/21975136/
<                 final double dx = p1[0] - p2[0];
<                 final double dy = p1[1] - p2[1];
<                 final double dz = p1[2] - p2[2];
< 
<                 double euclideanDistance = Math.sqrt(dx * dx + dy * dy);
<                 double absZDifference = Math.abs(dz);
<                 return euclideanDistance + absZDifference; // negative if inside
<         };
< 
<         /**
<          * A streams filter to remove triangulation triangles that share at least one
<          * edge with the shape edge.
<          */
663a591,605
>         // New helper method to perform a linear nearest neighbor search.
>         private static PVector getNearest(List<PVector> tree, double x, double y, double queryRadius) {
>                 PVector best = null;
>                 double bestDist = Double.POSITIVE_INFINITY;
>                 for (PVector candidate : tree) {
>                         double dx = x - candidate.x;
>                         double dy = y - candidate.y;
>                         double dist = Math.sqrt(dx * dx + dy * dy) + Math.abs(queryRadius - candidate.z);
>                         if (dist < bestDist) {
>                                 bestDist = dist;
>                                 best = candidate;
>                         }
>                 }
>                 return best;
>         }
