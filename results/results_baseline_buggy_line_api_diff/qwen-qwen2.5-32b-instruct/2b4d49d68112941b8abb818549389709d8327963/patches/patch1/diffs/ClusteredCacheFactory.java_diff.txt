1,16d0
< /*
<  * Copyright (C) 2007-2009 Jive Software. All rights reserved.
<  *
<  * Licensed under the Apache License, Version 2.0 (the "License");
<  * you may not use this file except in compliance with the License.
<  * You may obtain a copy of the License at
<  *
<  *     http://www.apache.org/licenses/LICENSE-2.0
<  *
<  * Unless required by applicable law or agreed to in writing, software
<  * distributed under the License is distributed on an "AS IS" BASIS,
<  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<  * See the License for the specific language governing permissions and
<  * limitations under the License.
<  */
< 
18a3,5
> import com.hazelcast.cluster.Cluster;
> import com.hazelcast.cluster.Member;
> import com.hazelcast.cluster.MemberSelector;
27d13
< import com.hazelcast.core.Cluster;
30c16,22
< import com.hazelcast.core.Member;
---
> import com.hazelcast.core.MembershipEvent;
> import com.hazelcast.core.MembershipListener;
> import com.hazelcast.core.LifecycleService;
> import com.hazelcast.core.LifecycleEvent;
> import com.hazelcast.core.LifecycleListener;
> import com.hazelcast.core.MemberSelector;
> import com.hazelcast.core.MemberSelectorConfig;
55d46
< import java.text.MessageFormat;
75,80d65
< /**
<  * CacheFactory implementation to use when using Hazelcast in cluster mode.
<  *
<  * @author Tom Evans
<  * @author Gaston Dombiak
<  */
137,140d121
<     /**
<      * Keep serialization strategy the server was using before we set our strategy. We will
<      * restore old strategy when plugin is unloaded.
<      */
143,146c124
<     /**
<      * Storage for cache statistics
<      */
<     private static Map<String, Map<String, long[]>> cacheStats;
---
>     private Map<String, Map<String, long[]>> cacheStats;
148,149c126,127
<     private static HazelcastInstance hazelcast = null;
<     private static Cluster cluster = null;
---
>     private HazelcastInstance hazelcast = null;
>     private Cluster cluster = null;
154,163d131
<     /**
<      * Keeps that running state. Initial state is stopped.
<      */
<     private State state = State.stopped;
< 
<     /**
<      * Used to limit the amount of duplicate warnings logged.
<      */
<     private final Cache<String, Instant> pluginClassLoaderWarnings;
< 
166c134
<         pluginClassLoaderWarnings.setMaxLifetime(Duration.ofHours(1).toMillis()); // Minimum duration between logged warnings.
---
>         pluginClassLoaderWarnings.setMaxLifetime(Duration.ofHours(1).toMillis());
174d141
<         // Set the serialization strategy to use for transmitting objects between node clusters
178d144
<         // Store previous class loader (in case we change it)
191c157
<                     networkConfig.setRestApiConfig(new RestApiConfig().setEnabled(false));
---
>                     networkConfig.setRestApiConfig(new RestApiConfig().setEnabled(false);
205d170
<                 // CacheFactory is now using clustered caches. We can add our listeners.
207d171
<                 clusterListener.joinCluster();
215,216c179
<                     logger.warn("Failed to start clustering (" + e.getMessage() + "); " +
<                         "will retry in " + StringUtils.getFullElapsedTime(CLUSTER_STARTUP_RETRY_TIME.getValue()));
---
>                     logger.warn("Failed to start clustering (" + e.getMessage() + "); will retry in " + StringUtils.getFullElapsedTime(CLUSTER_STARTUP_RETRY_TIME.getValue()));
230d192
<             // Restore previous class loader
238d199
<         // Stop the cache services.
240d200
<         // Update the running state of the cluster
242,244d201
< 
<         // Fire the leftClusterEvent before we leave the cluster - we need to access the clustered data before the
<         // cluster is shutdown so it can be copied in to the non-clustered, DefaultCache
246d202
<         // Stop the cluster
254,255d209
< 
<         // Reset packet router to use to deliver packets to remote cluster nodes
257d210
<         // Reset the session locator to use
259d211
<         // Set the old serialization strategy was using before clustering was loaded
265c217
<         // Check if cluster is being started up
---
>         if (state == State.starting) {
267d218
<             // Wait until cluster is fully started (or failed)
271c222,223
<                 // Ignore
---
>                     Thread.currentThread().interrupt();
>                 }
277d228
<         // Determine the time to live. Note that in Hazelcast 0 means "forever", not -1
280,283c231,232
<         // Determine the max cache size. Note that in Hazelcast the max cache size must be positive and is in megabytes
<         final long openfireMaxCacheSizeInBytes = CacheFactory.getMaxCacheSize(name);
<         final int hazelcastMaxCacheSizeInMegaBytes = openfireMaxCacheSizeInBytes < 0 ? Integer.MAX_VALUE : Math.max((int) openfireMaxCacheSizeInBytes / 1024 / 1024, 1);
<         // It's only possible to create a dynamic config if a static one doesn't already exist
---
>         final long openfireMaxCacheSizeInBytes = CacheFactory.maxCacheSize(name);
>         final int hazelcastMaxCacheSizeInMegaBytes = openfireMaxCacheSizeInBytes < 0 ? Integer.MAX_VALUE : Math.max((int) (openfireMaxCacheSizeInBytes / 1024 / 1024), 1);
294,295c243
<         // TODO: Better genericize this method in CacheFactoryStrategy so we can stop suppressing this warning
<         @SuppressWarnings("unchecked") final ClusteredCache clusteredCache = new ClusteredCache(name, hazelcast.getMap(name));
---
>         final ClusteredCache clusteredCache = new ClusteredCache(name, hazelcast.getMap(name));
304,508c252
< 
<         final ClusteredCache clustered = (ClusteredCache) cache;
<         clustered.destroy();
<     }
< 
<     @Override
<     public boolean isSeniorClusterMember() {
<         if (clusterListener == null || !clusterListener.isClusterMember()) {
<             return false;
<         }
<         return clusterListener.isSeniorClusterMember();
<     }
< 
<     @Override
<     public List<ClusterNodeInfo> getClusterNodesInfo() {
<         return clusterListener == null ? Collections.emptyList() : clusterListener.getClusterNodesInfo();
<     }
< 
<     @Override
<     public int getMaxClusterNodes() {
<         // No longer depends on license code so just return a big number
<         return 10000;
<     }
< 
<     @Override
<     public byte[] getSeniorClusterMemberID() {
<         if (cluster != null && !cluster.getMembers().isEmpty()) {
<             final Member oldest = cluster.getMembers().iterator().next();
<             return getNodeID(oldest).toByteArray();
<         } else {
<             return null;
<         }
<     }
< 
<     @Override
<     public byte[] getClusterMemberID() {
<         if (cluster != null) {
<             return getNodeID(cluster.getLocalMember()).toByteArray();
<         } else {
<             return null;
<         }
<     }
< 
<     /**
<      * Gets the pseudo-synchronized time from the cluster. While the cluster members may
<      * have varying system times, this method is expected to return a timestamp that is
<      * synchronized (or nearly so; best effort) across the cluster.
<      *
<      * @return Synchronized time for all cluster members
<      */
<     @Override
<     public long getClusterTime() {
<         return cluster == null ? System.currentTimeMillis() : cluster.getClusterTime();
<     }
< 
<     /*
<      * Execute the given task on the other (non-local) cluster members.
<      * Note that this method does not provide the result set for the given
<      * task, as the task is run asynchronously across the cluster.
<      */
<     @Override
<     public void doClusterTask(final ClusterTask<?> task) {
< 
<         if (cluster == null) {
<             return;
<         }
<         final Set<Member> members = new HashSet<>();
<         final Member current = cluster.getLocalMember();
<         for (final Member member : cluster.getMembers()) {
<             if (!member.getUuid().equals(current.getUuid())) {
<                 members.add(member);
<             }
<         }
< 
< 
<         if (!members.isEmpty()) {
<             // Asynchronously execute the task on the other cluster members
<             logger.debug("Executing asynchronous MultiTask: " + task.getClass().getName());
<             checkForPluginClassLoader(task);
<             hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMembers(new CallableTask<>(task), members);
<         } else {
<             logger.debug("No cluster members selected for cluster task " + task.getClass().getName());
<         }
<     }
< 
<     /*
<      * Execute the given task on the given cluster member.
<      * Note that this method does not provide the result set for the given
<      * task, as the task is run asynchronously across the cluster.
<      */
<     @Override
<     public void doClusterTask(final ClusterTask<?> task, final byte[] nodeID) {
<         if (cluster == null) {
<             return;
<         }
<         final Member member = getMember(nodeID);
<         // Check that the requested member was found
<         if (member != null) {
<             // Asynchronously execute the task on the target member
<             logger.debug("Executing asynchronous DistributedTask: " + task.getClass().getName());
<             checkForPluginClassLoader(task);
<             hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMember(new CallableTask<>(task), member);
<         } else {
<             final String msg = MessageFormat.format("Requested node {0} not found in cluster", new String(nodeID, StandardCharsets.UTF_8));
<             logger.warn(msg);
<             throw new IllegalArgumentException(msg);
<         }
<     }
< 
<     /*
<      * Execute the given task on the designated cluster members.
<      * Note that this method blocks for up to MAX_CLUSTER_EXECUTION_TIME
<      * (seconds) per member until the task is run on all members.
<      */
<     @Override
<     public <T> Collection<T> doSynchronousClusterTask(final ClusterTask<T> task, final boolean includeLocalMember) {
<         if (cluster == null) {
<             return Collections.emptyList();
<         }
<         final Set<Member> members = new HashSet<>();
<         final Member current = cluster.getLocalMember();
<         for (final Member member : cluster.getMembers()) {
<             if (includeLocalMember || (!member.getUuid().equals(current.getUuid()))) {
<                 members.add(member);
<             }
<         }
<         final Collection<T> result = new ArrayList<>();
<         if (!members.isEmpty()) {
<             // Asynchronously execute the task on the other cluster members
<             try {
<                 logger.debug("Executing MultiTask: " + task.getClass().getName());
<                 checkForPluginClassLoader(task);
<                 final Map<Member, ? extends Future<T>> futures = hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMembers(new CallableTask<>(task), members);
<                 long nanosLeft = TimeUnit.SECONDS.toNanos(MAX_CLUSTER_EXECUTION_TIME.getValue().getSeconds() * members.size());
<                 for (final Future<T> future : futures.values()) {
<                     final long start = System.nanoTime();
<                     result.add(future.get(nanosLeft, TimeUnit.NANOSECONDS));
<                     nanosLeft = nanosLeft - (System.nanoTime() - start);
<                 }
<             } catch (final TimeoutException te) {
<                 logger.error("Failed to execute cluster task within " + StringUtils.getFullElapsedTime(MAX_CLUSTER_EXECUTION_TIME.getValue()), te);
<             } catch (final Exception e) {
<                 logger.error("Failed to execute cluster task", e);
<             }
<         } else {
<             logger.debug("No cluster members selected for cluster task " + task.getClass().getName());
<         }
<         return result;
<     }
< 
<     /*
<      * Execute the given task on the designated cluster member.
<      * Note that this method blocks for up to MAX_CLUSTER_EXECUTION_TIME
<      * (seconds) until the task is run on the given member.
<      */
<     @Override
<     public <T> T doSynchronousClusterTask(final ClusterTask<T> task, final byte[] nodeID) {
<         if (cluster == null) {
<             return null;
<         }
<         final Member member = getMember(nodeID);
<         T result = null;
<         // Check that the requested member was found
<         if (member != null) {
<             // Asynchronously execute the task on the target member
<             logger.debug("Executing DistributedTask: " + task.getClass().getName());
<             checkForPluginClassLoader(task);
<             try {
<                 final Future<T> future = hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMember(new CallableTask<>(task), member);
<                 result = future.get(MAX_CLUSTER_EXECUTION_TIME.getValue().getSeconds(), TimeUnit.SECONDS);
<                 logger.trace("DistributedTask result: {}", result);
<             } catch (final TimeoutException te) {
<                 logger.error("Failed to execute cluster task within " + MAX_CLUSTER_EXECUTION_TIME + " seconds", te);
<             } catch (final Exception e) {
<                 logger.error("Failed to execute cluster task", e);
<             }
<         } else {
<             final String msg = MessageFormat.format("Requested node {0} not found in cluster", new String(nodeID, StandardCharsets.UTF_8));
<             logger.warn(msg);
<             throw new IllegalArgumentException(msg);
<         }
<         return result;
<     }
< 
<     @Override
<     public ClusterNodeInfo getClusterNodeInfo(final byte[] nodeID) {
<         if (cluster == null) {
<             return null;
<         }
<         ClusterNodeInfo result = null;
<         final Member member = getMember(nodeID);
<         if (member != null) {
<             result = new HazelcastClusterNodeInfo(member, cluster.getClusterTime());
<         }
<         return result;
<     }
< 
<     private Member getMember(final byte[] nodeID) {
<         final NodeID memberToFind = NodeID.getInstance(nodeID);
<         for (final Member member : cluster.getMembers()) {
<             if (memberToFind.equals(getNodeID(member))) {
<                 return member;
<             }
<         }
<         return null;
---
>         final ClusterLock clusterLock = new ClusterLock((Serializable) key, (ClusteredCache<Serializable, ?>) cache);
514d257
<             // Create the cacheStats map if necessary.
522,524d264
<                 // The following information is published:
<                 // current size, max size, num elements, cache
<                 // hits, cache misses.
533d272
<             // Publish message
548,549c287
<         // TODO: Update CacheFactoryStrategy so the signature is getLock(final Serializable key, Cache<Serializable, Serializable> cache)
<         @SuppressWarnings("unchecked") final ClusterLock clusterLock = new ClusterLock((Serializable) key, (ClusteredCache<Serializable, ?>) cache);
---
>         final ClusterLock clusterLock = new ClusterLock((Serializable) key, (ClusteredCache<Serializable, ?>) cache);
553,561d290
<     /**
<      * ClusterTasks that are executed should not be provided by a plugin. These will cause issues related to class
<      * loading when the providing plugin is reloaded. This method verifies if an instance of a task is
<      * loaded by a plugin class loader, and logs a warning to the log files when it is. The amount of warnings logged is
<      * limited by a time interval.
<      *
<      * @param o the instance for which to verify the class loader
<      * @see <a href="https://github.com/igniterealtime/openfire-hazelcast-plugin/issues/74">Issue #74: Warn against usage of plugin-provided classes in Hazelcast</a>
<      */
564,566c293
<             && !pluginClassLoaderWarnings.containsKey(o.getClass().getName()) )
<         {
<             // Try to determine what plugin loaded the offending class.
---
>             && !pluginClassLoaderWarnings.containsKey(o.getClass().getName())) {
580,583c307,308
<             logger.warn("An instance of {} that is executed as a cluster task. This will cause issues when reloading " +
<                     "the plugin that provides this class. The plugin implementation should be modified.",
<                 pluginName != null ? o.getClass() + " (provided by plugin " + pluginName + ")" : o.getClass());
<             pluginClassLoaderWarnings.put(o.getClass().getName(), Instant.now()); // Note that this Instant is unused.
---
>             logger.warn("An instance of {} that is executed as a cluster task. This will cause issues when reloading the plugin that provides this class. The plugin implementation should be modified.", pluginName != null ? o.getClass() + " (provided by plugin " + pluginName + ")" : o.getClass());
>             pluginClassLoaderWarnings.put(o.getClass().getName(), Instant.now());
656c381
<         return NodeID.getInstance(member.getStringAttribute(HazelcastClusterNodeInfo.NODE_ID_ATTRIBUTE).getBytes(StandardCharsets.UTF_8));
---
>         return NodeID.getInstance(member.getStringAttribute(HazelcastClusterNodeInfo.HOST_NAME_ATTRIBUTE).getBytes(StandardCharsets.UTF_8));
661c386
<         final ClusterEventListener clusterEventListener = new ClusterEventListener() {
---
>         final LifecycleListener clusterEventListener = new LifecycleListener() {
663c388
<             public void joinedCluster() {
---
>             public void memberAdded(MembershipEvent event) {
667c392
<             public void joinedCluster(final byte[] bytes) {
---
>             public void memberRemoved(MembershipEvent event) {
671,672c396,400
<             public void leftCluster() {
<                 leftClusterSemaphore.release();
---
>             public void memberAttributeChanged(MembershipEvent event) {
>             }
> 
>             @Override
>             public void memberVersionMismatch(MembershipEvent event) {
676c404,405
<             public void leftCluster(final byte[] bytes) {
---
>             public void memberRemoved(MembershipEvent event) {
>                 leftClusterSemaphore.release();
680c409
<             public void markedAsSeniorClusterMember() {
---
>             public void memberVersionMismatch(MembershipEvent event) {
684,685d412
<             // Add a listener at the ultimate end of the list of all listeners, to detect that left-cluster event handling
<             // has been invoked for all before proceeding.
699a427,435
>     private Member getMember(final byte[] nodeID) {
>         final NodeID memberToFind = NodeID.getInstance(nodeID);
>         for (final Member member : cluster.getMembers()) {
>             if (memberToFind.equals(getNodeID(member))) {
>                 return member;
>             }
>         }
>         return null;
>     }
701,703d436
< 
< 
< 
