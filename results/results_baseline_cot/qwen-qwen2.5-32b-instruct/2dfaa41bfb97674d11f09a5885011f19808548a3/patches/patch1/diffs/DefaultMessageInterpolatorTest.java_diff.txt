1,16d0
< /*
<  * Licensed to the Apache Software Foundation (ASF) under one or more
<  * contributor license agreements. See the NOTICE file distributed with this
<  * work for additional information regarding copyright ownership. The ASF
<  * licenses this file to you under the Apache License, Version 2.0 (the
<  * "License"); you may not use this file except in compliance with the License.
<  * You may obtain a copy of the License at
<  *
<  * http://www.apache.org/licenses/LICENSE-2.0
<  *
<  * Unless required by applicable law or agreed to in writing, software
<  * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
<  * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
<  * License for the specific language governing permissions and limitations under
<  * the License.
<  */
117c101
<         assumeTrue(originalClassLoader != null);
---
>         assumeThat(originalClassLoader, anyOf(equalTo(null)));
125,127c109,110
<                 () -> validator.getConstraintsForClass(PreferredGuest.class)
<                     .getConstraintsForProperty("guestCreditCardNumber").getConstraintDescriptors().stream()
<                     .filter(forConstraintType(Digits.class)).findFirst()
---
>                 () -> validator.getConstraintsForClass(PreferredGuest.class).getConstraintsForProperty("guestCreditCardNumber")
>                     .getConstraintDescriptors().stream().filter(forConstraintType(Digits.class)).findFirst()
144,147d126
<     /**
<      * Checks that strings containing special characters are correctly
<      * substituted when interpolating.
<      */
155c134
<                     .orElseThrow(() -> new AssertionError("expected constraint missing"))));
---
>                     .orElseThrow(() -> new AssertionError("expected constraint missing")));
157,158c136
<         assertEquals("Incorrect message interpolation when $ is in an attribute", "Id number should match ....$",
<             idNumberResult);
---
>         assertEquals("Id number should match ....$", idNumberResult);
165,189d142
<                     .orElseThrow(() -> new AssertionError("expected constraint missing"))));
< 
<         assertEquals("Incorrect message interpolation when \\ is in an attribute value", "Other id should match .\\n",
<             otherIdResult);
<     }
< 
<     @Test
<     public void testRecursiveInterpolation() {
<         String msg = this.interpolator.interpolate("{recursive.interpolation.1}",
<             context("12345678",
<                 () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty("idNumber")
<                     .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()
<                     .orElseThrow(() -> new AssertionError("expected constraint missing"))));
< 
<         assertEquals("must match \"....$\"", msg);
<     }
< 
<     @Test
<     public void testNoELAvailable() {
<         assumeThat(elImpl, equalTo("invalid"));
<         assertFalse(elAvailable);
<         
<         ApacheMessageContext context = context("12345678",
<             () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty("idNumber")
<             .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()
192,197c145
<         when(context
<             .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))
<                 .thenAnswer(invocation -> Boolean.toString(true));
< 
<         assertEquals("${regexp.charAt(4)}", interpolator.interpolate("${regexp.charAt(4)}",
<             context));
---
>         assertEquals("Other id should match .\\n", otherIdResult);
201,212c149
<     public void testDisallowCustomTemplateExpressionEvaluationByDefault() {
<         assumeTrue(elAvailable);
< 
<         assertEquals("${regexp.charAt(4)}", interpolator.interpolate("${regexp.charAt(4)}",
<             context("12345678",
<                 () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty("idNumber")
<                 .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()
<                 .orElseThrow(() -> new AssertionError("expected constraint missing")))));
<     }
< 
<     @Test
<     public void testExpressionLanguageEvaluation() {
---
>     public void testRecursiveInterpolation() {
220,221c157
<         assertEquals("Another value should match ....$",
<             interpolator.interpolate(context.getConstraintDescriptor().getMessageTemplate(), context));
---
>         assertEquals("Another value should match ....$", interpolator.interpolate(context.getConstraintDescriptor().getMessageTemplate(), context));
233,311c169
<         assertEquals("Mixed message value of length 8 should match ....$",
<             interpolator.interpolate(context.getConstraintDescriptor().getMessageTemplate(), context));
<     }
< 
<     @Test
<     public void testELEscapingTomcatJuel() {
<         assumeTrue(elAvailable);
<         assumeThat(elImpl, anyOf(equalTo("tomcat")));
< 
<         // not so much a test as an illustration that the specified EL implementations are seemingly confused by leading
<         // backslashes and treats the whole expression as literal. We could skip any literal text before the first
<         // non-escaped $, but that would only expose us to inconsistency for composite expressions containing more
<         // than one component EL expression
< 
<         ApacheMessageContext context = context("12345678",
<             () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty("idNumber")
<             .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()
<             .orElseThrow(() -> new AssertionError("expected constraint missing")));
< 
<         when(context
<             .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))
<                 .thenAnswer(invocation -> Boolean.toString(true));
< 
<         assertEquals("${regexp.charAt(4)}", interpolator.interpolate("\\${regexp.charAt(4)}",
<             context));
< 
<         assertEquals("${regexp.charAt(4)}", interpolator.interpolate("\\\\${regexp.charAt(4)}",
<             context));
<     }
< 
<     @Test
<     public void testELEscapingRI() {
<         assumeTrue(elAvailable);
<             assumeThat(elImpl, equalTo("ri"));
< 
<         ApacheMessageContext context = context("12345678",
<             () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty("idNumber")
<                 .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()
<                 .orElseThrow(() -> new AssertionError("expected constraint missing")));
< 
<         when(context
<             .getConfigurationProperty(ApacheValidatorConfiguration.Properties.CUSTOM_TEMPLATE_EXPRESSION_EVALUATION))
<         .thenAnswer(invocation -> Boolean.toString(true));
< 
<         assertEquals("returns literal", "${regexp.charAt(4)}",
<             interpolator.interpolate("\\${regexp.charAt(4)}",
<                 context));
< 
<         assertEquals("returns literal \\ followed by $, later interpreted as an escape sequence", "$",
<             interpolator.interpolate("\\\\${regexp.charAt(4)}",
<                 context));
< 
<         assertEquals("returns literal \\ followed by .", "\\.",
<             interpolator.interpolate("\\\\${regexp.charAt(3)}",
<                 context));
<     }
< 
<     @Test
<     public void testEscapedELPattern() {
<         assertEquals("$must match \"....$\"",
<             interpolator.interpolate("\\${jakarta.validation.constraints.Pattern.message}",
<                 context("12345678",
<                     () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty("idNumber")
<                         .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()
<                         .orElseThrow(() -> new AssertionError("expected constraint missing")))));
< 
<         assertEquals("$must match \"....$\"",
<             interpolator.interpolate("\\${jakarta.validation.constraints.Pattern.message}",
<                 context("12345678",
<                     () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty("idNumber")
<                     .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()
<                     .orElseThrow(() -> new AssertionError("expected constraint missing")))));
< 
<         assertEquals("\\$must match \"....$\"",
<             interpolator.interpolate("\\\\\\${jakarta.validation.constraints.Pattern.message}",
<                 context("12345678",
<                     () -> validator.getConstraintsForClass(Person.class).getConstraintsForProperty("idNumber")
<                     .getConstraintDescriptors().stream().filter(forConstraintType(Pattern.class)).findFirst()
<                     .orElseThrow(() -> new AssertionError("expected constraint missing")))));
---
>         assertEquals("Mixed message value of length 8 should match ....$", interpolator.interpolate(context.getConstraintDescriptor().getMessageTemplate(), context);
317,318c175,176
<         when(result.unwrap(any(Class.class)))
<             .thenAnswer(invocation -> invocation.getArgumentAt(0, Class.class).cast(result));
---
>         when(result.unwrap(Mockito.any(Class.class)))
>             .thenAnswer(invocation -> invocation.getArgument(0, Class.class).cast(result));
