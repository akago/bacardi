1,16d0
< /*
<  * Copyright 2016 Google LLC
<  *
<  * Licensed under the Apache License, Version 2.0 (the "License");
<  * you may not use this file except in compliance with the License.
<  * You may obtain a copy of the License at
<  *
<  *       http://www.apache.org/licenses/LICENSE-2.0
<  *
<  * Unless required by applicable law or agreed to in writing, software
<  * distributed under the License is distributed on an "AS IS" BASIS,
<  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<  * See the License for the specific language governing permissions and
<  * limitations under the License.
<  */
< 
21d4
< import static java.net.HttpURLConnection.HTTP_OK;
25,31d7
< import com.google.api.services.cloudresourcemanager.model.Binding;
< import com.google.api.services.cloudresourcemanager.model.Operation;
< import com.google.api.services.cloudresourcemanager.model.Policy;
< import com.google.api.services.cloudresourcemanager.model.Project;
< import com.google.api.services.cloudresourcemanager.model.SetIamPolicyRequest;
< import com.google.api.services.cloudresourcemanager.model.TestIamPermissionsRequest;
< import com.google.api.services.cloudresourcemanager.model.TestIamPermissionsResponse;
33d8
< import com.google.cloud.resourcemanager.ResourceManagerOptions;
46a22
> import java.net.HttpURLConnection;
64d39
< import java.util.zip.GZIPInputStream;
70,94c45,46
<  * Utility to create a local Resource Manager mock for testing.
<  *
<  * <p>The mock runs in a separate thread, listening for HTTP requests on the local machine at an
<  * ephemeral port. While this mock attempts to simulate the Cloud Resource Manager, there are some
<  * divergences in behavior. The following is a non-exhaustive list of some of those behavioral
<  * differences:
<  *
<  * <ul>
<  *   <li>This mock assumes you have adequate permissions for any action. Related to this,
<  *       <i>testIamPermissions</i> always indicates that the caller has all permissions listed in
<  *       the request.
<  *   <li>IAM policies are set to an empty policy with version 0 (only legacy roles supported) upon
<  *       project creation. The actual service will not have an empty list of bindings and may also
<  *       set your version to 1.
<  *   <li>There is no input validation for the policy provided when replacing a policy or calling
<  *       testIamPermissions.
<  *   <li>In this mock, projects never move from the <i>DELETE_REQUESTED</i> lifecycle state to
<  *       <i>DELETE_IN_PROGRESS</i> without an explicit call to the utility method {@link
<  *       #changeLifecycleState}. Similarly, a project is never completely removed without an
<  *       explicit call to the utility method {@link #removeProject}.
<  *   <li>The messages in the error responses given by this mock do not necessarily match the
<  *       messages given by the actual service.
<  * </ul>
<  *
<  * @deprecated v3 GAPIC client of ResourceManager is now available
---
>  * Utility to create a {@code LocalResourceManagerHelper} object that listens to requests on the local
>  * machine.
110d61
<   private static final String[] NO_FIELDS = {};
117c68
<           "Could not initialize LocalResourceManagerHelper due to URISyntaxException.", e);
---
>           ("Could not initialize LocalResourceManagerHelper due to URISyntaxException.", e);
121,124d71
<   // see https://cloud.google.com/resource-manager/reference/rest/v1beta1/projects
<   private static final Set<Character> PERMISSIBLE_PROJECT_NAME_PUNCTUATION =
<       ImmutableSet.of('-', '\'', '"', ' ', '!');
< 
130,303d76
<   private static class Response {
<     private final int code;
<     private final String body;
< 
<     Response(int code, String body) {
<       this.code = code;
<       this.body = body;
<     }
< 
<     int code() {
<       return code;
<     }
< 
<     String body() {
<       return body;
<     }
<   }
< 
<   private enum Error {
<     ABORTED(409, "global", "aborted", "ABORTED"),
<     ALREADY_EXISTS(409, "global", "alreadyExists", "ALREADY_EXISTS"),
<     PERMISSION_DENIED(403, "global", "forbidden", "PERMISSION_DENIED"),
<     FAILED_PRECONDITION(400, "global", "failedPrecondition", "FAILED_PRECONDITION"),
<     INVALID_ARGUMENT(400, "global", "badRequest", "INVALID_ARGUMENT"),
<     BAD_REQUEST(400, "global", "badRequest", "BAD_REQUEST"),
<     INTERNAL_ERROR(500, "global", "internalError", "INTERNAL_ERROR");
< 
<     private final int code;
<     private final String domain;
<     private final String reason;
<     private final String status;
< 
<     Error(int code, String domain, String reason, String status) {
<       this.code = code;
<       this.domain = domain;
<       this.reason = reason;
<       this.status = status;
<     }
< 
<     Response response(String message) {
<       try {
<         return new Response(code, toJson(message));
<       } catch (IOException e) {
<         return Error.INTERNAL_ERROR.response("Error when generating JSON error response");
<       }
<     }
< 
<     private String toJson(String message) throws IOException {
<       Map<String, Object> errors = new HashMap<>();
<       errors.put("domain", domain);
<       errors.put("message", message);
<       errors.put("reason", reason);
<       Map<String, Object> args = new HashMap<>();
<       args.put("errors", ImmutableList.of(errors));
<       args.put("code", code);
<       args.put("message", message);
<       args.put("status", status);
<       return jsonFactory.toString(ImmutableMap.of("error", args));
<     }
<   }
< 
<   private class RequestHandler implements HttpHandler {
<     @Override
<     public void handle(HttpExchange exchange) {
<       // see https://cloud.google.com/resource-manager/reference/rest/
<       Response response;
<       String path = BASE_CONTEXT.relativize(exchange.getRequestURI()).getPath();
<       String requestMethod = exchange.getRequestMethod();
<       try {
<         switch (requestMethod) {
<           case "POST":
<             response = handlePost(exchange, path);
<             break;
<           case "DELETE":
<             response = delete(projectIdFromUri(path));
<             break;
<           case "GET":
<             if (!path.isEmpty()) {
<               response =
<                   get(projectIdFromUri(path), parseFields(exchange.getRequestURI().getQuery()));
<             } else {
<               response = list(parseListOptions(exchange.getRequestURI().getQuery()));
<             }
<             break;
<           case "PUT":
<             String requestBody =
<                 decodeContent(exchange.getRequestHeaders(), exchange.getRequestBody());
<             response =
<                 replace(projectIdFromUri(path), jsonFactory.fromString(requestBody, Project.class));
<             break;
<           default:
<             response =
<                 Error.BAD_REQUEST.response(
<                     "The server could not understand the following request URI: "
<                         + requestMethod
<                         + " "
<                         + path);
<         }
<       } catch (IOException e) {
<         response = Error.BAD_REQUEST.response(e.getMessage());
<       }
<       writeResponse(exchange, response);
<     }
<   }
< 
<   private Response handlePost(HttpExchange exchange, String path) throws IOException {
<     String requestBody = decodeContent(exchange.getRequestHeaders(), exchange.getRequestBody());
<     if (!path.contains(":")) {
<       return create(jsonFactory.fromString(requestBody, Project.class));
<     } else {
<       switch (path.split(":", 2)[1]) {
<         case "undelete":
<           return undelete(projectIdFromUri(path));
<         case "getIamPolicy":
<           return getPolicy(projectIdFromUri(path));
<         case "setIamPolicy":
<           return replacePolicy(
<               projectIdFromUri(path),
<               jsonFactory.fromString(requestBody, SetIamPolicyRequest.class).getPolicy());
<         case "testIamPermissions":
<           return testPermissions(
<               projectIdFromUri(path),
<               jsonFactory
<                   .fromString(requestBody, TestIamPermissionsRequest.class)
<                   .getPermissions());
<         default:
<           return Error.BAD_REQUEST.response(
<               "The server could not understand the following request URI: POST " + path);
<       }
<     }
<   }
< 
<   private class OperationRequestHandler implements HttpHandler {
<     @Override
<     public void handle(HttpExchange exchange) {
<       // see https://cloud.google.com/resource-manager/reference/rest/
<       String projectId;
<       try {
<         projectId = new URI(OPERATION_CONTEXT).relativize(exchange.getRequestURI()).getPath();
<       } catch (URISyntaxException e) {
<         throw new IllegalStateException(e);
<       }
<       Response response;
<       String requestMethod = exchange.getRequestMethod();
<       switch (requestMethod) {
<         case "GET":
<           Project project = projects.get(projectId);
<           if (project == null) {
<             response = Error.PERMISSION_DENIED.response("Project " + projectId + " not found.");
<             break;
<           }
<           try {
<             response =
<                 new Response(
<                     HTTP_OK,
<                     jsonFactory.toString(new Operation().setDone(true).setResponse(project)));
<           } catch (IOException e) {
<             response =
<                 Error.INTERNAL_ERROR.response(
<                     "Error when serializing project " + project.getProjectId());
<           }
<           break;
<         default:
<           response =
<               Error.BAD_REQUEST.response(
<                   "The server could not understand the following request URI: "
<                       + requestMethod
<                       + " "
<                       + projectId);
<       }
<       writeResponse(exchange, response);
<     }
<   }
< 
327c100
<               "The request has the following unsupported HTTP content encoding: " + encoding);
---
>               ("The request has the following unsupported HTTP content encoding: " + encoding);
454c227
<               .format(Instant.ofEpochMilli(System.currentTimeMillis())));
---
>               .format(Instant.ofEpochMilli(System.currentTimeMillis()));
457c230
<             "A project with the same project ID (" + project.getProjectId() + ") already exists.");
---
>             ("A project with the same project ID (" + project.getProjectId() + ") already exists.");
461c234
<               .setBindings(Collections.<Binding>emptyList())
---
>               .setBindings(Collections.emptyList())
469,470c242,243
<                 new Operation().setDone(false).setName("operations/" + project.getProjectId()));
<         return new Response(HTTP_OK, createdProjectStr);
---
>                 (new Operation().setDone(false).setName("operations/" + project.getProjectId()));
>         return new Response(HttpURLConnection.HTTP_OK, createdProjectStr);
472c245,246
<         return Error.INTERNAL_ERROR.response("Error serializing project " + project.getProjectId());
---
>         return Error.INTERNAL_ERROR.response
>             ("Error serializing project " + project.getProjectId());
480,481c254,255
<       return Error.PERMISSION_DENIED.response(
<           "Error when deleting " + projectId + " because the project was not found.");
---
>       return Error.PERMISSION_DENIED.response
>           ("Error when deleting " + projectId + " because the project was not found.");
484,485c258,259
<       return Error.FAILED_PRECONDITION.response(
<           "Error when deleting " + projectId + " because the lifecycle state was not ACTIVE.");
---
>       return Error.FAILED_PRECONDITION.response
>           ("Error when delete " + projectId + " because the lifecycle state was not ACTIVE.");
488c262
<       return new Response(HTTP_OK, "{}");
---
>       return new Response(HttpURLConnection.HTTP_OK, "{}");
496c270
<         return new Response(HTTP_OK, jsonFactory.toString(extractFields(project, fields)));
---
>         return new Response(HttpURLConnection.HTTP_OK, jsonFactory.toString(extractFields(project, fields));
498,499c272,273
<         return Error.INTERNAL_ERROR.response(
<             "Error when serializing project " + project.getProjectId());
---
>         return Error.INTERNAL_ERROR.response
>             ("Error when serializing project " + project.getProjectId());
530c304
<           projectsSerialized.add(jsonFactory.toString(extractFields(p, projectFields)));
---
>           projectsSerialized.add(jsonFactory.toString(extractFields(p, projectFields));
532,533c306,307
<           return Error.INTERNAL_ERROR.response(
<               "Error when serializing project " + p.getProjectId());
---
>           return Error.INTERNAL_ERROR.response
>               ("Error when serializing project " + p.getProjectId());
547c321
<         && (listFields == null || ImmutableSet.copyOf(listFields).contains("nextPageToken"))) {
---
>         && (listFields == null || ImmutableSet.copyOf(listFields).contains("nextPageToken")) {
556c330
<     return new Response(HTTP_OK, responseBody.toString());
---
>     return new Response(HttpURLConnection.HTTP_OK, responseBody.toString());
562c336
<       if (!("id".equals(field) || "name".equals(field) || field.startsWith("labels."))) {
---
>       if (!("id".equals(field) || "name".equals(field) || field.startsWith("labels.")) {
640,641c414,415
<       return Error.PERMISSION_DENIED.response(
<           "Error when replacing " + projectId + " because the project was not found.");
---
>       return Error.PERMISSION_DENIED.response
>           ("Error when replacing " + projectId + " because the project was not found.");
643,644c417,418
<       return Error.FAILED_PRECONDITION.response(
<           "Error when replacing " + projectId + " because the lifecycle state was not ACTIVE.");
---
>       return Error.FAILED_PRECONDITION.response
>           ("Error when replace " + projectId + " because the lifecycle state was not ACTIVE.");
646,647c420,421
<       return Error.INVALID_ARGUMENT.response(
<           "The server currently only supports setting the parent once "
---
>       return Error.INVALID_ARGUMENT.response
>           ("The server currently only supports setting the parent once "
657c431
<       return new Response(HTTP_OK, jsonFactory.toString(project));
---
>       return new Response(HttpURLConnection.HTTP_OK, jsonFactory.toString(project));
659c433,434
<       return Error.INTERNAL_ERROR.response("Error when serializing project " + projectId);
---
>       return Error.INTERNAL_ERROR.response
>           ("Error when serializing project " + projectId);
668,669c443,444
<           Error.PERMISSION_DENIED.response(
<               "Error when undeleting " + projectId + " because the project was not found.");
---
>           Error.PERMISSION_DENIED.response
>               ("Error when undelete " + projectId + " because the project was not found.");
672,673c447,448
<           Error.FAILED_PRECONDITION.response(
<               "Error when undeleting "
---
>           Error.FAILED_PRECONDITION.response
>               ("Error when undelete "
678c453
<       response = new Response(HTTP_OK, "{}");
---
>       response = new Response(HttpURLConnection.HTTP_OK, "{}");
689c464
<       return new Response(HTTP_OK, jsonFactory.toString(policy));
---
>       return new Response(HttpURLConnection.HTTP_OK, jsonFactory.toString(policy);
691,692c466,467
<       return Error.INTERNAL_ERROR.response(
<           "Error when serializing the IAM policy for " + projectId);
---
>       return Error.INTERNAL_ERROR.response
>           ("Error when serializing the IAM policy for " + projectId);
699,700c474,475
<       return Error.PERMISSION_DENIED.response(
<           "Error when replacing the policy for "
---
>       return Error.PERMISSION_DENIED.response
>           ("Error when replace the policy for "
706,707c481,482
<       return Error.ABORTED.response(
<           "Policy etag mismatch when replacing the policy for project "
---
>       return Error.ABORTED.response
>           ("Policy etag mismatch when replace the policy for project "
715c490
<       return new Response(HTTP_OK, jsonFactory.toString(policy));
---
>       return new Response(HttpURLConnection.HTTP_OK, jsonFactory.toString(policy);
717,718c492,493
<       return Error.INTERNAL_ERROR.response(
<           "Error when serializing the policy for project " + projectId);
---
>       return Error.INTERNAL_ERROR.response
>           ("Error when serializing the policy for project " + projectId);
727,729c502,504
<       return new Response(
<           HTTP_OK,
<           jsonFactory.toString(new TestIamPermissionsResponse().setPermissions(permissions)));
---
>       return new Response
>           (HttpURLConnection.HTTP_OK,
>           jsonFactory.toString(new TestIamPermissionsResponse().setPermissions(permissions));
731c506,776
<       return Error.INTERNAL_ERROR.response("Error when serializing permissions " + permissions);
---
>       return Error.INTERNAL_ERROR.response
>           ("Error when serializing permissions " + permissions);
>     }
>   }
> 
>   private static class Project {
>     private String projectId;
>     private String name;
>     private String lifecycleState;
>     private String createTime;
>     private String projectNumber;
>     private Map<String, String> labels;
>     private String parent;
> 
>     public String getProjectId() {
>       return projectId;
>     }
> 
>     public void setProjectId(String projectId) {
>       this.projectId = projectId;
>     }
> 
>     public String getName() {
>       return name;
>     }
> 
>     public void setName(String name) {
>       this.name = name;
>     }
> 
>     public String getLifecycleState() {
>       return lifecycleState;
>     }
> 
>     public void setLifecycleState(String lifecycleState) {
>       this.lifecycleState = lifecycleState;
>     }
> 
>     public String getCreateTime() {
>       return createTime;
>     }
> 
>     public void setCreateTime(String createTime) {
>       this.createTime = createTime;
>     }
> 
>     public String getProjectNumber() {
>       return projectNumber;
>     }
> 
>     public void setProjectNumber(String projectNumber) {
>       this.projectNumber = projectNumber;
>     }
> 
>     public Map<String, String> getLabels() {
>       return labels;
>     }
> 
>     public void setLabels(Map<String, String> labels) {
>       this.labels = labels;
>     }
> 
>     public String getParent() {
>       return parent;
>     }
> 
>     public void setParent(String parent) {
>       this.parent = parent;
>     }
>   }
> 
>   private static class Policy {
>     private List<Binding> bindings;
>     private String etag;
>     private int version;
> 
>     public List<Binding> getBindings() {
>       return bindings;
>     }
> 
>     public void setBindings(List<Binding> bindings) {
>       this.bindings = bindings;
>     }
> 
>     public String getEtag() {
>       return etag;
>     }
> 
>     public void setEtag(String etag) {
>       this.etag = etag;
>     }
> 
>     public int getVersion() {
>       return version;
>     }
> 
>     public void setVersion(int version) {
>       this.version = version;
>     }
>   }
> 
>   private static class Binding {
>     // Define the fields and methods for Binding as needed
>   }
> 
>   private static class Operation {
>     private boolean done;
>     private String name;
> 
>     public boolean isDone() {
>       return done;
>     }
> 
>     public void setDone(boolean done) {
>       this.done = done;
>     }
> 
>     public String getName() {
>       return name;
>     }
> 
>     public void setName(String name) {
>       this.name = name;
>     }
>   }
> 
>   private static class SetIamPolicyRequest {
>     private Policy policy;
> 
>     public Policy getPolicy() {
>       return policy;
>     }
> 
>     public void setPolicy(Policy policy) {
>       this.policy = policy;
>     }
>   }
> 
>   private static class TestIamPermissionsRequest {
>     private List<String> permissions;
> 
>     public List<String> getPermissions() {
>       return permissions;
>     }
> 
>     public void setPermissions(List<String> permissions) {
>       this.permissions = permissions;
>     }
>   }
> 
>   private static class TestIamPermissionsResponse {
>     private List<String> permissions;
> 
>     public List<String> getPermissions() {
>       return permissions;
>     }
> 
>     public void setPermissions(List<String> permissions) {
>       this.permissions = permissions;
>     }
>   }
> 
>   private static class Response {
>     private int code;
>     private String body;
> 
>     public Response(int code, String body) {
>       this.code = code;
>       this.body = body;
>     }
> 
>     public int code() {
>       return code;
>     }
> 
>     public String body() {
>       return body;
>     }
>   }
> 
>   private static class Error {
>     private final int code;
>     private final String domain;
>     private final String reason;
>     private final String status;
> 
>     public Error(int code, String domain, String reason, String status) {
>       this.code = code;
>       this.domain = domain;
>       this.reason = reason;
>       this.status = status;
>     }
> 
>     public Response response(String message) {
>       try {
>         return new Response(code, toJson(message));
>       } catch (IOException e) {
>         return new Response(HttpURLConnection.HTTP_INTERNAL_ERROR, "Error when generating JSON error response.");
>       }
>     }
> 
>     private String toJson(String message) throws IOException {
>       Map<String, Object> errors = new HashMap<>();
>       errors.put("domain", domain);
>       errors.put("message", message);
>       errors.put("reason", reason);
>       return jsonFactory.toString(ImmutableMap.of("error", errors));
>     }
>   }
> 
>   private class RequestHandler implements HttpHandler {
>     public void handle(HttpExchange exchange) {
>       // see https://cloud.google.com/resource-manager/reference/rest/
>       Response response;
>       String path = BASE_CONTEXT.relativize(exchange.getRequestURI()).getPath();
>       String requestMethod = exchange.getRequestMethod();
>       try {
>         switch (requestMethod) {
>           case "POST":
>             response = handlePost(exchange, path);
>             break;
>           case "DELETE":
>             response = delete(projectIdFromUri(path));
>             break;
>           case "GET":
>             if (!path.isEmpty()) {
>               response =
>                   get(projectIdFromUri(path), parseFields(exchange.getRequestURI().getQuery()));
>             } else {
>               response = list(parseListOptions(exchange.getRequestURI().getQuery()));
>             }
>             break;
>           case "PUT":
>             String requestBody =
>                 decodeContent(exchange.getRequestHeaders(), exchange.getRequestBody());
>             response =
>                 replace(projectIdFromUri(path), jsonFactory.fromString(requestBody, Project.class));
>             break;
>         }
>       } catch (IOException e) {
>         log.log(Level.WARNING, "IOException encountered when sending response.", e);
>       }
>     }
>   }
> 
>   private class OperationRequestHandler implements HttpHandler {
>     public void handle(HttpExchange exchange) {
>       // see https://cloud.google.com/resource-manager/reference/rest/
>       String projectId;
>       try {
>         projectId = new URI(OPERATION_CONTEXT).relativize(exchange.getRequestURI()).getPath();
>       } catch (URISyntaxException e) {
>         throw new IllegalStateException(e);
>       }
>       Response response;
>       String requestMethod = exchange.getRequestMethod();
>       switch (requestMethod) {
>         case "GET":
>           Project project = projects.get(checkNotNull(projectId);
>           if (project != null) {
>             try {
>               return new Response(HttpURLConnection.HTTP_OK, jsonFactory.toString(project);
>             } catch (IOException e) {
>               return Error.INTERNAL_ERROR.response
>                   ("Error serializing project " + project.getProjectId());
>             }
>           } else {
>             return Error.PERMISSION_DENIED.response
>                 ("Project " + projectId + " not found.");
>           }
>       }
742c787,788
<       throw new RuntimeException("Could not bind the mock Resource Manager server.", e);
---
>       throw new RuntimeException
>           ("Could not bind the mock Resource Manager server.", e);
764c810,812
<   /** Starts the thread that runs the Resource Manager server. */
---
>   /**
>    * Starts the thread that runs the Resource Manager server.
>    */
769c817,819
<   /** Stops the thread that runs the mock Resource Manager server. */
---
>   /**
>    * Stops the thread that runs the mock Resource Manager server.
>    */
780,781c830,831
<     checkArgument(
<         "ACTIVE".equals(lifecycleState)
---
>     checkArgument
>         ("ACTIVE".equals(lifecycleState)
784,785c834,835
<         "Lifecycle state must be ACTIVE, DELETE_REQUESTED, or DELETE_IN_PROGRESS");
<     Project project = projects.get(checkNotNull(projectId));
---
>         "Lifecycle state must be ACTIVE, DELETE_REQUESTED, or DELETE_IN_PROGRESS.");
>     Project project = projects.get(projectId);
796,797c846
<    * <p>This method can be used to fully remove a project (to mimic when the server completely
<    * deletes a project).
---
>    * <p>The project is removed from the map.
802,804c851,852
<     // Because this method is synchronized, any code that relies on non-atomic read/write operations
<     // should not fail if that code is also synchronized.
<     policies.remove(checkNotNull(projectId));
---
>     // Because this method is synchronized, both this method and removeProject are synchronized
>     policies.remove(projectId);
