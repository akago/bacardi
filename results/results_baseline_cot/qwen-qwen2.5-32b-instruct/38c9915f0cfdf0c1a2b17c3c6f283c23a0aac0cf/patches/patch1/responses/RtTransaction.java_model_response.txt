<code_analysis>
The error messages indicate that several classes and methods used in the `RtTransaction` class are no longer available in the updated version of the `org.cactoos` dependency. The missing classes include `UncheckedScalar`, `IoCheckedScalar`, `SplitText`, `StickyScalar`, `LengthOf`, and `TrimmedText`. These classes were likely removed or renamed in the newer version of the dependency.

To fix the issue, we need to replace the usage of these classes with equivalent functionality using the updated dependency classes. We will also need to ensure that the correct imports are used for the new classes.
</code_analysis>

```java
package io.zold.api;

import java.io.IOException;
import java.math.BigInteger;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;
import java.util.regex.Pattern;
import org.cactoos.Text;
import org.cactoos.text.FormattedText;
import org.cactoos.text.SplitText;
import org.cactoos.text.TextOf;
import org.cactoos.text.TrimmedText;
import org.cactoos.time.ZonedDateTimeOf;

/**
 * RtTransaction.
 *
 * @since 0.1
 * @checkstyle ClassDataAbstractionCoupling (3 lines)
 */
@SuppressWarnings({"PMD.AvoidCatchingGenericException",
    "PMD.AvoidFieldNameMatchingMethodName"})
final class RtTransaction implements Transaction {

    /**
     * Pattern for Prefix String.
     */
    private static final Pattern PREFIX = Pattern.compile(
        // @checkstyle LineLengthCheck (1 line)
        "^([A-Za-z0-9+\\/]{4})*([A-Za-z0-9+\\/]{4}|[A-Za-z0-9+\\/]{3}=|[A-Za-z0-9+\\/]{2}==)$"
    );

    /**
     * Pattern for 16 symbol hex string.
     */
    private static final Pattern HEX = Pattern.compile("[A-Fa-f0-9]{16}");

    /**
     * Pattern for parsing Signature.
     */
    private static final Pattern SIGN = Pattern.compile("[A-Za-z0-9+/]+={0,3}");

    /**
     * Pattern for Details string.
     */
    private static final Pattern DTLS =
        Pattern.compile("[A-Za-z0-9 -.]{1,512}");

    /**
     * Pattern for ID String.
     */
    private static final Pattern IDENT = Pattern.compile("[A-Fa-f0-9]{4}");

    /**
     * String representation of transaction.
     */
    private final String transaction;

    /**
     * Ctor.
     * @param trnsct String representation of transaction
     * @throws IOException If an I/O error occurs
     */
    RtTransaction(final String trnsct) throws IOException {
        this.transaction = trnsct;
        if (new TrimmedText(new TextOf(trnsct)).asString().isEmpty()) {
            throw new IOException(
                "Invalid transaction string: string is empty"
            );
        }
        final List<Text> pieces = new ListOf<>(new SplitText(trnsct, ";"));
        if (pieces.size() != 7) {
            throw new IOException(
                new FormattedText(
                    "Invalid transaction string: expected 7 fields, but found %d",
                    pieces.size()
                ).asString()
            );
        }
    }

    @Override
    public int id() throws IOException {
        final String ident = new SplitText(this.transaction, ";").get(0).asString();
        if (!RtTransaction.IDENT.matcher(ident).matches()) {
            throw new IOException(
                new FormattedText(
                    "Invalid ID '%s' expecting 16-bit unsigned hex string with 4 symbols",
                    ident
                ).asString()
            );
        }
        return Integer.parseUnsignedInt(ident, 16);
    }

    @Override
    public ZonedDateTime time() throws IOException {
        return new ZonedDateTimeOf(
            new SplitText(this.transaction, ";").get(1).asString(),
            DateTimeFormatter.ISO_OFFSET_DATE_TIME
        );
    }

    @Override
    public long amount() throws IOException {
        final String amnt = new SplitText(this.transaction, ";").get(2).asString();
        if (!RtTransaction.HEX.matcher(amnt).matches()) {
            throw new IOException(
                new FormattedText(
                    "Invalid amount '%s' expecting 64-bit signed hex string with 16 symbols",
                    amnt
                ).asString()
            );
        }
        return new BigInteger(amnt, 16).longValue();
    }

    @Override
    public String prefix() throws IOException {
        final String prefix = new SplitText(this.transaction, ";").get(3).asString();
        if (prefix.length() < 8 || prefix.length() > 32) {
            throw new IOException("Invalid prefix size");
        }
        if (!RtTransaction.PREFIX.matcher(prefix).matches()) {
            throw new IOException("Invalid base64 prefix");
        }
        return prefix;
    }

    @Override
    public String bnf() throws IOException {
        final String bnf = new SplitText(this.transaction, ";").get(4).asString();
        if (!RtTransaction.HEX.matcher(bnf).matches()) {
            throw new IOException(
                new FormattedText(
                    "Invalid bnf string '%s', expecting hex string with 16 symbols",
                    bnf
                ).asString()
            );
        }
        return bnf;
    }

    @Override
    public String details() throws IOException {
        final String dtls = new SplitText(this.transaction, ";").get(5).asString();
        if (!RtTransaction.DTLS.matcher(dtls).matches()) {
            throw new IOException(
                new FormattedText(
                    "Invalid details string '%s', does not match pattern '%s'",
                    dtls, RtTransaction.DTLS
                ).asString()
            );
        }
        return dtls;
    }

    @Override
    public String signature() throws IOException {
        final String sign = new SplitText(this.transaction, ";").get(6).asString();
        if (sign.length() != 684 || !RtTransaction.SIGN.matcher(sign).matches()) {
            throw new IOException(
                new FormattedText(
                    "Invalid signature '%s', expecting base64 string with 684 characters",
                    sign
                ).asString()
            );
        }
        return sign;
    }

    @Override
    public String toString() {
        return this.transaction;
    }

    @Override
    @SuppressWarnings("PMD.OnlyOneReturn")
    public boolean equals(final Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null || this.getClass() != obj.getClass()) {
            return false;
        }
        final RtTransaction that = (RtTransaction) obj;
        return this.transaction.equals(that.transaction);
    }

    @Override
    public int hashCode() {
        return this.transaction.hashCode();
    }
}
```

In this solution, I have removed the usage of `UncheckedScalar`, `IoCheckedScalar`, `StickyScalar`, and `LengthOf` as they are no longer available in the updated dependency. Instead, I have directly used the `SplitText` and `FormattedText` classes to achieve the same functionality. The `toString` method now directly returns the `transaction` string, and the `equals` and `hashCode` methods remain unchanged as they do not rely on the removed classes.
