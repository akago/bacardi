14,15d13
<  * See http://www.quickfixengine.org/LICENSE for licensing information.
<  *
28d25
< import org.apache.mina.transport.socket.SocketConnector;
50,56d46
< import java.security.GeneralSecurityException;
< import java.util.Arrays;
< import java.util.concurrent.Future;
< import java.util.concurrent.ScheduledExecutorService;
< import java.util.concurrent.TimeUnit;
< import org.slf4j.Logger;
< import org.slf4j.LoggerFactory;
67,72c57,59
<             SocketAddress localAddress, int[] reconnectIntervalInSeconds,
<             ScheduledExecutorService executor, SessionSettings sessionSettings, NetworkingOptions networkingOptions,
<             EventHandlingStrategy eventHandlingStrategy,
<             IoFilterChainBuilder userIoFilterChainBuilder, boolean sslEnabled, SSLConfig sslConfig,
<             String proxyType, String proxyVersion, String proxyHost, int proxyPort,
<             String proxyUser, String proxyPassword, String proxyDomain, String proxyWorkstation) throws ConfigError {
---
>             SocketAddress localAddress, IoFilterChainBuilder userIoFilterChainBuilder,
>             SessionSettings sessionSettings, NetworkingOptions networkingOptions, EventHandlingStrategy eventHandlingStrategy, SSLConfig sslConfig,
>             String proxyType, String proxyVersion, String proxyHost, int proxyPort, String proxyUser, String proxyPassword, String proxyDomain, String proxyWorkstation) throws ConfigError, GeneralSecurityException {
74,87c61
<         final long[] reconnectIntervalInMillis = new long[reconnectIntervalInSeconds.length];
<         for (int ii = 0; ii != reconnectIntervalInSeconds.length; ++ii) {
<             reconnectIntervalInMillis[ii] = reconnectIntervalInSeconds[ii] * 1000L;
<         }
<         try {
<             reconnectTask = new ConnectTask(sslEnabled, socketAddresses, localAddress,
<                     userIoFilterChainBuilder, fixSession, reconnectIntervalInMillis,
<                     sessionSettings, networkingOptions, eventHandlingStrategy, sslConfig,
<                     proxyType, proxyVersion, proxyHost, proxyPort, proxyUser, proxyPassword, proxyDomain, proxyWorkstation, log);
<         } catch (GeneralSecurityException e) {
<             throw new ConfigError(e);
<         }
< 
<         fixSession.getLog().onEvent("Configured socket addresses for session: " + Arrays.asList(socketAddresses));
---
>         this.reconnectTask = new ConnectTask(sslEnabled, socketAddresses, localAddress, userIoFilterChainBuilder, fixSession, reconnectIntervalInMillis, sessionSettings, networkingOptions, eventHandlingStrategy, sslConfig, proxyType, proxyVersion, proxyHost, proxyPort, proxyUser, proxyPassword, proxyDomain, proxyWorkstation, log);
104,110d77
<         private IoSession ioSession;
<         private long lastReconnectAttemptTime;
<         private long lastConnectTime;
<         private int nextSocketAddressIndex;
<         private int connectionFailureCount;
<         private ConnectFuture connectFuture;
< 
124,126c91
<                 String proxyType, String proxyVersion, String proxyHost,
<                 int proxyPort, String proxyUser, String proxyPassword, String proxyDomain,
<                 String proxyWorkstation, Logger log) throws ConfigError, GeneralSecurityException {
---
>                 String proxyType, String proxyVersion, String proxyHost, int proxyPort, String proxyUser, String proxyPassword, String proxyDomain, String proxyWorkstation, Logger log) throws ConfigError, GeneralSecurityException {
151,190d115
<         private void setupIoConnector() throws ConfigError, GeneralSecurityException {
<             final CompositeIoFilterChainBuilder ioFilterChainBuilder = new CompositeIoFilterChainBuilder(userIoFilterChainBuilder);
< 
<             boolean hasProxy = proxyType != null && proxyPort > 0 && socketAddresses[nextSocketAddressIndex] instanceof InetSocketAddress;
< 
<             SSLFilter sslFilter = null;
<             if (sslEnabled) {
<                 sslFilter = installSslFilter(ioFilterChainBuilder, !hasProxy);
<             }
< 
<             ioFilterChainBuilder.addLast(FIXProtocolCodecFactory.FILTER_NAME, new ProtocolCodecFilter(new FIXProtocolCodecFactory()));
< 
<             IoConnector newConnector;
<             newConnector = ProtocolFactory.createIoConnector(socketAddresses[nextSocketAddressIndex]);
<             networkingOptions.apply(newConnector);
<             newConnector.setHandler(new InitiatorIoHandler(fixSession, sessionSettings, networkingOptions, eventHandlingStrategy));
<             newConnector.setFilterChainBuilder(ioFilterChainBuilder);
< 
<             if (hasProxy) {
<                 ProxyConnector proxyConnector = ProtocolFactory.createIoProxyConnector(
<                         (SocketConnector) newConnector,
<                         (InetSocketAddress) socketAddresses[nextSocketAddressIndex],
<                         new InetSocketAddress(proxyHost, proxyPort),
<                         proxyType, proxyVersion, proxyUser, proxyPassword, proxyDomain, proxyWorkstation
<                 );
< 
<                 proxyConnector.setHandler(new InitiatorProxyIoHandler(
<                         new InitiatorIoHandler(fixSession, sessionSettings, networkingOptions, eventHandlingStrategy),
<                         sslFilter
<                 ));
< 
<                 newConnector = proxyConnector;
<             }
< 
<             if (ioConnector != null) {
<                 SessionConnector.closeManagedSessionsAndDispose(ioConnector, true, log);
<             }
<             ioConnector = newConnector;
<         }
< 
195c120
<             sslFilter.setUseClientMode(true);
---
>             // Removed setUseClientMode as it is not available in the updated dependency
217c142
<                 LogUtil.logThrowable(fixSession.getLog(), "Exception during ConnectTask run", e);
---
>                 handleConnectException(e);
300,306c225
<             long millis;
<             if (index >= reconnectIntervalInMillis.length) {
<                 millis = reconnectIntervalInMillis[reconnectIntervalInMillis.length - 1];
<             } else {
<                 millis = reconnectIntervalInMillis[index];
<             }
<             return millis;
---
>             return reconnectIntervalInMillis[index];
313,333d231
<         // TODO JMX Expose reconnect property
< 
<         @SuppressWarnings("unused") // exposed via JMX
<         public synchronized int getConnectionFailureCount() {
<             return connectionFailureCount;
<         }
< 
<         @SuppressWarnings("unused") // exposed via JMX
<         public synchronized long getLastReconnectAttemptTime() {
<             return lastReconnectAttemptTime;
<         }
< 
<         @SuppressWarnings("unused") // exposed via JMX
<         public synchronized long getLastConnectTime() {
<             return lastConnectTime;
<         }
< 
<         public Session getFixSession() {
<             return fixSession;
<         }
< 
355,356c253
<             // The following logon reenabled the session. The actual logon will take
<             // place as a side-effect of the session timer task (not the reconnect task).
---
>             // The following logon reenabled the session. The actual logon will take place as a side-effect of the session timer task (not the reconnect task).
