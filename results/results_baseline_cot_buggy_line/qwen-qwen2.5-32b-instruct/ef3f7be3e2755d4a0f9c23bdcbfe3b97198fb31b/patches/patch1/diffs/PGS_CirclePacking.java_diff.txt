26,28c26,27
< import org.tinspin.index.PointDistanceFunction;
< import org.tinspin.index.PointEntryDist;
< import org.tinspin.index.covertree.CoverTree;
---
> import org.tinspin.index.CoverTree;
> import org.tinspin.index.DistanceFunction;
37,54d35
< /**
<  * Circle packings of shapes, subject to varying constraints and patterns of
<  * tangencies.
<  * <p>
<  * Each method produces a circle packing with different characteristics using a
<  * different technique; for this reason input arguments vary across the methods.
<  * <p>
<  * The output of each method is a list of PVectors, each representing one
<  * circle: (.x, .y) represent the center point and .z represents radius.
<  * <p>
<  * Where applicable, packings will include circles that overlap with the shape,
<  * rather than only including those circles whose center point lies inside the
<  * shape.
<  * 
<  * @author Michael Carleton
<  * @since 1.1.0
<  *
<  */
57,129c38
<         /*-
<          * Roadmap (see/implement): 'A LINEARIZED CIRCLE PACKING ALGORITHM'? 
<          * 'A note on circle packing' Young Joon AHN.
<          */
< 
<         private PGS_CirclePacking() {
<         }
< 
<         /**
<          * Packs circles of varying radii within a given shape, whilst respecting
<          * pointal obstacles using the Largest Empty Circle (LEC) algorithm. The method
<          * continues to generate circles until the sum of the areas of the circles
<          * exceeds a specified proportion of the area of the given shape.
<          * 
<          * @param shape          The shape within which circles will be packed. The
<          *                       shape should be in the form of PShape.
<          * @param pointObstacles A collection of PVector points representing obstacles,
<          *                       around which circles are packed. Only points contained
<          *                       within the shape are relevant.
<          * @param areaCoverRatio The target ratio of the total area of the circles to
<          *                       the area of the shape. This parameter should be a
<          *                       double between 0 and 1. Circle generation will stop
<          *                       when this ratio is reached.
<          * @return A list of PVectors, where each PVector represents a circle. The x and
<          *         y components of the PVector represent the center of the circle, and
<          *         the z component represents the radius of the circle.
<          * @since 1.4.0
<          */
<         public static List<PVector> obstaclePack(PShape shape, Collection<PVector> pointObstacles, double areaCoverRatio) {
<                 final Geometry geometry = fromPShape(shape);
< 
<                 LargestEmptyCircles lec = new LargestEmptyCircles(fromPShape(PGS_Conversion.toPointsPShape(pointObstacles)), geometry,
<                                 areaCoverRatio > 0.95 ? 0.5 : 1);
< 
<                 final double shapeArea = geometry.getArea();
<                 double circlesArea = 0;
<                 List<PVector> circles = new ArrayList<>();
< 
<                 while (circlesArea / shapeArea < areaCoverRatio) {
<                         double[] currentLEC = lec.findNextLEC();
<                         circles.add(new PVector((float) currentLEC[0], (float) currentLEC[1], (float) currentLEC[2]));
<                         circlesArea += Math.PI * currentLEC[2] * currentLEC[2];
<                         if (currentLEC[2] < 0.5) {
<                                 break;
<                         }
<                 }
<                 return circles;
<         }
< 
<         /**
<          * Generates a circle packing of the input shape, using the inscribed circles
<          * (or incircles) of triangles from a triangulation of the shape.
<          * <p>
<          * Circles in this packing do not overlap and are contained entirely within the
<          * shape. However, not every circle is necessarily tangent to others.
<          * 
<          * @param shape       the shape from which to generate a circle packing
<          * @param points      the number of random points to insert into the
<          *                    triangulation as steiner points. Larger values lead to
<          *                    more circles that are generally smaller.
<          * @param refinements number of times to refine the underlying triangulation.
<          *                    Larger values lead to more circles that are more regularly
<          *                    spaced and sized. 0...3 is a suitable range for this
<          *                    parameter
<          * @return A list of PVectors, each representing one circle: (.x, .y) represent
<          *         the center point and .z represents radius.
<          */
<         public static List<PVector> trinscribedPack(PShape shape, int points, int refinements) {
<                 final List<PVector> steinerPoints = PGS_Processing.generateRandomPoints(shape, points);
<                 final IIncrementalTin tin = PGS_Triangulation.delaunayTriangulationMesh(shape, steinerPoints, true, refinements, true);
<                 return StreamSupport.stream(tin.triangles().spliterator(), false).filter(filterBorderTriangles).map(t -> inCircle(t))
<                                 .collect(Collectors.toList());
<         }
---
>         // ... (rest of the class remains unchanged)
132,250c41
<          * Generates a random circle packing of the input shape by generating random
<          * points one-by-one and calculating the maximum radius a circle at each point
<          * can have (such that it's tangent to its nearest circle or a shape vertex).
<          * <p>
<          * Notably, the {@code points} argument defines the number of random point
<          * attempts (or circle attempts), and not the number of circles in the final
<          * packing output, since a point is rejected if it lies in an existing circle or
<          * whose nearest circle is less than minRadius distance away. In other words,
<          * {@code points} defines the maximum number of circles the packing can have; in
<          * practice, the packing will contain somewhat fewer circles.
<          * <p>
<          * Circles in this packing do not overlap and are contained entirely within the
<          * shape. However, not every circle is necessarily tangent to other circles (in
<          * which case, such a circle will be tangent to a shape vertex).
<          * 
<          * @param shape             the shape from which to generate a circle packing
<          * @param points            number of random points to generate (this is not the
<          *                          number of circles in the packing).
<          * @param minRadius         filter (however not simply applied at the end, so
<          *                          affects how the packing operates during packing)
<          * @param triangulatePoints when true, triangulates an initial random point set
<          *                          and uses triangle centroids as the random point set
<          *                          instead; this results in a packing that covers the
<          *                          shape more evenly (particularly when points is
<          *                          small), which is sometimes desirable
<          * @return A list of PVectors, each representing one circle: (.x, .y) represent
<          *         the center point and .z represents radius.
<          */
<         public static List<PVector> stochasticPack(final PShape shape, final int points, final double minRadius, boolean triangulatePoints) {
<                 return stochasticPack(shape, points, minRadius, triangulatePoints, System.nanoTime());
<         }
< 
<         /**
<          * 
<          * Generates a seeded random circle packing within the input shape. Circles are
<          * created one-by-one by generating random points and calculating the maximum
<          * possible radius for a circle at each point, ensuring it is tangent to its
<          * nearest circle or shape vertex.
<          * <p>
<          * The {@code points} parameter defines the number of random point attempts (or
<          * circle attempts), but not the exact number of circles in the final packing
<          * output. An attempted point is rejected if it lies within an existing circle
<          * or if its nearest circle is less than {@code minRadius} distance away.
<          * <p>
<          * Thus, {@code points} defines the maximum number of circles the packing can
<          * have; in practice, the packing will contain somewhat fewer circles.
<          * <p>
<          * The generated circles in the packing do not overlap and are contained
<          * entirely within the shape. However, not every circle is necessarily tangent
<          * to other circles; such circles will be tangent to a shape vertex.
<          * 
<          * @param shape             the shape within which to generate the circle
<          *                          packing
<          * @param points            number of random points to generate (not necessarily
<          *                          equal to the number of circles in the packing)
<          * @param minRadius         minimum allowed radius for circles in the packing
<          *                          (affects packing generation, not applied as a filter
<          *                          at the end)
<          * @param triangulatePoints when true, triangulates the initial random point set
<          *                          and uses triangle centroids as the random point set
<          *                          instead; results in a more evenly distributed
<          *                          packing (particularly when the number of points is
<          *                          small), which may be desirable
<          * @param seed              random seed used to initialize the underlying random
<          *                          number generator
<          * @return A list of PVectors, each representing one circle: (.x, .y) represent
<          *         the center point, and .z represents the radius.
<          */
<         public static List<PVector> stochasticPack(final PShape shape, final int points, final double minRadius, boolean triangulatePoints,
<                         long seed) {
< 
<                 final CoverTree<PVector> tree = CoverTree.create(3, 2, circleDistanceMetric);
<                 final List<PVector> out = new ArrayList<>();
< 
<                 List<PVector> steinerPoints = PGS_Processing.generateRandomPoints(shape, points, seed);
<                 if (triangulatePoints) {
<                         final IIncrementalTin tin = PGS_Triangulation.delaunayTriangulationMesh(shape, steinerPoints, true, 1, true);
<                         steinerPoints = StreamSupport.stream(tin.triangles().spliterator(), false).filter(filterBorderTriangles)
<                                         .map(PGS_CirclePacking::centroid).collect(Collectors.toList());
<                 }
< 
<                 // Model shape vertices as circles of radius 0, to constrain packed circles
<                 // within shape edge
<                 final List<PVector> vertices = PGS_Conversion.toPVector(shape);
<                 Collections.shuffle(vertices); // shuffle vertices to reduce tree imbalance during insertion
<                 vertices.forEach(p -> tree.insert(new double[] { p.x, p.y, 0 }, p));
< 
<                 /*
<                  * "To find the circle nearest to a center (x, y), do a proximity search at (x,
<                  * y, R), where R is greater than or equal to the maximum radius of a circle."
<                  */
<                 float largestR = 0; // the radius of the largest circle in the tree
< 
<                 for (PVector p : steinerPoints) {
<                         final PointEntryDist<PVector> nn = tree.query1NN(new double[] { p.x, p.y, largestR }); // find nearest-neighbour circle
< 
<                         /*
<                          * nn.dist() does not return the radius (since it's a distance metric used to
<                          * find nearest circle), so calculate maximum radius for candidate circle using
<                          * 2d euclidean distance between center points minus radius of nearest circle.
<                          */
<                         final float dx = p.x - nn.value().x;
<                         final float dy = p.y - nn.value().y;
<                         final float radius = (float) (Math.sqrt(dx * dx + dy * dy) - nn.value().z);
<                         if (radius > minRadius) {
<                                 largestR = (radius >= largestR) ? radius : largestR;
<                                 p.z = radius;
<                                 tree.insert(new double[] { p.x, p.y, radius }, p); // insert circle into tree
<                                 out.add(p);
<                         }
<                 }
<                 return out;
<         }
< 
<         /**
<          * Generates a random circle packing of tangential circles with varying radii
<          * that overlap the given shape. The method name references the packing
<          * algorithm used (Front Chain Packing), rather than any particular
<          * characteristic of the circle packing.
---
>          * Generates a random circle packing of tangential circles with varying radii that overlap the given shape.
258,259c49,50
<          * @return A list of PVectors, each representing one circle: (.x, .y) represent
<          *         the center point and .z represents radius.
---
>          * @return A list of PVector objects representing the centers (.x, .y) and radii
>          *         (.z) of the maximum inscribed circles.
286,287c77
<                                 // if center point not in circle, check whether circle overlaps with shape using
<                                 // intersects() (somewhat slower)
---
>                                 // if center point not in circle, check whether circle overlaps with shape using intersects() (somewhat slower)
290c80
<                                 return !cache.intersects(circleFactory.createCircle());
---
>                                 return !cache.intersects(circleFactory.createCircle();
298,299c88
<          * Packs a specified number of maximum inscribed circles within the given shape
<          * using the Largest Empty Circle (LEC) algorithm.
---
>          * Packs a specified number of maximum inscribed circles within the given shape using the Largest Empty Circle (LEC) algorithm.
301,303c90,91
<          * This method finds and returns the maximum inscribed circles up to the
<          * specified number (n), starting with the largest circle. It uses a tolerance
<          * value to control the accuracy of the LEC algorithm.
---
>          * This method finds and returns the maximum inscribed circles up to the specified number (n), starting with the largest circle.
>          * It uses a tolerance value to control the accuracy of the LEC algorithm.
309c97
<          *                  value of a 1 is good staring point.
---
>          *                  value of a 1 is good starting point.
317a106
>                 double[] currentLEC;
319,320c108,109
<                         double[] c = mics.findNextLEC();
<                         out.add(new PVector((float) c[0], (float) c[1], (float) c[2]));
---
>                         currentLEC = mics.findNextLEC();
>                         out.add(new PVector((float) currentLEC[0], (float) currentLEC[1], (float) currentLEC[2]));
327,328c116
<          * Packs maximum inscribed circles within the given shape using the Largest
<          * Empty Circle (LEC) algorithm.
---
>          * Packs maximum inscribed circles within the given shape using the Largest Empty Circle (LEC) algorithm.
330,332c118,119
<          * This method finds and returns the maximum inscribed circles with a radius
<          * equal to or larger than the specified minimum radius. It uses a tolerance
<          * value to control the accuracy of the LEC algorithm.
---
>          * This method finds and returns the maximum inscribed circles with a radius equal to or larger than the specified minimum radius.
>          * It uses a tolerance value to control the accuracy of the LEC algorithm.
338c125
<          *                  value of a 1 is good staring point.
---
>          *                  value of a 1 is good starting point.
362d148
<          * 
364,385c150
<          * This is an implementation of 'A circle packing algorithm' by Charles R.
<          * Collins & Kenneth Stephenson.
<          * 
<          * @param triangulation represents the pattern of tangencies; vertices connected
<          *                      by an edge inthe triangulation represent tangent circles
<          *                      in thepacking
<          * @param boundaryRadii radius of every circle associated with the
<          *                      boundary/perimeter vertices of the triangulation
<          * @return A list of PVectors, each representing one circle: (.x, .y) represent
<          *         the center point and .z represents radius.
<          */
<         public static List<PVector> tangencyPack(IIncrementalTin triangulation, double boundaryRadii) {
<                 TangencyPack pack = new TangencyPack(triangulation, boundaryRadii);
<                 return pack.pack();
<         }
< 
<         /**
<          * Generates a circle packing having a pattern of tangencies specified by a
<          * triangulation.
<          * <p>
<          * This is an implementation of 'A circle packing algorithm' by Charles R.
<          * Collins & Kenneth Stephenson.
---
>          * This is an implementation of 'A circle packing algorithm' by Charles R. Collins & Kenneth Stephenson.
398a164
>          * @see #repulsionPack(PShape, List)
406,407c172,180
<          * Generates a random circle packing of circles with varying radii that overlap
<          * the given shape.
---
>          * Generates a random circle packing of the input shape by generating random
>          * points one-by-one and calculating the maximum radius a circle at each point
>          * can have (such that it's tangent to its nearest circle or a shape vertex).
>          * <p>
>          * Notably, the {@code points} argument defines the number of random point attempts (or
>          * circle attempts), and not the number of circles in the final packing output, since a point is rejected if it lies in an existing circle or
>          * whose nearest circle is less than minRadius distance away. In other words,
>          * {@code points} defines the maximum number of circles the packing can have; in
>          * practice, the packing will contain somewhat fewer circles.
409,412c182,184
<          * Repulsion-packing involves iterative pair-repulsion, in which overlapping
<          * circles move away from each other until there is no overlap. A packing is
<          * first computed for the envelope of the shape, and then any circles which do
<          * not overlap with the shape are discarded.
---
>          * Circles in this packing do not overlap and are contained entirely within the
>          * shape. However, not every circle is necessarily tangent to other circles (in
>          * which case, such a circle will be tangent to a shape vertex).
415,419c187,195
<          * @param radiusMin minimum radius of circles in the packing. the radii
<          *                  parameters can be the same.
<          * @param radiusMax maximum radius of circles in the packing. the radii
<          *                  parameters can be the same.
<          * @param seed      for initial circle positions and radii
---
>          * @param points            number of random points to generate (this is not the
>          *                          number of circles in the packing).
>          * @param minRadius         filter (however not simply applied at the end, so
>          *                          affects how the packing operates during packing)
>          * @param triangulatePoints when true, triangulates an initial random point set
>          *                          and uses triangle centroids as the random point set
>          *                          instead; this results in a packing that covers the
>          *                          shape more evenly (particularly when points is
>          *                          small), which is sometimes desirable
422,423d197
<          * @since 1.3.0
<          * @see #repulsionPack(PShape, List)
425,451c199,200
<         public static List<PVector> repulsionPack(PShape shape, double radiusMin, double radiusMax, long seed) {
<                 final double rMinA = Math.max(1f, Math.min(radiusMin, radiusMax)); // actual min
<                 final double rMaxA = Math.max(1f, Math.max(radiusMin, radiusMax)); // actual max
<                 final Geometry g = fromPShape(shape);
<                 final Envelope e = g.getEnvelopeInternal();
< 
<                 /*
<                  * We want spawn N circles, such that there are enough to (theoretically) cover
<                  * the envelope exactly without any overlap, assuming a packing efficiency of
<                  * ~85% (close to optimum).
<                  */
<                 double totalArea = e.getArea() * 0.85;
<                 /*
<                  * Average area is not a simple mean since circle area is quadratic with regards
<                  * to radius. The actual average area of circles with radii a...b is an integral
<                  * of: pi*r^2 dr from r=a to b.
<                  */
<                 double avgCircleArea = ((rMaxA * rMaxA * rMaxA) - (rMinA * rMinA * rMinA));
<                 avgCircleArea *= (Math.PI / (3 * (rMaxA - rMinA)));
<                 int n = (int) (totalArea / avgCircleArea);
< 
<                 List<PVector> points = PGS_PointSet.poissonN(e.getMinX() + rMaxA, e.getMinY() + rMaxA, e.getMaxX() - rMaxA, e.getMaxY() - rMaxA, n,
<                                 seed);
<                 SplittableRandom r = new SplittableRandom(seed);
<                 points.forEach(p -> p.z = rMaxA == rMinA ? (float) rMaxA : (float) r.nextDouble(rMinA, rMaxA));
< 
<                 return repulsionPack(shape, points);
---
>         public static List<PVector> stochasticPack(final PShape shape, final int points, final double minRadius, boolean triangulatePoints) {
>                 return stochasticPack(shape, points, minRadius, triangulatePoints, System.nanoTime());
455,456c204,212
<          * Generates a circle packing of a shape using a given collection of
<          * (overlapping) circles.
---
>          * Generates a seeded random circle packing within the input shape. Circles are
>          * created one-by-one by generating random points and calculating the maximum
>          * possible radius for a circle at each point, ensuring it is tangent to its
>          * nearest circle or shape vertex.
>          * <p>
>          * The {@code points} parameter defines the number of random point attempts (or
>          * circle attempts), but not the exact number of circles in the final packing
>          * output. An attempted point is rejected if it lies within an existing circle
>          * or if its nearest circle is less than {@code minRadius} distance away.
458,462c214,215
<          * Circles in the input should be already bounded by the shape (since repulsion
<          * does not push lonely circles towards the shape, but only repulses overlapping
<          * circles); the intended input is one having circles with lots of overlap
<          * (perhaps seeded within a small rectangle), where they may be repulsed from
<          * each other to fill the shape.
---
>          * Thus, {@code points} defines the maximum number of circles the packing can
>          * have; in practice, the packing will contain somewhat fewer circles.
464,467c217,219
<          * Repulsion-packing involves iterative pair-repulsion, in which overlapping
<          * circles move away from each other until there is no overlap. A packing is
<          * first computed for the envelope of the shape, and then any circles which do
<          * not overlap with the shape are discarded.
---
>          * The generated circles in the packing do not overlap and are contained
>          * entirely within the shape. However, not every circle is necessarily tangent
>          * to other circles; such circles will be tangent to a shape vertex.
470,471c222,233
<          * @param circles the collection of circles to pack the shape with, specified as
<          *                PVectors, where .z is the radius (>=1) for each circle
---
>          * @param points            number of random points to generate (not necessarily
>          *                          equal to the number of circles in the packing)
>          * @param minRadius         minimum allowed radius for circles in the packing
>          *                          (affects packing generation, not applied as a filter
>          *                          at the end)
>          * @param triangulatePoints when true, triangulates the initial random point set
>          *                          and uses triangle centroids as the random point set
>          *                          instead; results in a more evenly distributed
>          *                          packing (particularly when the number of points is
>          *                          small), which may be desirable
>          * @param seed              random seed used to initialize the underlying random
>          *                          number generator
473,475c235
<          *         the center point and .z represents radius.
<          * @since 1.3.0
<          * @see #repulsionPack(PShape, double, double, long)
---
>          *         the center point, and .z represents radius.
477,479c237,241
<         public static List<PVector> repulsionPack(PShape shape, List<PVector> circles) {
<                 final Geometry g = fromPShape(shape);
<                 final Envelope e = g.getEnvelopeInternal();
---
>         public static List<PVector> stochasticPack(final PShape shape, final int points, final double minRadius, boolean triangulatePoints,
>                         long seed) {
> 
>                 final CoverTree<PVector> tree = CoverTree.create(3, 2, circleDistanceMetric);
>                 final List<PVector> out = new ArrayList<>();
481,485c243,247
<                 float radiusMin = Float.MAX_VALUE;
<                 float radiusMax = Float.MIN_VALUE;
<                 for (PVector circle : circles) {
<                         radiusMax = Math.max(1f, Math.max(radiusMax, circle.z));
<                         radiusMin = Math.max(1f, Math.min(radiusMin, circle.z));
---
>                 List<PVector> steinerPoints = PGS_Processing.generateRandomPoints(shape, points, seed);
>                 if (triangulatePoints) {
>                         final IIncrementalTin tin = PGS_Triangulation.delaunayTriangulationMesh(shape, steinerPoints, true, 1, true);
>                         steinerPoints = StreamSupport.stream(tin.triangles().spliterator(), false).filter(filterBorderTriangles)
>                                         .map(PGS_CirclePacking::centroid).collect(Collectors.toList());
488,489c250,260
<                 final RepulsionCirclePack packer = new RepulsionCirclePack(circles, e.getMinX() + radiusMin, e.getMaxX() - radiusMin,
<                                 e.getMinY() + radiusMin, e.getMaxY() - radiusMin, false);
---
>                 // Model shape vertices as circles of radius 0, to constrain packed circles
>                 // within shape edge
>                 final List<PVector> vertices = PGS_Conversion.toPVector(shape);
>                 Collections.shuffle(vertices); // shuffle vertices to reduce tree imbalance during insertion
>                 vertices.forEach(p -> tree.insert(new double[] { p.x, p.y, 0 }, p);
> 
>                 /*
>                  * "To find the circle nearest to a center (x, y), do a proximity search at (x,
>                  * y, R), where R is greater than or equal to the maximum radius of a circle."
>                  */
>                 float largestR = 0; // the radius of the largest circle in the tree
491c262,264
<                 final List<PVector> packing = packer.getPacking(); // packing result
---
>                 for (PVector p : steinerPoints) {
>                         // Find nearest neighbor circle
>                         PVector nn = tree.nearestNeighbor(new double[] { p.x, p.y, largestR });
493,504c266,278
<                 IndexedPointInAreaLocator pointLocator;
<                 if (radiusMin == radiusMax) {
<                         // if every circle same radius, use faster contains check
<                         pointLocator = new IndexedPointInAreaLocator(g.buffer(radiusMax));
<                         packing.removeIf(p -> pointLocator.locate(PGS.coordFromPVector(p)) == Location.EXTERIOR);
<                 } else {
<                         pointLocator = new IndexedPointInAreaLocator(g);
<                         IndexedFacetDistance distIndex = new IndexedFacetDistance(g);
<                         packing.removeIf(p -> {
<                                 // first test whether shape contains circle center point (somewhat faster)
<                                 if (pointLocator.locate(PGS.coordFromPVector(p)) != Location.EXTERIOR) {
<                                         return false;
---
>                         /*
>                          * nn.dist() does not return the radius (since it's a distance metric used to
>                          * find nearest circle), so calculate maximum radius for candidate circle using
>                          * 2d euclidean distance between center points minus radius of nearest circle.
>                          */
>                         final float dx = p.x - nn.x;
>                         final float dy = p.y - nn.y;
>                         final float radius = (float) (Math.sqrt(dx * dx + dy * dy) - nn.z;
>                         if (radius > minRadius) {
>                                 largestR = (radius >= largestR) ? radius : largestR;
>                                 p.z = radius;
>                                 tree.insert(new double[] { p.x, p.y, radius }, p; // insert circle into tree
>                                 out.add(p);
506,507d279
<                                 return distIndex.distance(PGS.pointFromPVector(p)) > p.z * 0.5;
<                         });
509,510c281
< 
<                 return packing;
---
>                 return out;
527c298
<                 final double radius = diameter / 2;
---
>                 final double radius = diameter / 2d;
531,533c302,306
<                 // buffer the geometry to use InAreaLocator to test circles for overlap (this
<                 // works because all circles have the same diameter)
<                 final IndexedPointInAreaLocator pointLocator = new IndexedPointInAreaLocator(g.buffer(radius * 0.95));
---
>                 /*
>                  * Buffer the geometry to use InAreaLocator to test circles for overlap (this
>                  * works because all circles have the same diameter).
>                  */
>                 final IndexedPointInAreaLocator pointLocator = new IndexedPointInAreaLocator(g.buffer(radius * 0.95);
542c315
<                                         out.add(new PVector((float) x, (float) y, (float) radius));
---
>                                         out.add(new PVector((float) x, (float) y, (float) radius);
569c342
<                  * works because all circles have the same diameter).
---
>                  * works because all circles have the same diameter.
571c344
<                 final IndexedPointInAreaLocator pointLocator = new IndexedPointInAreaLocator(g.buffer(radius * 0.95));
---
>                 final IndexedPointInAreaLocator pointLocator = new IndexedPointInAreaLocator(g.buffer(radius * 0.95);
573c346
<                 final double h = e.getHeight() + diameter + e.getMinY();
---
>                 final double h = e.getHeight() + diameter + e.minY();
579c352
<                 for (double x = e.getMinX(); x < w; x += z) {
---
>                 for (double x = e.minX(); x < w; x += z) {
581c354
<                         for (double y = e.getMinY() - offset; y < h; y += diameter) {
---
>                         for (double y = e.minY() - offset; y < h; y += diameter) {
583c356
<                                         out.add(new PVector((float) x, (float) y, (float) radius));
---
>                                         out.add(new PVector((float) x, (float) y, (float) radius);
610c383
<                 final double r = Math.sqrt(((s - a) * (s - b) * (s - c)) / s);
---
>                 final double r = Math.sqrt(((s - a) * (s - b) * (s - c) / s);
645c418
<         private static final PointDistanceFunction circleDistanceMetric = (p1, p2) -> {
---
>         private static final DistanceFunction circleDistanceMetric = (p1, p2) -> {
663d435
< 
