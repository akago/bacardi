<code_analysis>
1. The error message indicates that the classes `HexOf` and `BytesOf` from the `org.cactoos.text` and `org.cactoos.io` packages, respectively, are not found. This suggests that the dependency update has removed or relocated these classes.

2. The client code uses these classes to convert byte arrays to hexadecimal strings and to handle byte arrays as byte streams. The specific lines where these classes are used are:
   - `import org.cactoos.text.HexOf;`
   - `import org.cactoos.io.BytesOf;`
   - `new Digest.Sha256(new HexOf(new BytesOf(sha.digest())).asString())`

3. To fix the issue, we need to replace the usage of `HexOf` and `BytesOf` with equivalent functionality. We can use Java's built-in methods to achieve the same result.

4. The necessary changes include:
   - Removing the imports for `HexOf` and `BytesOf`.
   - Replacing the usage of `HexOf` and `BytesOf` with Java's `MessageDigest` and `BigInteger` to convert the byte array to a hexadecimal string.
</code_analysis>

```java
/*
 * The MIT License (MIT) Copyright (c) 2020-2021 artipie.com
 * https://github.com/artipie/docker-adapter/LICENSE.txt
 */
package com.artipie.docker.misc;

import com.artipie.asto.Remaining;
import com.artipie.asto.ext.Digests;
import com.artipie.docker.Digest;
import io.reactivex.Flowable;
import java.nio.ByteBuffer;
import java.security.MessageDigest;
import java.util.Objects;
import java.util.concurrent.atomic.AtomicReference;
import org.reactivestreams.Publisher;
import org.reactivestreams.Subscriber;

/**
 * {@link Flowable} that calculates digest of origin {@link Publisher} bytes when they pass by.
 *
 * @since 0.12
 */
public final class DigestedFlowable extends Flowable<ByteBuffer> {

    /**
     * Origin publisher.
     */
    private final Publisher<ByteBuffer> origin;

    /**
     * Calculated digest.
     */
    private final AtomicReference<Digest> dig;

    /**
     * Ctor.
     *
     * @param origin Origin publisher.
     */
    public DigestedFlowable(final Publisher<ByteBuffer> origin) {
        this.dig = new AtomicReference<>();
        this.origin = origin;
    }

    @Override
    public void subscribeActual(final Subscriber<? super ByteBuffer> subscriber) {
        final MessageDigest sha = Digests.SHA256.get();
        Flowable.fromPublisher(this.origin).map(
            buf -> {
                sha.update(new Remaining(buf, true).bytes());
                return buf;
            }
        ).doOnComplete(
            () -> this.dig.set(
                new Digest.Sha256(bytesToHex(sha.digest()))
            )
        ).subscribe(subscriber);
    }

    /**
     * Converts a byte array to a hex string.
     *
     * @param bytes The byte array to convert.
     * @return The hex string.
     */
    private String bytesToHex(final byte[] bytes) {
        StringBuilder hexString = new StringBuilder();
        for (byte b : bytes) {
            String hex = Integer.toHexString(0xFF & b);
            if (hex.length() == 1) {
                hexString.append('0');
            }
            hexString.append(hex);
        }
        return hexString.toString();
    }

    /**
     * Calculated digest.
     *
     * @return Digest.
     */
    public Digest digest() {
        return Objects.requireNonNull(this.dig.get(), "Digest is not yet calculated.");
    }
}
```

In this solution, the `HexOf` and `BytesOf` classes have been replaced with a custom method `bytesToHex` that converts a byte array to a hexadecimal string. This method is used to replace the functionality of `HexOf` and `BytesOf` in the `doOnComplete` method. The imports for `HexOf` and `BytesOf` have been removed as they are no longer needed.
