1,16d0
< /*
<  * Copyright (C) 2007-2009 Jive Software. All rights reserved.
<  *
<  * Licensed under the Apache License, Version 2.0 (the "License");
<  * you may not use this file except in compliance with the License.
<  * You may obtain a copy of the License at
<  *
<  *     http://www.apache.org/licenses/LICENSE-2.0
<  *
<  * Unless required by applicable law or agreed to in writing, software
<  * distributed under the License is distributed on an "AS IS" BASIS,
<  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<  * See the License for the specific language governing permissions and
<  * limitations under the License.
<  */
< 
20a5
> import com.hazelcast.config.EvictionConfig;
22,27d6
< import com.hazelcast.config.MaxSizeConfig;
< import com.hazelcast.config.MemberAttributeConfig;
< import com.hazelcast.config.MemcacheProtocolConfig;
< import com.hazelcast.config.NetworkConfig;
< import com.hazelcast.config.RestApiConfig;
< import com.hazelcast.core.Cluster;
32c11
< import org.jivesoftware.openfire.XMPPServer;
---
> import org.jivesoftware.openfire.XMppServer;
55d33
< import java.text.MessageFormat;
77,79d54
<  *
<  * @author Tom Evans
<  * @author Gaston Dombiak
83,133d57
<     private static final SystemProperty<String> HAZELCAST_EXECUTOR_SERVICE_NAME = SystemProperty.Builder.ofType(String.class)
<         .setKey("hazelcast.executor.service.name")
<         .setDefaultValue("openfire::cluster::executor")
<         .setDynamic(false)
<         .setPlugin(HazelcastPlugin.PLUGIN_NAME)
<         .build();
<     private static final SystemProperty<Duration> MAX_CLUSTER_EXECUTION_TIME = SystemProperty.Builder.ofType(Duration.class)
<         .setKey("hazelcast.max.execution.seconds")
<         .setDefaultValue(Duration.ofSeconds(30))
<         .setChronoUnit(ChronoUnit.SECONDS)
<         .setDynamic(true)
<         .setPlugin(HazelcastPlugin.PLUGIN_NAME)
<         .build();
<     private static final SystemProperty<Duration> CLUSTER_STARTUP_RETRY_TIME = SystemProperty.Builder.ofType(Duration.class)
<         .setKey("hazelcast.startup.retry.seconds")
<         .setDefaultValue(Duration.ofSeconds(10))
<         .setChronoUnit(ChronoUnit.SECONDS)
<         .setDynamic(true)
<         .setPlugin(HazelcastPlugin.PLUGIN_NAME)
<         .build();
<     private static final SystemProperty<Integer> CLUSTER_STARTUP_RETRY_COUNT = SystemProperty.Builder.ofType(Integer.class)
<         .setKey("hazelcast.startup.retry.count")
<         .setDefaultValue(1)
<         .setDynamic(true)
<         .setPlugin(HazelcastPlugin.PLUGIN_NAME)
<         .build();
<     private static final SystemProperty<String> HAZELCAST_CONFIG_FILE = SystemProperty.Builder.ofType(String.class)
<         .setKey("hazelcast.config.xml.filename")
<         .setDefaultValue("hazelcast-cache-config.xml")
<         .setDynamic(false)
<         .setPlugin(HazelcastPlugin.PLUGIN_NAME)
<         .build();
<     private static final SystemProperty<Boolean> HAZELCAST_JMX_ENABLED = SystemProperty.Builder.ofType(Boolean.class)
<         .setKey("hazelcast.config.jmx.enabled")
<         .setDefaultValue(Boolean.FALSE)
<         .setDynamic(false)
<         .setPlugin(HazelcastPlugin.PLUGIN_NAME)
<         .build();
<     private static final SystemProperty<Boolean> HAZELCAST_REST_ENABLED = SystemProperty.Builder.ofType(Boolean.class)
<         .setKey("hazelcast.config.rest.enabled")
<         .setDefaultValue(Boolean.FALSE)
<         .setDynamic(false)
<         .setPlugin(HazelcastPlugin.PLUGIN_NAME)
<         .build();
<     private static final SystemProperty<Boolean> HAZELCAST_MEMCACHE_ENABLED = SystemProperty.Builder.ofType(Boolean.class)
<         .setKey("hazelcast.config.memcache.enabled")
<         .setDefaultValue(Boolean.FALSE)
<         .setDynamic(false)
<         .setPlugin(HazelcastPlugin.PLUGIN_NAME)
<         .build();
< 
149d72
<     private static Cluster cluster = null;
154,163d76
<     /**
<      * Keeps that running state. Initial state is stopped.
<      */
<     private State state = State.stopped;
< 
<     /**
<      * Used to limit the amount of duplicate warnings logged.
<      */
<     private final Cache<String, Instant> pluginClassLoaderWarnings;
< 
203d115
<                 cluster = hazelcast.getCluster();
206c118
<                 clusterListener = new ClusterListener(cluster);
---
>                 clusterListener = new ClusterListener(hazelcast);
209c121
<                 membershipListener = cluster.addMembershipListener(clusterListener);
---
>                 membershipListener = hazelcast.getCluster().addMembershipListener(clusterListener);
213d124
<                 cluster = null;
215,216c126
<                     logger.warn("Failed to start clustering (" + e.getMessage() + "); " +
<                         "will retry in " + StringUtils.getFullElapsedTime(CLUSTER_STARTUP_RETRY_TIME.getValue()));
---
>                     logger.warn("Failed to start clustering (" + e.getMessage() + "); will retry in " + StringUtils.getFullElapsedTime(CLUSTER_STARTUP_RETRY_TIME.getValue()));
233c143
<         return cluster != null;
---
>         return hazelcast != null;
248c158
<         cluster.removeMembershipListener(membershipListener);
---
>         hazelcast.getCluster().removeMembershipListener(membershipListener);
250c160
<         cluster = null;
---
>         hazelcast = null;
282c192
<         final int hazelcastMaxCacheSizeInMegaBytes = openfireMaxCacheSizeInBytes < 0 ? Integer.MAX_VALUE : Math.max((int) openfireMaxCacheSizeInBytes / 1024 / 1024, 1);
---
>         final int hazelcastMaxCacheSizeInMegaBytes = openfireMaxCacheSizeInBytes < 0 ? Integer.MAX_VALUE : Math.max((int) (openfireMaxCacheSizeInBytes / 1024 / 1024), 1);
288c198,200
<             dynamicConfig.setMaxSizeConfig(new MaxSizeConfig(hazelcastMaxCacheSizeInMegaBytes, MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE));
---
>             final EvictionConfig evictionConfig = new EvictionConfig();
>             evictionConfig.setSize(hazelcastMaxCacheSizeInMegaBytes);
>             dynamicConfig.setEvictionConfig(evictionConfig);
330,331c242,243
<         if (cluster != null && !cluster.getMembers().isEmpty()) {
<             final Member oldest = cluster.getMembers().iterator().next();
---
>         if (hazelcast != null && !hazelcast.getCluster().getMembers().isEmpty()) {
>             final Member oldest = hazelcast.getCluster().getMembers().iterator().next();
340,341c252,253
<         if (cluster != null) {
<             return getNodeID(cluster.getLocalMember()).toByteArray();
---
>         if (hazelcast != null) {
>             return getNodeID(hazelcast.getLocalMember()).toByteArray();
356c268
<         return cluster == null ? System.currentTimeMillis() : cluster.getClusterTime();
---
>         return hazelcast == null ? System.currentTimeMillis() : hazelcast.getCluster().getClusterTime();
367c279
<         if (cluster == null) {
---
>         if (hazelcast == null) {
371,372c283,284
<         final Member current = cluster.getLocalMember();
<         for (final Member member : cluster.getMembers()) {
---
>         final Member current = hazelcast.getLocalMember();
>         for (final Member member : hazelcast.getCluster().getMembers()) {
374c286
<                 members.add(member);
---
>                 member.add(member);
378,379c290
< 
<         if (!members.isEmpty()) {
---
>         if (!member.isEmpty()) {
380a292
>             try {
383c295,301
<             hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMembers(new CallableTask<>(task), members);
---
>                 final Map<Member, ? extends Future<?>> futures = hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMembers(new CallableTask<>(task), member);
>                 for (final Future<?> future : futures.values()) {
>                     future.get();
>                 }
>             } catch (final Exception e) {
>                 logger.error("Failed to execute cluster task", e);
>             }
396c314
<         if (cluster == null) {
---
>         if (hazelcast == null) {
414,454d331
<      * Execute the given task on the designated cluster members.
<      * Note that this method blocks for up to MAX_CLUSTER_EXECUTION_TIME
<      * (seconds) per member until the task is run on all members.
<      */
<     @Override
<     public <T> Collection<T> doSynchronousClusterTask(final ClusterTask<T> task, final boolean includeLocalMember) {
<         if (cluster == null) {
<             return Collections.emptyList();
<         }
<         final Set<Member> members = new HashSet<>();
<         final Member current = cluster.getLocalMember();
<         for (final Member member : cluster.getMembers()) {
<             if (includeLocalMember || (!member.getUuid().equals(current.getUuid()))) {
<                 members.add(member);
<             }
<         }
<         final Collection<T> result = new ArrayList<>();
<         if (!members.isEmpty()) {
<             // Asynchronously execute the task on the other cluster members
<             try {
<                 logger.debug("Executing MultiTask: " + task.getClass().getName());
<                 checkForPluginClassLoader(task);
<                 final Map<Member, ? extends Future<T>> futures = hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMembers(new CallableTask<>(task), members);
<                 long nanosLeft = TimeUnit.SECONDS.toNanos(MAX_CLUSTER_EXECUTION_TIME.getValue().getSeconds() * members.size());
<                 for (final Future<T> future : futures.values()) {
<                     final long start = System.nanoTime();
<                     result.add(future.get(nanosLeft, TimeUnit.NANOSECONDS));
<                     nanosLeft = nanosLeft - (System.nanoTime() - start);
<                 }
<             } catch (final TimeoutException te) {
<                 logger.error("Failed to execute cluster task within " + StringUtils.getFullElapsedTime(MAX_CLUSTER_EXECUTION_TIME.getValue()), te);
<             } catch (final Exception e) {
<                 logger.error("Failed to execute cluster task", e);
<             }
<         } else {
<             logger.debug("No cluster members selected for cluster task " + task.getClass().getName());
<         }
<         return result;
<     }
< 
<     /*
461c338
<         if (cluster == null) {
---
>         if (hazelcast == null) {
490c367
<         if (cluster == null) {
---
>         if (hazelcast == null) {
496c373
<             result = new HazelcastClusterNodeInfo(member, cluster.getClusterTime());
---
>             result = new HazelcastClusterNodeInfo(member, hazelcast.getCluster().getClusterTime());
503c380
<         for (final Member member : cluster.getMembers()) {
---
>         for (final Member member : hazelcast.getCluster().getMembers()) {
513c390
<         if (!caches.isEmpty() && cluster != null) {
---
>         if (!caches.isEmpty() && hazelcast != null) {
518c395
<             final String uid = getNodeID(cluster.getLocalMember()).toString();
---
>             final String uid = getNodeID(hazelcast.getLocalMember()).toString();
553,586d429
<     /**
<      * ClusterTasks that are executed should not be provided by a plugin. These will cause issues related to class
<      * loading when the providing plugin is reloaded. This method verifies if an instance of a task is
<      * loaded by a plugin class loader, and logs a warning to the log files when it is. The amount of warnings logged is
<      * limited by a time interval.
<      *
<      * @param o the instance for which to verify the class loader
<      * @see <a href="https://github.com/igniterealtime/openfire-hazelcast-plugin/issues/74">Issue #74: Warn against usage of plugin-provided classes in Hazelcast</a>
<      */
<     protected <T extends ClusterTask<?>> void checkForPluginClassLoader(final T o) {
<         if (o != null && o.getClass().getClassLoader() instanceof PluginClassLoader
<             && !pluginClassLoaderWarnings.containsKey(o.getClass().getName()) )
<         {
<             // Try to determine what plugin loaded the offending class.
<             String pluginName = null;
<             try {
<                 final Collection<Plugin> plugins = XMPPServer.getInstance().getPluginManager().getPlugins();
<                 for (final Plugin plugin : plugins) {
<                     final PluginClassLoader pluginClassloader = XMPPServer.getInstance().getPluginManager().getPluginClassloader(plugin);
<                     if (o.getClass().getClassLoader().equals(pluginClassloader)) {
<                         pluginName = XMPPServer.getInstance().getPluginManager().getCanonicalName(plugin);
<                         break;
<                     }
<                 }
<             } catch (Exception e) {
<                 logger.debug("An exception occurred while trying to determine the plugin class loader that loaded an instance of {}", o.getClass(), e);
<             }
<             logger.warn("An instance of {} that is executed as a cluster task. This will cause issues when reloading " +
<                     "the plugin that provides this class. The plugin implementation should be modified.",
<                 pluginName != null ? o.getClass() + " (provided by plugin " + pluginName + ")" : o.getClass());
<             pluginClassLoaderWarnings.put(o.getClass().getName(), Instant.now()); // Note that this Instant is unused.
<         }
<     }
< 
643c486
<                 logger.error("Unexpected exception running CallableTask[{}]", task.getClass().getName(), e);
---
>                 logger.error("Unexpected exception running CallableTask[{}]", task.getClass().name(), e);
656c499
<         return NodeID.getInstance(member.getStringAttribute(HazelcastClusterNodeInfo.NODE_ID_ATTRIBUTE).getBytes(StandardCharsets.UTF_8));
---
>         return NodeID.getInstance(member.getStringAttribute(HazelcastClusterNodeInfo.HOST_NAME_ATTRIBUTE).getBytes(StandardCharsets.UTF_8));
687c530
<             logger.debug("Firing leftCluster() event");
---
>             logger.debug("Firinging leftCluster() event");
691c534
<                 logger.warn("Timeout waiting for leftCluster() event to be called [timeout={}]", StringUtils.getFullElapsedTime(timeout));
---
>                 logger.warn("Timeout waiting for leftCluster() event to be called [timeout={}]", StringUtils.getFullElapsedTime(timeout);
699d541
< 
701,703d542
< 
< 
< 
