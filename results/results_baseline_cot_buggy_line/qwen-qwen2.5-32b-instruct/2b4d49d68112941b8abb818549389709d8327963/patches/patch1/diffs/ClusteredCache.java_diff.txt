1,15d0
< /*
<  * Copyright (C) 1999-2009 Jive Software. All rights reserved.
<  *
<  * Licensed under the Apache License, Version 2.0 (the "License");
<  * you may not use this file except in compliance with the License.
<  * You may obtain a copy of the License at
<  *
<  *     http://www.apache.org/licenses/LICENSE-2.0
<  *
<  * Unless required by applicable law or agreed to in writing, software
<  * distributed under the License is distributed on an "AS IS" BASIS,
<  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<  * See the License for the specific language governing permissions and
<  * limitations under the License.
<  */
21,22c6,8
< import com.hazelcast.core.MapEvent;
< import com.hazelcast.map.listener.MapListener;
---
> import com.hazelcast.core.HazelcastInstance;
> import com.hazelcast.core.HazelcastInstanceAware;
> import com.hazelcast.map.impl.MapService;
45,49c31
< /**
<  * Clustered implementation of the Cache interface using Hazelcast.
<  *
<  */
< public class ClusteredCache<K extends Serializable, V extends Serializable> implements Cache<K, V> {
---
> public class ClusteredCache<K extends Serializable, V extends Serializable> implements Cache<K, V>, HazelcastInstanceAware {
50a33
> {
60a44
>     private HazelcastInstance hazelcastInstance;
62,73d45
<     /**
<      * Used to limit the amount of duplicate warnings logged.
<      */
<     private Instant lastPluginClassLoaderWarning = Instant.EPOCH;
<     private final Duration pluginClassLoaderWarningSupression = Duration.ofHours(1);
< 
<     /**
<      * Create a new cache using the supplied named cache as the actual cache implementation
<      *
<      * @param name a name for the cache, which should be unique per vm.
<      * @param cache the cache implementation
<      */
80,83d51
<     void addEntryListener(final MapListener listener) {
<         listeners.add(map.addEntryListener(listener, false));
<     }
< 
85,86c53
<     public String addClusteredCacheEntryListener(@Nonnull final ClusteredCacheEntryListener<K, V> clusteredCacheEntryListener, final boolean includeValues, final boolean includeEventsFromLocalNode)
<     {
---
>     public String addClusteredCacheEntryListener(@Nonnull final ClusteredCacheEntryListener<K, V> clusteredCacheEntryListener, final boolean includeValues) {
89,108c56,57
<             public void mapEvicted(MapEvent event) {
<                 if (includeEventsFromLocalNode || !event.getMember().localMember()) {
<                     final NodeID eventNodeId = ClusteredCacheFactory.getNodeID(event.getMember());
<                     logger.trace("Processing map evicted event of node '{}'", eventNodeId);
<                     clusteredCacheEntryListener.mapEvicted(eventNodeId);
<                 }
<             }
< 
<             @Override
<             public void mapCleared(MapEvent event) {
<                 if (includeEventsFromLocalNode || !event.getMember().localMember()) {
<                     final NodeID eventNodeId = ClusteredCacheFactory.getNodeID(event.getMember());
<                     logger.trace("Processing map cleared event of node '{}'", eventNodeId);
<                     clusteredCacheEntryListener.mapCleared(eventNodeId);
<                 }
<             }
< 
<             @Override
<             public void entryUpdated(EntryEvent event) {
<                 if (includeEventsFromLocalNode || !event.getMember().localMember()) {
---
>             public void entryEvicted(EntryEvent<K, V> event) {
>                 if (includeValues || !event.getMember().localMember()) {
110,111c59,60
<                     logger.trace("Processing entry update event of node '{}' for key '{}'", eventNodeId, event.getKey());
<                     clusteredCacheEntryListener.entryUpdated((K) event.getKey(), (V) event.getOldValue(), (V) event.getValue(), eventNodeId);
---
>                     logger.trace("Processing entry evicted event of node '{}' for key '{}'", eventNodeId, event.getKey());
>                     clusteredCacheEntryListener.entryEvicted((K) event.getKey(), (V) event.getOldValue(), eventNodeId);
116,117c65,66
<             public void entryRemoved(EntryEvent event) {
<                 if (includeEventsFromLocalNode || !event.getMember().localMember()) {
---
>             public void entryRemoved(EntryEvent<K, V> event) {
>                 if (includeValues || !event.getMember().localMember()) {
125,126c74,75
<             public void entryEvicted(EntryEvent event) {
<                 if (includeEventsFromLocalNode || !event.getMember().localMember()) {
---
>             public void entryUpdated(EntryEvent<K, V> event) {
>                 if (includeValues || !event.getMember().localMember()) {
128,129c77,78
<                     logger.trace("Processing entry evicted event of node '{}' for key '{}'", eventNodeId, event.getKey());
<                     clusteredCacheEntryListener.entryEvicted((K) event.getKey(), (V) event.getOldValue(), eventNodeId);
---
>                     logger.trace("Processing entry update event of node '{}' for key '{}'", eventNodeId, event.getKey());
>                     clusteredCacheEntryListener.entryUpdated((K) event.getKey(), (V) event.getOldValue(), (V) event.getValue(), eventNodeId);
134,135c83,84
<             public void entryAdded(EntryEvent event) {
<                 if (includeEventsFromLocalNode || !event.getMember().localMember()) {
---
>             public void entryAdded(EntryEvent<K, V> event) {
>                 if (includeValues || !event.getMember().localMember()) {
145c94
<         logger.debug("Added new clustered cache entry listener (including values: {}, includeEventsFromLocalNode: {}) using ID: '{}'", includeValues, includeEventsFromLocalNode, listenerId);
---
>         logger.debug("Added new clustered cache entry listener (including values: {}, includeEventsFromLocalNode: {}) using ID: '{}'", includeValues, includeValues, listenerId);
192c141
<         final LocalMapStats stats = map.getLocalMapStats();
---
>         final LocalMapStats stats = hazelcastInstance.getMap(name).getLocalMapStats();
226c175
<         entries.entrySet().stream().findAny().ifPresent(
---
>         entries.entrySet().stream().findFirst().ifPresent(
257c206
<         final LocalMapStats stats = map.getLocalMapStats();
---
>         final LocalMapStats stats = hazelcastInstance.getMap(name).getLocalMapStats();
267,271d215
<     public void setMaxCacheSize(int i) {
<         setMaxCacheSize((long) i);
<     }
< 
<     @Override
308,324d251
<     void unlock(final K key) {
<         try {
<             map.unlock(key);
<         } catch (final IllegalMonitorStateException e) {
<             logger.error("Failed to release cluster lock", e);
<         }
<     }
< 
<     /**
<      * Clustered caches should not contain instances of classes that are provided by Openfire plugins. These will cause
<      * issues related to class loading when the providing plugin is reloaded. This method verifies if an instance is
<      * loaded by a plugin class loader, and logs a warning to the log files when it is. The amount of warnings logged is
<      * limited by a time interval.
<      *
<      * @param o the instance for which to verify the class loader
<      * @see <a href="https://github.com/igniterealtime/openfire-hazelcast-plugin/issues/74">Issue #74: Warn against usage of plugin-provided classes in Hazelcast</a>
<      */
327,328c254,255
<             && lastPluginClassLoaderWarning.isBefore(Instant.now().minus(pluginClassLoaderWarningSupression)) )
<         {
---
>             && lastPluginClassLoaderWarning.isBefore(Instant.now().minus(pluginClassLoaderWarningSupression))
>         ) {
348a276,280
> 
>     @Override
>     public void setHazelcastInstance(HazelcastInstance hazelcastInstance) {
>         this.hazelcastInstance = hazelcastInstance;
>     }
