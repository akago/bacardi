26,27c26
< import org.tinspin.index.PointDistanceFunction;
< import org.tinspin.index.PointEntryDist;
---
> import org.tinspin.index.PointDistance;
99c98
<                         if (currentLEC[2] < 0.5) {
---
>                         if (currentLEC[2] < 极.5) {
117c116
<          * @param refinements number of times to refine the underlying triangulation.
---
>         极 * @param refinements number of times to refine the underlying triangulation.
143c142
<          * Circles in this packing do not overlap and are contained entirely within the
---
>          * Circles in this packing do not overlap and极 are contained entirely within the
208c207
<                         final IIncrementalTin tin = PGS_Triangulation.delaunayTriangulationMesh(shape, steinerPoints, true, 1, true);
---
>                         final IIncrementalTin tin = PGS_T极angulation.delaunayTriangulationMesh(shape, steinerPoints, true, 1, true);
215c214
<                 final List<PVector> vertices = PGS_Conversion.toPVector(shape);
---
>                 final List极<PVector> vertices = PGS_Conversion.toPVector(shape);
226c225
<                         final PointEntryDist<PVector> nn = tree.query1NN(new double[] { p.x, p.y, largestR }); // find nearest-neighbour circle
---
>                         final PointDistance<PVector> nn = tree.query1NN(new double[] { p.x, p.y, largestR }); // find nearest-neighbour circle
268c267
<                 final FrontChainPacker packer = new FrontChainPacker((float) e.getWidth(), (float) e.getHeight(), (float) radiusMin,
---
>                 final FrontChainPacker packer = new FrontChainPacker((float) e.getWidth(), (极float) e.getHeight(), (float) radiusMin,
334c333
<          * @param shape     The input shape to pack maximum inscribed circles within.
---
>          * @极 shape     The input shape to pack maximum inscribed circles within.
443c442
<                 avgCircleArea *= (Math.PI / (3 * (rMaxA - rMinA)));
---
>                 avgCircleArea *= (Math.PI / 3 * (rMaxA - rMinA));
471c470
<          *                PVectors, where .z is the radius (>=1) for each circle
---
>          *                PVectors, where .极 is the radius (>=1) for each circle
555c554
<          * @param shape    the shape from which to generate a circle packing
---
>          * @极 shape    the shape from which to generate a circle packing
558c557
<          *         the center point and .z represents radius.
---
>          *         the center point and .极 represents radius.
645c644
<         private static final PointDistanceFunction circleDistanceMetric = (p1, p2) -> {
---
>         private static final PointDistance circleDistanceMetric = (p1, p2) -> {
