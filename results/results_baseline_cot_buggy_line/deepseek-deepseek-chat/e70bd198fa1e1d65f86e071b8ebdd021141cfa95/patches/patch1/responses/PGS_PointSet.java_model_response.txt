<code_analysis>
1. Examine the error message:
   - The error occurs in the `prunePointsWithinDistance` method at line 70.
   - The specific issue is that the `query1NN(double[])` method cannot be found on the `KDTree` object.
   - This suggests that the API of the `KDTree` class from the `org.tinspin.index.kdtree` package has changed in the newer version.

2. Review the client code:
   - The problematic line is using `tree.query1NN(coords).dist()` to find the nearest neighbor and get its distance.
   - The code is using a KDTree to store and query PVector points.
   - The KDTree is created with `KDTree.create(2)` indicating it's a 2-dimensional tree.

3. Consider potential fixes:
   - Need to find the equivalent method in the newer version of the KDTree API for nearest neighbor search.
   - The newer version likely has a different method name or approach for nearest neighbor queries.
   - Should maintain the same functionality of checking if a point is within a certain distance of existing points.

4. Plan the necessary changes:
   - Replace the `query1NN` call with the appropriate method from the newer KDTree API.
   - Ensure the distance calculation is still performed correctly.
   - Keep the same logic for adding points only if they're beyond the distance tolerance.
</code_analysis>

Here's the fixed class:

```java
package micycle.pgs;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.SplittableRandom;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import javax.vecmath.Point3d;
import javax.vecmath.Point4d;

import org.apache.commons.math3.ml.clustering.Clusterable;
import org.apache.commons.math3.ml.clustering.Clusterer;
import org.apache.commons.math3.ml.clustering.KMeansPlusPlusClusterer;
import org.apache.commons.math3.ml.distance.EuclideanDistance;
import org.apache.commons.math3.random.RandomGenerator;
import org.apache.commons.math3.util.FastMath;
import org.apache.commons.math3.util.Pair;

import org.jgrapht.alg.interfaces.SpanningTreeAlgorithm;
import org.jgrapht.alg.spanning.PrimMinimumSpanningTree;
import org.jgrapht.graph.SimpleGraph;
import org.tinfour.common.IIncrementalTin;
import org.tinspin.index.kdtree.KDTree;

import it.unimi.dsi.util.XoRoShiRo128PlusRandom;
import it.unimi.dsi.util.XoRoShiRo128PlusRandomGenerator;
import micycle.pgs.commons.GeometricMedian;
import micycle.pgs.commons.PEdge;
import micycle.pgs.commons.PoissonDistributionJRUS;
import processing.core.PShape;
import processing.core.PVector;

/**
 * Generation of random sets of 2D points having a variety of different
 * distributions and constraints (and associated functions).
 * 
 * @author Michael Carleton
 * @since 1.2.0
 *
 */
public final class PGS_PointSet {

    private static final float SQRT_3 = (float) Math.sqrt(3);
    /** Golden angle (in radians) */
    private static final float GOLDEN_ANGLE = (float) (Math.PI * (3 - Math.sqrt(5)));

    private PGS_PointSet() {
    }

    /**
     * Returns a filtered copy of the input, containing no points that are within
     * the <code>distanceTolerance</code> of each other.
     * <p>
     * This method can be used to convert a random point set into a blue-noise-like
     * (poisson) point set.
     * 
     * @param points            list of points to filter
     * @param distanceTolerance a point that is within this distance of a previously
     *                          included point is not included in the output
     * @return
     */
    public static List<PVector> prunePointsWithinDistance(List<PVector> points, double distanceTolerance) {
        final KDTree<PVector> tree = KDTree.create(2);
        final List<PVector> newPoints = new ArrayList<>();
        for (PVector p : points) {
            final double[] coords = new double[] { p.x, p.y };
            if (tree.size() == 0) {
                tree.insert(coords, p);
                newPoints.add(p);
            } else {
                KDTree.KnnQuery<PVector> query = tree.nearestNeighbor(coords, 1);
                if (query.hasNext()) {
                    KDTree.Entry<PVector> nearest = query.next();
                    double dist = Math.sqrt(Math.pow(nearest.point()[0] - coords[0], 2) + 
                                          Math.pow(nearest.point()[1] - coords[1], 2));
                    if (dist > distanceTolerance) {
                        tree.insert(coords, p);
                        newPoints.add(p);
                    }
                }
            }
        }
        return newPoints;
    }

    // ... (rest of the class remains unchanged)
}
```

The main changes are in the `prunePointsWithinDistance` method:
1. Replaced `query1NN(coords).dist()` with the newer API's `nearestNeighbor` method
2. Added manual distance calculation using Euclidean distance formula
3. Maintained the same logic for adding points only if they're beyond the distance tolerance
4. Added a check for the first point insertion when the tree is empty

The rest of the class remains unchanged as it wasn't affected by the KDTree API changes. The fix maintains the original functionality while adapting to the newer KDTree API.
