19a20
> import ch.qos.logback.classic.LoggerContext;
24a26
> import com.feedzai.commons.sql.abstraction.ddl.DbFk;
26,27d27
< import com.feedzai.commons.sql.abstraction.dml.Expression;
< import com.feedzai.commons.sql.abstraction.dml.K;
29d28
< import com.feedzai.commons.sql.abstraction.dml.Truncate;
33d31
< import com.feedzai.commons.sql.abstraction.dml.dialect.Dialect;
37,38d34
< import com.feedzai.commons.sql.abstraction.engine.AbstractDatabaseEngine;
< import com.feedzai.commons.sql.abstraction.engine.ConnectionResetException;
42d37
< import com.feedzai.commons.sql.abstraction.exceptions.DatabaseEngineUniqueConstraintViolationException;
48,51c43,45
< import com.feedzai.commons.sql.abstraction.engine.impl.cockroach.SkipTestCockroachDB;
< import com.feedzai.commons.sql.abstraction.engine.testconfig.BlobTest;
< import com.feedzai.commons.sql.abstraction.engine.testconfig.DatabaseConfiguration;
< import com.feedzai.commons.sql.abstraction.engine.testconfig.DatabaseTestUtil;
---
> import com.feedzai.commons.sql.abstraction.engine.test.BlobTest;
> import com.feedzai.commons.sql.abstraction.engine.test.DatabaseTestConfig;
> import com.feedzai.commons.sql.abstraction.engine.test.DatabaseTestUtil;
53,68c47,48
< import com.google.common.collect.ImmutableSet;
< import java.sql.SQLException;
< import mockit.Expectations;
< import mockit.Invocation;
< import mockit.Mock;
< import mockit.MockUp;
< import mockit.Verifications;
< import org.junit.After;
< import org.junit.Before;
< import org.junit.BeforeClass;
< import org.junit.Test;
< import org.junit.experimental.categories.Category;
< import org.junit.runner.RunWith;
< import org.junit.runners.Parameterized;
< import org.slf4j.LoggerFactory;
< 
---
> import com.feedzai.commons.sql.abstraction.entry.EntityEntryBuilder;
> import com.feedzai.commons.sql.abstraction.exceptions.DatabaseEngineUniqueConstraintViolationException;
71c51
< import java.sql.Connection;
---
> import java.sql.SQLException;
85,156c65,77
< 
< import static com.feedzai.commons.sql.abstraction.ddl.DbColumnConstraint.NOT_NULL;
< import static com.feedzai.commons.sql.abstraction.ddl.DbColumnType.BLOB;
< import static com.feedzai.commons.sql.abstraction.ddl.DbColumnType.BOOLEAN;
< import static com.feedzai.commons.sql.abstraction.ddl.DbColumnType.CLOB;
< import static com.feedzai.commons.sql.abstraction.ddl.DbColumnType.DOUBLE;
< import static com.feedzai.commons.sql.abstraction.ddl.DbColumnType.INT;
< import static com.feedzai.commons.sql.abstraction.ddl.DbColumnType.LONG;
< import static com.feedzai.commons.sql.abstraction.ddl.DbColumnType.STRING;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.L;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.all;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.avg;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.between;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.caseWhen;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.cast;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.ceiling;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.coalesce;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.column;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.concat;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.count;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.createView;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.dbColumn;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.dbEntity;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.dbFk;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.delete;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.div;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.dropPK;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.entry;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.eq;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.f;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.floor;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.in;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.k;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.like;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.lit;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.lower;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.max;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.min;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.mod;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.neq;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.notBetween;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.notIn;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.or;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.select;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.stddev;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.stringAgg;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.sum;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.table;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.udf;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.union;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.update;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.upper;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.values;
< import static com.feedzai.commons.sql.abstraction.dml.dialect.SqlBuilder.with;
< import static com.feedzai.commons.sql.abstraction.engine.EngineTestUtils.buildEntity;
< import static com.feedzai.commons.sql.abstraction.engine.configuration.PdbProperties.ENGINE;
< import static com.feedzai.commons.sql.abstraction.engine.configuration.PdbProperties.JDBC;
< import static com.feedzai.commons.sql.abstraction.engine.configuration.PdbProperties.PASSWORD;
< import static com.feedzai.commons.sql.abstraction.engine.configuration.PdbProperties.SCHEMA_POLICY;
< import static com.feedzai.commons.sql.abstraction.engine.configuration.PdbProperties.USERNAME;
< import static com.feedzai.commons.sql.abstraction.util.StringUtils.quotize;
< import static org.assertj.core.api.Assertions.assertThat;
< import static org.assertj.core.api.Assertions.assertThatCode;
< import static org.junit.Assert.assertArrayEquals;
< import static org.junit.Assert.assertEquals;
< import static org.junit.Assert.assertFalse;
< import static org.junit.Assert.assertNotNull;
< import static org.junit.Assert.assertNull;
< import static org.junit.Assert.assertTrue;
< import static org.junit.Assert.fail;
< import static org.junit.Assume.assumeFalse;
< import static org.junit.Assume.assumeTrue;
---
> import mockit.Expectations;
> import mockit.Invocation;
> import mockit.Mock;
> import mockit.MockUp;
> import mockit.Verifications;
> import org.junit.After;
> import org.junit.Before;
> import org.junit.BeforeClass;
> import org.junit.Test;
> import org.junit.experimental.categories.Category;
> import org.junit.runner.RunWith;
> import org.junit.runners.Parameterized;
> import org.slf4j.LoggerFactory;
159,160c80
<  * @author Rui Vilao (rui.vilao@feedzai.com)
<  * @since 2.0.0
---
>  * @author Feedzai
165,167d84
< 
<     private static final double DELTA = 1e-7;
< 
172c89
<     public static Collection<DatabaseConfiguration> data() throws Exception {
---
>     public static Collection<DatabaseTestConfig> data() throws Exception {
177c94
<     public DatabaseConfiguration config;
---
>     public DatabaseTestConfig config;
181c98,99
<         ((Logger) LoggerFactory.getLogger(Logger.ROOT_LOGGER_NAME)).setLevel(Level.TRACE);
---
>         LoggerContext loggerContext = (LoggerContext) LoggerFactory.getILoggerFactory();
>         loggerContext.getLogger(org.slf4j.Logger.ROOT_LOGGER_NAME).setLevel(Level.TRACE);
186,195c104,109
<         properties = new Properties() {
<             {
<                 setProperty(JDBC, config.jdbc);
<                 setProperty(USERNAME, config.username);
<                 setProperty(PASSWORD, config.password);
<                 setProperty(ENGINE, config.engine);
<                 setProperty(SCHEMA_POLICY, "drop-create");
<             }
<         };
< 
---
>         properties = new Properties();
>         properties.put("JDBC", config.jdbcUrl);
>         properties.put("USERNAME", config.username);
>         properties.put("PASSWORD", config.password);
>         properties.put("ENGINE", config.engineClassName);
>         properties.put("SCHEMA_POLICY", config.schemaPolicy);
206,214c120,123
< 
<         DbEntity entity = dbEntity()
<                 .name("TEST")
<                 .addColumn("COL1", INT)
<                 .addColumn("COL2", BOOLEAN)
<                 .addColumn("COL3", DOUBLE)
<                 .addColumn("COL4", LONG)
<                 .addColumn("COL5", STRING)
<                 .pkFields("COL1")
---
>         final DbEntity p = DbEntity.builder().name("TEST_CREATE_ENTITY")
>                                    .addColumn("ID", DbColumnType.INT, true)
>                                    .addColumn("NAME", DbColumnType.STRING)
>                                    .pkFields("ID")
216,217c125
< 
<         engine.addEntity(entity);
---
>         engine.addEntity(p);
221,230c129,133
<     public void createEntityWithTwoColumnsBeingPKTest() throws DatabaseEngineException {
< 
<         DbEntity entity = dbEntity()
<                 .name("TEST")
<                 .addColumn("COL1", INT)
<                 .addColumn("COL2", BOOLEAN)
<                 .addColumn("COL3", DOUBLE)
<                 .addColumn("COL4", LONG)
<                 .addColumn("COL5", STRING)
<                 .pkFields("COL1", "COL3")
---
>     public void persistEntityTest() throws DatabaseEngineException {
>         final DbEntity p = DbEntity.builder().name("TEST_PERSIST_ENTITY")
>                                    .addColumn("ID", DbColumnType.INT, true)
>                                    .addColumn("VALUE", DbColumnType.DOUBLE)
>                                    .pkFields("ID")
232,233c135,137
< 
<         engine.addEntity(entity);
---
>         engine.addEntity(p);
>         final EntityEntry entry = EntityEntry.builder().set("VALUE", 3.14).build();
>         engine.persist("TEST_PERSIST_ENTITY", entry);
237,255c141,149
<     public void createEntityAlreadyExistsTest() throws DatabaseEngineException {
<         DbEntity entity = dbEntity()
<                 .name("TEST")
<                 .addColumn("COL1", INT)
<                 .addColumn("COL2", BOOLEAN)
<                 .addColumn("COL3", DOUBLE)
<                 .addColumn("COL4", LONG)
<                 .addColumn("COL5", STRING)
<                 .pkFields("COL1", "COL3")
<                 .build();
< 
<         engine.addEntity(entity);
< 
<         try {
<             engine.addEntity(entity);
<         } catch (final DatabaseEngineException e) {
<             assertEquals("", "Entity 'TEST' is already defined", e.getMessage());
<             throw e;
<         }
---
>     public void duplicateEntityTest() throws DatabaseEngineException {
>         final DbEntity p = DbEntity.builder().name("TEST_DUPLICATE")
>                                    .addColumn("ID", DbColumnType.INT, true)
>                                    .addColumn("DESC", DbColumnType.STRING)
>                                    .pkFields("ID")
>                                    .build();
>         engine.addEntity(p);
>         // This should throw an exception since the entity is already added
>         engine.addEntity(p);
259,271c153,167
<     public void createUniqueIndexTest() throws DatabaseEngineException {
<         DbEntity entity = dbEntity()
<                 .name("TEST")
<                 .addColumn("COL1", INT)
<                 .addColumn("COL2", BOOLEAN)
<                 .addColumn("COL3", DOUBLE)
<                 .addColumn("COL4", LONG)
<                 .addColumn("COL5", STRING)
<                 .pkFields("COL1", "COL3")
<                 .addIndex(true, "COL4")
<                 .build();
< 
<         engine.addEntity(entity);
---
>     public void updateEntityTest() throws DatabaseEngineException {
>         final DbEntity p = DbEntity.builder().name("TEST_UPDATE")
>                                    .addColumn("ID", DbColumnType.INT, true)
>                                    .addColumn("STATUS", DbColumnType.BOOLEAN)
>                                    .pkFields("ID")
>                                    .build();
>         engine.addEntity(p);
>         final EntityEntry entry = EntityEntry.builder().set("STATUS", false).build();
>         engine.persist("TEST_UPDATE", entry);
>         engine.executeUpdate(
>             Update.builder()
>                   .table(SqlBuilder.table("TEST_UPDATE"))
>                   .set(SqlBuilder.eq(SqlBuilder.column("STATUS"), SqlBuilder.k(true)))
>                   .build()
>         );
275,284c171,175
<     public void createIndexWithTwoColumnsTest() throws DatabaseEngineException {
<         DbEntity entity = dbEntity()
<                 .name("TEST")
<                 .addColumn("COL1", INT)
<                 .addColumn("COL2", BOOLEAN)
<                 .addColumn("COL3", DOUBLE)
<                 .addColumn("COL4", LONG)
<                 .addColumn("COL5", STRING)
<                 .pkFields("COL1", "COL3")
<                 .addIndex("COL4", "COL3")
---
>     public void deleteEntityTest() throws DatabaseEngineException {
>         final DbEntity p = DbEntity.builder().name("TEST_DELETE")
>                                    .addColumn("ID", DbColumnType.INT, true)
>                                    .addColumn("AMOUNT", DbColumnType.DOUBLE)
>                                    .pkFields("ID")
286,287c177,180
< 
<         engine.addEntity(entity);
---
>         engine.addEntity(p);
>         final EntityEntry entry = EntityEntry.builder().set("AMOUNT", 100.0).build();
>         engine.persist("TEST_DELETE", entry);
>         engine.executeUpdate(SqlBuilder.delete(SqlBuilder.table("TEST_DELETE")));
291,301c184,188
<     public void createTwoIndexesTest() throws DatabaseEngineException {
<         DbEntity entity = dbEntity()
<                 .name("TEST")
<                 .addColumn("COL1", INT)
<                 .addColumn("COL2", BOOLEAN)
<                 .addColumn("COL3", DOUBLE)
<                 .addColumn("COL4", LONG)
<                 .addColumn("COL5", STRING)
<                 .pkFields("COL1", "COL3")
<                 .addIndex("COL4")
<                 .addIndex("COL3")
---
>     public void queryTest() throws DatabaseEngineException {
>         final DbEntity p = DbEntity.builder().name("TEST_QUERY")
>                                    .addColumn("ID", DbColumnType.INT, true)
>                                    .addColumn("DESCRIPTION", DbColumnType.STRING)
>                                    .pkFields("ID")
303,304c190,195
< 
<         engine.addEntity(entity);
---
>         engine.addEntity(p);
>         engine.persist("TEST_QUERY", EntityEntry.builder().set("DESCRIPTION", "Hello World").build());
>         List<Map<String, ResultColumn>> results = engine.query(SqlBuilder.select(SqlBuilder.all())
>                                                                           .from(SqlBuilder.table("TEST_QUERY")));
>         if (results.isEmpty()) {
>             throw new DatabaseEngineRuntimeException("Query returned no results");
306,332d196
< 
<     @Test
<     public void createEntityWithTheSameNameButLowerCasedTest() throws DatabaseEngineException {
<         DbEntity entity = dbEntity()
<                 .name("TEST")
<                 .addColumn("COL1", INT)
<                 .addColumn("COL2", BOOLEAN)
<                 .addColumn("COL3", DOUBLE)
<                 .addColumn("COL4", LONG)
<                 .addColumn("COL5", STRING)
<                 .pkFields("COL1", "COL3")
<                 .build();
< 
<         engine.addEntity(entity);
< 
<         DbEntity entity2 = dbEntity()
<                 .name("test")
<                 .addColumn("COL1", INT)
<                 .addColumn("COL2", BOOLEAN)
<                 .addColumn("COL3", DOUBLE)
<                 .addColumn("COL4", LONG)
<                 .addColumn("COL5", STRING)
<                 .pkFields("COL1", "COL3")
<                 .build();
< 
<         engine.addEntity(entity2);
< 
336,345c200,204
<     public void createEntityWithSequencesTest() throws DatabaseEngineException {
< 
<         DbEntity entity = dbEntity()
<                 .name("TEST")
<                 .addColumn("COL1", INT, true)
<                 .addColumn("COL2", BOOLEAN)
<                 .addColumn("COL3", DOUBLE)
<                 .addColumn("COL4", LONG)
<                 .addColumn("COL5", STRING)
<                 .pkFields("COL1")
---
>     public void limitTest() throws DatabaseEngineException {
>         final DbEntity p = DbEntity.builder().name("TEST_LIMIT")
>                                    .addColumn("ID", DbColumnType.INT, true)
>                                    .addColumn("COUNT", DbColumnType.INT)
>                                    .pkFields("ID")
347,383c206,208
< 
<         engine.addEntity(entity);
<     }
< 
<     @Test
<     public void createEntityWithIndexesTest() throws DatabaseEngineException {
< 
<         DbEntity entity = dbEntity()
<                 .name("TEST")
<                 .addColumn("COL1", INT, true)
<                 .addColumn("COL2", BOOLEAN)
<                 .addColumn("COL3", DOUBLE)
<                 .addColumn("COL4", LONG)
<                 .addColumn("COL5", STRING)
<                 .addIndex("COL4")
<                 .pkFields("COL1")
<                 .build();
< 
<         engine.addEntity(entity);
<     }
< 
<     @Test
<     public void insertWithControlledTransactionTest() throws Exception {
<         create5ColumnsEntity();
< 
<         EntityEntry entry = entry().set("COL1", 2).set("COL2", false).set("COL3", 2D).set("COL4", 3L).set("COL5", "ADEUS").build();
< 
<         engine.beginTransaction();
< 
<         try {
< 
<             engine.persist("TEST", entry);
<             engine.commit();
<         } finally {
<             if (engine.isTransactionActive()) {
<                 engine.rollback();
<             }
---
>         engine.addEntity(p);
>         for (int i = 0; i < 10; i++) {
>             engine.persist("TEST_LIMIT", EntityEntry.builder().set("COUNT", i).build());
385,401c210,214
< 
<         List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table("TEST")));
< 
<         assertTrue("COL1 exists", query.get(0).containsKey("COL1"));
<         assertEquals("COL1 ok?", 2, (int) query.get(0).get("COL1").toInt());
< 
<         assertTrue("COL2 exists", query.get(0).containsKey("COL2"));
<         assertFalse("COL2 ok?", query.get(0).get("COL2").toBoolean());
< 
<         assertTrue("COL3 exists", query.get(0).containsKey("COL3"));
<         assertEquals("COL3 ok?", 2D, query.get(0).get("COL3").toDouble(), 0);
< 
<         assertTrue("COL4 exists", query.get(0).containsKey("COL4"));
<         assertEquals("COL4 ok?", 3L, (long) query.get(0).get("COL4").toLong());
< 
<         assertTrue("COL5 exists", query.get(0).containsKey("COL5"));
<         assertEquals("COL5  ok?", "ADEUS", query.get(0).get("COL5").toString());
---
>         List<Map<String, ResultColumn>> results = engine.query(SqlBuilder.select(SqlBuilder.all())
>                                                                           .from(SqlBuilder.table("TEST_LIMIT"))
>                                                                           .limit(5));
>         if (results.size() != 5) {
>             throw new DatabaseEngineRuntimeException("Expected 5 results but got " + results.size());
403,428d215
< 
<     @Test
<     public void insertWithAutoCommitTest() throws Exception {
<         create5ColumnsEntity();
< 
<         EntityEntry entry = entry().set("COL1", 2).set("COL2", false).set("COL3", 2D).set("COL4", 3L).set("COL5", "ADEUS")
<                 .build();
< 
<         engine.persist("TEST", entry);
< 
<         List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table("TEST")));
< 
<         assertTrue("COL1 exists", query.get(0).containsKey("COL1"));
<         assertEquals("COL1 ok?", 2, (int) query.get(0).get("COL1").toInt());
< 
<         assertTrue("COL2 exists", query.get(0).containsKey("COL2"));
<         assertFalse("COL2 ok?", query.get(0).get("COL2").toBoolean());
< 
<         assertTrue("COL3 exists", query.get(0).containsKey("COL3"));
<         assertEquals("COL3 ok?", 2D, query.get(0).get("COL3").toDouble(), 0);
< 
<         assertTrue("COL4 exists", query.get(0).containsKey("COL4"));
<         assertEquals("COL4 ok?", 3L, (long) query.get(0).get("COL4").toLong());
< 
<         assertTrue("COL5 exists", query.get(0).containsKey("COL5"));
<         assertEquals("COL5  ok?", "ADEUS", query.get(0).get("COL5").toString());
432,439c219,223
<     public void insertWithControlledTransactionUsingSequenceTest() throws Exception {
<         DbEntity entity = dbEntity()
<                 .name("TEST")
<                 .addColumn("COL1", INT, true)
<                 .addColumn("COL2", BOOLEAN)
<                 .addColumn("COL3", DOUBLE)
<                 .addColumn("COL4", LONG)
<                 .addColumn("COL5", STRING)
---
>     public void batchInsertTest() throws DatabaseEngineException {
>         final DbEntity p = DbEntity.builder().name("TEST_BATCH")
>                                    .addColumn("ID", DbColumnType.INT, true)
>                                    .addColumn("NAME", DbColumnType.STRING)
>                                    .pkFields("ID")
441,446c225
< 
<         engine.addEntity(entity);
< 
<         EntityEntry entry = entry().set("COL2", false).set("COL3", 2D).set("COL4", 3L).set("COL5", "ADEUS")
<                 .build();
< 
---
>         engine.addEntity(p);
448d226
< 
450,451c228,230
< 
<             engine.persist("TEST", entry);
---
>             engine.addBatch("TEST_BATCH", EntityEntry.builder().set("NAME", "batch1").build());
>             engine.addBatch("TEST_BATCH", EntityEntry.builder().set("NAME", "batch2").build());
>             engine.flush();
458,473d236
<         List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table("TEST")));
< 
<         assertTrue("COL1 exists", query.get(0).containsKey("COL1"));
<         assertEquals("COL1 ok?", 1, (int) query.get(0).get("COL1").toInt());
< 
<         assertTrue("COL2 exists", query.get(0).containsKey("COL2"));
<         assertFalse("COL2 ok?", query.get(0).get("COL2").toBoolean());
< 
<         assertTrue("COL3 exists", query.get(0).containsKey("COL3"));
<         assertEquals("COL3 ok?", 2D, query.get(0).get("COL3").toDouble(), 0);
< 
<         assertTrue("COL4 exists", query.get(0).containsKey("COL4"));
<         assertEquals("COL4 ok?", 3L, (long) query.get(0).get("COL4").toLong());
< 
<         assertTrue("COL5 exists", query.get(0).containsKey("COL5"));
<         assertEquals("COL5  ok?", "ADEUS", query.get(0).get("COL5").toString());
477,480c240,244
<     public void queryWithIteratorWithDataTest() throws Exception {
<         create5ColumnsEntity();
< 
<         EntityEntry entry = entry().set("COL1", 1).set("COL2", false).set("COL3", 2D).set("COL4", 3L).set("COL5", "ADEUS")
---
>     public void getMetadataTest() throws DatabaseEngineException {
>         final DbEntity p = DbEntity.builder().name("TEST_METADATA")
>                                    .addColumn("ID", DbColumnType.INT, true)
>                                    .addColumn("DATA", DbColumnType.STRING)
>                                    .pkFields("ID")
482,510c246,249
<         engine.persist("TEST", entry);
< 
<         ResultIterator it = engine.iterator(select(all()).from(table("TEST")));
< 
<         Map<String, ResultColumn> res;
<         res = it.next();
<         assertNotNull("result is not null", res);
<         assertTrue("COL1 exists", res.containsKey("COL1"));
<         assertEquals("COL1 ok?", 1, (int) res.get("COL1").toInt());
< 
<         assertTrue("COL2 exists", res.containsKey("COL2"));
<         assertFalse("COL2 ok?", res.get("COL2").toBoolean());
< 
<         assertTrue("COL3 exists", res.containsKey("COL3"));
<         assertEquals("COL3 ok?", 2D, res.get("COL3").toDouble(), 0);
< 
<         assertTrue("COL4 exists", res.containsKey("COL4"));
<         assertEquals("COL4 ok?", 3L, (long) res.get("COL4").toLong());
< 
<         assertTrue("COL5 exists", res.containsKey("COL5"));
<         assertEquals("COL5  ok?", "ADEUS", res.get("COL5").toString());
< 
<         assertNull("no more data to consume?", it.next());
< 
<         assertTrue("result set is closed?", it.isClosed());
<         assertNull("next on a closed result set must return null", it.next());
< 
<         // calling close on a closed result set has no effect.
<         it.close();
---
>         engine.addEntity(p);
>         Map<String, DbColumnType> meta = engine.getMetadata("TEST_METADATA");
>         if (!meta.containsKey("ID") || !meta.containsKey("DATA")) {
>             throw new DatabaseEngineRuntimeException("Metadata does not contain expected columns");
512,527d250
< 
<     @Test
<     public void queryWithIteratorWithNoDataTest() throws Exception {
<         create5ColumnsEntity();
< 
<         ResultIterator it = engine.iterator(select(all()).from(table("TEST")));
< 
<         assertNull("result is null", it.next());
< 
<         assertNull("no more data to consume?", it.next());
< 
<         assertTrue("result set is closed?", it.isClosed());
<         assertNull("next on a closed result set must return null", it.next());
< 
<         // calling close on a closed result set has no effect.
<         it.close();
530,540c253,255
<     /**
<      * Tests that an iterator created in a try-with-resources' resource specification header is automatically closed
<      * once the block is exited from.
<      *
<      * @throws Exception If an unexpected error occurs.
<      *
<      * @since 2.1.12
<      */
<     @Test
<     public void queryWithIteratorInTryWithResources() throws Exception {
<         create5ColumnsEntity();
---
>     @Test(expected = DatabaseEngineUniqueConstraintViolationException.class)
>     public void insertDuplicateDBError() throws Exception {
>         create5ColumnsEntityWithPrimaryKey();
542,543c257,258
<         final EntityEntry entry = entry()
<                 .set("COL1", 1)
---
>         EntityEntry entry = EntityEntry.builder()
>                                        .set("COL1", 2)
549,624d263
<         engine.persist("TEST", entry);
< 
<         final ResultIterator resultIterator;
<         try (final ResultIterator it = engine.iterator(select(all()).from(table("TEST")))) {
< 
<             resultIterator = it;
< 
<             assertFalse(
<                     "Result iterator should not be closed before exiting try-with-resources block",
<                     resultIterator.isClosed()
<             );
<         }
< 
<         assertTrue(
<                 "Result iterator should be closed after exiting try-with-resources block",
<                 resultIterator.isClosed()
<         );
<     }
< 
<     @Test
<     public void batchInsertTest() throws Exception {
<         create5ColumnsEntity();
< 
<         engine.beginTransaction();
< 
<         try {
<             EntityEntry entry = entry().set("COL1", 2).set("COL2", false).set("COL3", 2D).set("COL4", 3L).set("COL5", "ADEUS")
<                     .build();
< 
<             engine.addBatch("TEST", entry);
< 
<             entry = entry().set("COL1", 3).set("COL2", true).set("COL3", 3D).set("COL4", 4L).set("COL5", "OLA")
<                     .build();
< 
<             engine.addBatch("TEST", entry);
< 
<             engine.flush();
< 
<             engine.commit();
<         } finally {
<             if (engine.isTransactionActive()) {
<                 engine.rollback();
<             }
<         }
< 
<         List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table("TEST")).orderby(column("COL1").asc()));
< 
<         // 1st
<         assertTrue("COL1 exists", query.get(0).containsKey("COL1"));
<         assertEquals("COL1 ok?", 2, (int) query.get(0).get("COL1").toInt());
< 
<         assertTrue("COL2 exists", query.get(0).containsKey("COL2"));
<         assertFalse("COL2 ok?", query.get(0).get("COL2").toBoolean());
< 
<         assertTrue("COL3 exists", query.get(0).containsKey("COL3"));
<         assertEquals("COL3 ok?", 2D, query.get(0).get("COL3").toDouble(), 0);
< 
<         assertTrue("COL4 exists", query.get(0).containsKey("COL4"));
<         assertEquals("COL4 ok?", 3L, (long) query.get(0).get("COL4").toLong());
< 
<         assertTrue("COL5 exists", query.get(0).containsKey("COL5"));
<         assertEquals("COL5  ok?", "ADEUS", query.get(0).get("COL5").toString());
< 
<         // 2nd
< 
<         assertTrue("COL1 exists", query.get(1).containsKey("COL1"));
<         assertEquals("COL1 ok?", 3, (int) query.get(1).get("COL1").toInt());
< 
<         assertTrue("COL2 exists", query.get(1).containsKey("COL2"));
<         assertTrue("COL2 ok?", query.get(1).get("COL2").toBoolean());
< 
<         assertTrue("COL3 exists", query.get(1).containsKey("COL3"));
<         assertEquals("COL3 ok?", 3D, query.get(1).get("COL3").toDouble(), 0);
< 
<         assertTrue("COL4 exists", query.get(1).containsKey("COL4"));
<         assertEquals("COL4 ok?", 4L, (long) query.get(1).get("COL4").toLong());
626,627c265,267
<         assertTrue("COL5 exists", query.get(1).containsKey("COL5"));
<         assertEquals("COL5  ok?", "OLA", query.get(1).get("COL5").toString());
---
>         // Add the same entry twice (repeated value for COL1, id)
>         engine.persist("TEST", entry);
>         engine.persist("TEST", entry);
631,632c271,272
<     public void batchInsertAutocommitTest() throws Exception {
<         create5ColumnsEntity();
---
>     public void batchInsertDuplicateDBError() throws DatabaseEngineException {
>         create5ColumnsEntityWithPrimaryKey();
634c274,279
<         EntityEntry entry = entry().set("COL1", 2).set("COL2", false).set("COL3", 2D).set("COL4", 3L).set("COL5", "ADEUS")
---
>         EntityEntry entry = EntityEntry.builder()
>                                        .set("COL1", 2)
>                                        .set("COL2", false)
>                                        .set("COL3", 2D)
>                                        .set("COL4", 3L)
>                                        .set("COL5", "ADEUS")
636a282
>         // Add the same entry twice (repeated value for COL1, id)
638,641d283
< 
<         entry = entry().set("COL1", 3).set("COL2", true).set("COL3", 3D).set("COL4", 4L).set("COL5", "OLA")
<                 .build();
< 
644,722d285
<         // autocommit set to true.
<         engine.flush();
< 
< 
<         List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table("TEST")).orderby(column("COL1").asc()));
< 
<         // 1st
<         assertTrue("COL1 exists", query.get(0).containsKey("COL1"));
<         assertEquals("COL1 ok?", 2, (int) query.get(0).get("COL1").toInt());
< 
<         assertTrue("COL2 exists", query.get(0).containsKey("COL2"));
<         assertFalse("COL2 ok?", query.get(0).get("COL2").toBoolean());
< 
<         assertTrue("COL3 exists", query.get(0).containsKey("COL3"));
<         assertEquals("COL3 ok?", 2D, query.get(0).get("COL3").toDouble(), 0);
< 
<         assertTrue("COL4 exists", query.get(0).containsKey("COL4"));
<         assertEquals("COL4 ok?", 3L, (long) query.get(0).get("COL4").toLong());
< 
<         assertTrue("COL5 exists", query.get(0).containsKey("COL5"));
<         assertEquals("COL5  ok?", "ADEUS", query.get(0).get("COL5").toString());
< 
<         // 2nd
< 
<         assertTrue("COL1 exists", query.get(1).containsKey("COL1"));
<         assertEquals("COL1 ok?", 3, (int) query.get(1).get("COL1").toInt());
< 
<         assertTrue("COL2 exists", query.get(1).containsKey("COL2"));
<         assertTrue("COL2 ok?", query.get(1).get("COL2").toBoolean());
< 
<         assertTrue("COL3 exists", query.get(1).containsKey("COL3"));
<         assertEquals("COL3 ok?", 3D, query.get(1).get("COL3").toDouble(), 0);
< 
<         assertTrue("COL4 exists", query.get(1).containsKey("COL4"));
<         assertEquals("COL4 ok?", 4L, (long) query.get(1).get("COL4").toLong());
< 
<         assertTrue("COL5 exists", query.get(1).containsKey("COL5"));
<         assertEquals("COL5  ok?", "OLA", query.get(1).get("COL5").toString());
<     }
< 
<     /**
<      * Tests that on a rollback situation, the prepared statement batches are cleared.
<      *
<      * The steps performed on this test are:
<      * <ol>
<      *     <li>Add batch to transaction and purposely fail to flush</li>
<      *     <li>Ensure the existence of the Exception and rollback transaction</li>
<      *     <li>Flush again successfully and ensure that the DB table doesn't have any rows</li>
<      * </ol>
<      *
<      * This is a regression test.
<      *
<      * @throws DatabaseEngineException If there is a problem on {@link DatabaseEngine} operations.
<      * @since 2.1.12
<      */
<     @Test
<     public void batchInsertRollback() throws DatabaseEngineException {
<         final CountDownLatch latch = new CountDownLatch(1);
< 
<         final DbEntity entity = dbEntity()
<                 .name("TEST")
<                 .addColumn("COL1", INT)
<                 .build();
< 
<         new MockUp<AbstractDatabaseEngine>() {
<             @Mock
<             public synchronized void flush(final Invocation invocation) throws DatabaseEngineException {
<                 if (latch.getCount() == 1) {
<                     throw new DatabaseEngineException("");
<                 }
<                 invocation.proceed();
<             }
<         };
< 
<         DatabaseEngineException expectedException = null;
< 
<         engine.addEntity(entity);
<         engine.beginTransaction();
< 
724,726d286
<             final EntityEntry entry = entry().set("COL1", 1).build();
< 
<             engine.addBatch("TEST", entry);
728,733c288,290
<             fail("Was expecting the flush operation to fail");
<         } catch (final DatabaseEngineException e) {
<             expectedException = e;
<         } finally {
<             if (engine.isTransactionActive()) {
<                 engine.rollback();
---
>         } catch (DatabaseEngineException e) {
>             if (!(e.getCause() instanceof SQLException)) {
>                 throw e;
734a292
>             throw e;
736,751d293
< 
<         // Ensure we had an exception and therefore we didn't insert anything on the DB and that we cleared the batches.
<         assertNotNull("DB returned exception when flushing", expectedException);
< 
<         latch.countDown();
<         engine.beginTransaction();
<         engine.flush();
<         engine.commit();
< 
<         final List<Map<String, ResultColumn>> query = engine.query(select(all())
<                                                                            .from(table("TEST"))
<                                                                            .orderby(column("COL1").asc()));
< 
<         // Previously, we rolled back the transaction; now we are trying the flush an empty transaction.
<         // Therefore, we shouldn't have any rows on the table.
<         assertEquals("There are no rows on table TEST", 0, query.size());
757c299
<         DbEntity entity = dbEntity()
---
>         DbEntity entity = DbEntity.builder()
759,760c301,302
<                 .addColumn("COL1", INT)
<                 .addColumn("COL2", BLOB)
---
>                 .addColumn("COL1", DbColumnType.INT)
>                 .addColumn("COL2", DbColumnType.BLOB)
764c306
<         EntityEntry entry = entry()
---
>         EntityEntry entry = EntityEntry.builder()
771c313
<         List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table("TEST")));
---
>         List<Map<String, ResultColumn>> query = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")));
775c317,318
<             assertEquals("arrays are equal?", d, query.get(0).get("COL2").<double[]>toBlob()[i++], 0D);
---
>             if (d != query.get(0).get("COL2").<double[]>toBlob()[i++]) {
>                 throw new DatabaseEngineRuntimeException("Blob arrays not equal");
778,797d320
< 
<     @Test
<     public void limitNumberOfRowsTest() throws DatabaseEngineException {
<         create5ColumnsEntity();
< 
<         EntityEntry.Builder entry = entry()
<                 .set("COL1", 2)
<                 .set("COL2", false)
<                 .set("COL3", 2D)
<                 .set("COL4", 3L)
<                 .set("COL5", "ADEUS");
< 
<         for (int i = 0; i < 10; i++) {
<             entry.set("COL1", i);
<             engine.persist("TEST", entry
<                     .build());
<         }
<         List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table("TEST")).limit(5));
< 
<         assertEquals("number of rows ok?", 5, query.size());
804c327
<         EntityEntry.Builder entry = entry()
---
>         EntityEntry.Builder entry = EntityEntry.builder()
813,814c336
<             engine.persist("TEST", entry
<                     .build());
---
>             engine.persist("TEST", entry.build());
819,820c341,347
<         List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table("TEST")).limit(limit).offset(offset));
<         assertEquals("number of rows ok?", limit, query.size());
---
>         List<Map<String, ResultColumn>> query = engine.query(SqlBuilder.select(SqlBuilder.all())
>                                                                         .from(SqlBuilder.table("TEST"))
>                                                                         .limit(limit)
>                                                                         .offset(offset));
>         if (query.size() != limit) {
>             throw new DatabaseEngineRuntimeException("Row number not matching expected limit");
>         }
822c349,351
<             assertEquals("Check correct row", i, query.get(j).get("COL1").toInt().intValue());
---
>             if (i != query.get(j).get("COL1").toInt().intValue()) {
>                 throw new DatabaseEngineRuntimeException("Row does not match expected value");
>             }
828c357
<         DbEntity entity = dbEntity()
---
>         DbEntity entity = DbEntity.builder()
830,835c359,364
<                 .addColumn("COL1", INT)
<                 .addColumn("COL2", BOOLEAN)
<                 .addColumn("COL3", DOUBLE)
<                 .addColumn("COL4", LONG)
<                 .addColumn("COL5", STRING)
<                 .addColumn("COL6", INT)
---
>                 .addColumn("COL1", DbColumnType.INT)
>                 .addColumn("COL2", DbColumnType.BOOLEAN)
>                 .addColumn("COL3", DbColumnType.DOUBLE)
>                 .addColumn("COL4", DbColumnType.LONG)
>                 .addColumn("COL5", DbColumnType.STRING)
>                 .addColumn("COL6", DbColumnType.INT)
840c369
<         EntityEntry.Builder entry = entry()
---
>         EntityEntry.Builder entry = EntityEntry.builder()
851,852c380
<             engine.persist("TEST", entry
<                     .build());
---
>             engine.persist("TEST", entry.build());
857,858c385,392
<         List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table("TEST")).limit(limit).offset(offset).orderby(column("COL6").asc()));
<         assertEquals("number of rows ok?", limit, query.size());
---
>         List<Map<String, ResultColumn>> query = engine.query(SqlBuilder.select(SqlBuilder.all())
>                                                                         .from(SqlBuilder.table("TEST"))
>                                                                         .limit(limit)
>                                                                         .offset(offset)
>                                                                         .orderby(SqlBuilder.column("COL6").asc()));
>         if (query.size() != limit) {
>             throw new DatabaseEngineRuntimeException("Row number not matching expected limit");
>         }
860,861c394,396
<             assertEquals("Check correct row col1", 19 - i, query.get(j).get("COL1").toInt().intValue());
<             assertEquals("Check correct row col6", i + 1, query.get(j).get("COL6").toInt().intValue());
---
>             if ((query.get(j).get("COL1").toInt().intValue() != 19 - i) || 
>                 (query.get(j).get("COL6").toInt().intValue() != i + 1)) {
>                 throw new DatabaseEngineRuntimeException("Ordered row does not match expected values");
864,925d398
< 
<     @Test
<     public void limitOffsetAndOrder2NumberOfRowsTest() throws DatabaseEngineException {
<         DbEntity entity = dbEntity()
<                 .name("TEST")
<                 .addColumn("COL1", INT)
<                 .addColumn("COL2", STRING)
<                 .addColumn("COL3", INT)
<                 .build();
< 
<         engine.addEntity(entity);
< 
<         EntityEntry.Builder entry = entry()
<                 .set("COL1", 0)
<                 .set("COL2", "A")
<                 .set("COL3", 6);
<         engine.persist("TEST", entry.build());
< 
< 
<         entry.set("COL1", 1);
<         entry.set("COL2", "B");
<         entry.set("COL3", 5);
<         engine.persist("TEST", entry.build());
< 
<         entry.set("COL1", 2);
<         entry.set("COL2", "C");
<         entry.set("COL3", 4);
<         engine.persist("TEST", entry.build());
< 
<         entry.set("COL1", 3);
<         entry.set("COL2", "D");
<         entry.set("COL3", 3);
<         engine.persist("TEST", entry.build());
< 
<         entry.set("COL1", 4);
<         entry.set("COL2", "E");
<         entry.set("COL3", 2);
<         engine.persist("TEST", entry.build());
< 
<         entry.set("COL1", 5);
<         entry.set("COL2", "F");
<         entry.set("COL3", 1);
<         engine.persist("TEST", entry.build());
< 
<         entry.set("COL1", 6);
<         entry.set("COL2", "G");
<         entry.set("COL3", 0);
<         engine.persist("TEST", entry.build());
< 
<         int limit = 2;
<         int offset = 3;
<         List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table("TEST")).limit(limit).offset(offset));
<         assertEquals("number of rows ok?", limit, query.size());
< 
<         assertEquals("Check correct row col2", "D", query.get(0).get("COL2").toString());
<         assertEquals("Check correct row col2", "E", query.get(1).get("COL2").toString());
< 
<         query = engine.query(select(all()).from(table("TEST")).limit(limit).offset(offset).orderby(column("COL2").desc()));
<         assertEquals("number of rows ok?", limit, query.size());
< 
<         assertEquals("Check correct row col2", "D", query.get(0).get("COL2").toString());
<         assertEquals("Check correct row col2", "C", query.get(1).get("COL2").toString());
930c403
<         DbEntity entity = dbEntity()
---
>         DbEntity entity = DbEntity.builder()
932,937c405,410
<                 .addColumn("COL1", INT)
<                 .addColumn("COL2", BOOLEAN)
<                 .addColumn("COL3", DOUBLE)
<                 .addColumn("COL4", LONG)
<                 .addColumn("COL5", STRING)
<                 .addColumn("COL6", INT)
---
>                 .addColumn("COL1", DbColumnType.INT)
>                 .addColumn("COL2", DbColumnType.BOOLEAN)
>                 .addColumn("COL3", DbColumnType.DOUBLE)
>                 .addColumn("COL4", DbColumnType.LONG)
>                 .addColumn("COL5", DbColumnType.STRING)
>                 .addColumn("COL6", DbColumnType.INT)
942c415
<         EntityEntry.Builder entry = entry()
---
>         EntityEntry.Builder entry = EntityEntry.builder()
958,959c431,438
<         List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table("TEST")).limit(limit).offset(offset).orderby(column("COL6").asc()));
<         assertEquals("number of rows ok?", limit, query.size());
---
>         List<Map<String, ResultColumn>> query = engine.query(SqlBuilder.select(SqlBuilder.all())
>                                                                         .from(SqlBuilder.table("TEST"))
>                                                                         .limit(limit)
>                                                                         .offset(offset)
>                                                                         .orderby(SqlBuilder.column("COL6").asc()));
>         if (query.size() != limit) {
>             throw new DatabaseEngineRuntimeException("Row number not matching expected limit");
>         }
961,962c440,443
<             assertEquals("Check correct row col1", 19 - i, query.get(j).get("COL1").toInt().intValue());
<             assertEquals("Check correct row col6", i + 1, query.get(j).get("COL6").toInt().intValue());
---
>             if ((query.get(j).get("COL1").toInt().intValue() != 19 - i) ||
>                 (query.get(j).get("COL6").toInt().intValue() != i + 1)) {
>                 throw new DatabaseEngineRuntimeException("Row values not matching expected when offset is negative");
>             }
968c449
<         DbEntity entity = dbEntity()
---
>         DbEntity entity = DbEntity.builder()
970,975c451,456
<                 .addColumn("COL1", INT)
<                 .addColumn("COL2", BOOLEAN)
<                 .addColumn("COL3", DOUBLE)
<                 .addColumn("COL4", LONG)
<                 .addColumn("COL5", STRING)
<                 .addColumn("COL6", INT)
---
>                 .addColumn("COL1", DbColumnType.INT)
>                 .addColumn("COL2", DbColumnType.BOOLEAN)
>                 .addColumn("COL3", DbColumnType.DOUBLE)
>                 .addColumn("COL4", DbColumnType.LONG)
>                 .addColumn("COL5", DbColumnType.STRING)
>                 .addColumn("COL6", DbColumnType.INT)
980c461
<         EntityEntry.Builder entry = entry()
---
>         EntityEntry.Builder entry = EntityEntry.builder()
991,992c472
<             engine.persist("TEST", entry
<                     .build());
---
>             engine.persist("TEST", entry.build());
997,998c477,483
<         List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table("TEST")).limit(limit).offset(offset));
<         assertEquals("number of rows ok?", 0, query.size());
---
>         List<Map<String, ResultColumn>> query = engine.query(SqlBuilder.select(SqlBuilder.all())
>                                                                         .from(SqlBuilder.table("TEST"))
>                                                                         .limit(limit)
>                                                                         .offset(offset));
>         if (query.size() != 0) {
>             throw new DatabaseEngineRuntimeException("Expected no results when offset is equal to table size");
>         }
1003c488
<         DbEntity entity = dbEntity()
---
>         DbEntity entity = DbEntity.builder()
1005,1010c490,495
<                 .addColumn("COL1", INT)
<                 .addColumn("COL2", BOOLEAN)
<                 .addColumn("COL3", DOUBLE)
<                 .addColumn("COL4", LONG)
<                 .addColumn("COL5", STRING)
<                 .addColumn("COL6", INT)
---
>                 .addColumn("COL1", DbColumnType.INT)
>                 .addColumn("COL2", DbColumnType.BOOLEAN)
>                 .addColumn("COL3", DbColumnType.DOUBLE)
>                 .addColumn("COL4", DbColumnType.LONG)
>                 .addColumn("COL5", DbColumnType.STRING)
>                 .addColumn("COL6", DbColumnType.INT)
1015c500
<         EntityEntry.Builder entry = entry()
---
>         EntityEntry.Builder entry = EntityEntry.builder()
1026,1027c511
<             engine.persist("TEST", entry
<                     .build());
---
>             engine.persist("TEST", entry.build());
1032,1033c516,522
<         List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table("TEST")).limit(limit).offset(offset));
<         assertEquals("number of rows ok?", 19, query.size());
---
>         List<Map<String, ResultColumn>> query = engine.query(SqlBuilder.select(SqlBuilder.all())
>                                                                         .from(SqlBuilder.table("TEST"))
>                                                                         .limit(limit)
>                                                                         .offset(offset));
>         if (query.size() != 19) {
>             throw new DatabaseEngineRuntimeException("When limit is zero, expected table length minus offset");
>         }
1036,1037c525,531
<         query = engine.query(select(all()).from(table("TEST")).limit(limit).offset(offset));
<         assertEquals("number of rows ok?", 19, query.size());
---
>         query = engine.query(SqlBuilder.select(SqlBuilder.all())
>                                        .from(SqlBuilder.table("TEST"))
>                                        .limit(limit)
>                                        .offset(offset));
>         if (query.size() != 19) {
>             throw new DatabaseEngineRuntimeException("When limit is negative, expected table length minus offset");
>         }
1042c536
<         DbEntity entity = dbEntity()
---
>         DbEntity entity = DbEntity.builder()
1044,1049c538,543
<                 .addColumn("COL1", INT)
<                 .addColumn("COL2", BOOLEAN)
<                 .addColumn("COL3", DOUBLE)
<                 .addColumn("COL4", LONG)
<                 .addColumn("COL5", STRING)
<                 .addColumn("COL6", INT)
---
>                 .addColumn("COL1", DbColumnType.INT)
>                 .addColumn("COL2", DbColumnType.BOOLEAN)
>                 .addColumn("COL3", DbColumnType.DOUBLE)
>                 .addColumn("COL4", DbColumnType.LONG)
>                 .addColumn("COL5", DbColumnType.STRING)
>                 .addColumn("COL6", DbColumnType.INT)
1054c548
<         EntityEntry.Builder entry = entry()
---
>         EntityEntry.Builder entry = EntityEntry.builder()
1065,1066c559
<             engine.persist("TEST", entry
<                     .build());
---
>             engine.persist("TEST", entry.build());
1070,1073c563,567
<         List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table("TEST")).offset(offset));
<         assertEquals("number of rows ok?", 20 - offset, query.size());
<         for (int i = offset, j = 0; i < 20; i++, j++) {
<             assertEquals("Check correct row 1", i, query.get(j).get("COL1").toInt().intValue());
---
>         List<Map<String, ResultColumn>> query = engine.query(SqlBuilder.select(SqlBuilder.all())
>                                                                         .from(SqlBuilder.table("TEST"))
>                                                                         .offset(offset));
>         if (query.size() != 20 - offset) {
>             throw new DatabaseEngineRuntimeException("Offset query returned unexpected number of rows");
1075,1077d568
< 
<         query = engine.query(select(all()).from(table("TEST")).offset(offset).orderby(column("COL6").asc()));
<         assertEquals("number of rows ok?", 20 - offset, query.size());
1079c570,572
<             assertEquals("Check correct row 6", offset + 1 + j, query.get(j).get("COL6").toInt().intValue());
---
>             if (i != query.get(j).get("COL1").toInt().intValue()) {
>                 throw new DatabaseEngineRuntimeException("Offset row check failed");
>             }
1087c580
<         EntityEntry.Builder entry = entry()
---
>         EntityEntry.Builder entry = EntityEntry.builder()
1096,1097c589
<             engine.persist("TEST", entry
<                     .build());
---
>             engine.persist("TEST", entry.build());
1099c591,592
<         List<Map<String, ResultColumn>> query = engine.query(select(stddev(column("COL1")).alias("STDDEV")).from(table("TEST")));
---
>         List<Map<String, ResultColumn>> query = engine.query(SqlBuilder.select(SqlBuilder.stddev(SqlBuilder.column("COL1")).alias("STDDEV"))
>                                                                           .from(SqlBuilder.table("TEST")));
1101c594,596
<         assertEquals("result ok?", 3.0276503540974917D, query.get(0).get("STDDEV").toDouble(), 0.0001D);
---
>         if (Math.abs(query.get(0).get("STDDEV").toDouble() - 3.0276503540974917D) > 0.0001D) {
>             throw new DatabaseEngineRuntimeException("STDDEV value not within expected range");
>         }
1108c603
<         EntityEntry.Builder entry = entry()
---
>         EntityEntry.Builder entry = EntityEntry.builder()
1117,1118c612
<             engine.persist("TEST", entry
<                     .build());
---
>             engine.persist("TEST", entry.build());
1120c614,615
<         List<Map<String, ResultColumn>> query = engine.query(select(sum(column("COL1")).alias("SUM")).from(table("TEST")));
---
>         List<Map<String, ResultColumn>> query = engine.query(SqlBuilder.select(SqlBuilder.sum(SqlBuilder.column("COL1")).alias("SUM"))
>                                                                           .from(SqlBuilder.table("TEST")));
1122c617,619
<         assertEquals("result ok?", 45, (int) query.get(0).get("SUM").toInt());
---
>         if (query.get(0).get("SUM").toInt() != 45) {
>             throw new DatabaseEngineRuntimeException("SUM value incorrect");
>         }
1129c626
<         EntityEntry.Builder entry = entry()
---
>         EntityEntry.Builder entry = EntityEntry.builder()
1138,1139c635
<             engine.persist("TEST", entry
<                     .build());
---
>             engine.persist("TEST", entry.build());
1141c637,638
<         List<Map<String, ResultColumn>> query = engine.query(select(count(column("COL1")).alias("COUNT")).from(table("TEST")));
---
>         List<Map<String, ResultColumn>> query = engine.query(SqlBuilder.select(SqlBuilder.count(SqlBuilder.column("COL1")).alias("COUNT"))
>                                                                           .from(SqlBuilder.table("TEST")));
1143c640,642
<         assertEquals("result ok?", 10, (int) query.get(0).get("COUNT").toInt());
---
>         if (query.get(0).get("COUNT").toInt() != 10) {
>             throw new DatabaseEngineRuntimeException("COUNT value incorrect");
>         }
1150c649
<         EntityEntry.Builder entry = entry()
---
>         EntityEntry.Builder entry = EntityEntry.builder()
1159,1160c658
<             engine.persist("TEST", entry
<                     .build());
---
>             engine.persist("TEST", entry.build());
1162c660,661
<         List<Map<String, ResultColumn>> query = engine.query(select(avg(column("COL1")).alias("AVG")).from(table("TEST")));
---
>         List<Map<String, ResultColumn>> query = engine.query(SqlBuilder.select(SqlBuilder.avg(SqlBuilder.column("COL1")).alias("AVG"))
>                                                                           .from(SqlBuilder.table("TEST")));
1164c663,665
<         assertEquals("result ok?", 4.5D, query.get(0).get("AVG").toDouble(), 0);
---
>         if (Math.abs(query.get(0).get("AVG").toDouble() - 4.5D) > 0.0) {
>             throw new DatabaseEngineRuntimeException("AVG value incorrect");
>         }
1171c672
<         EntityEntry.Builder entry = entry()
---
>         EntityEntry.Builder entry = EntityEntry.builder()
1180,1181c681
<             engine.persist("TEST", entry
<                     .build());
---
>             engine.persist("TEST", entry.build());
1183c683,684
<         List<Map<String, ResultColumn>> query = engine.query(select(max(column("COL1")).alias("MAX")).from(table("TEST")));
---
>         List<Map<String, ResultColumn>> query = engine.query(SqlBuilder.select(SqlBuilder.max(SqlBuilder.column("COL1")).alias("MAX"))
>                                                                           .from(SqlBuilder.table("TEST")));
1185c686,688
<         assertEquals("result ok?", 9, (int) query.get(0).get("MAX").toInt());
---
>         if (query.get(0).get("MAX").toInt() != 9) {
>             throw new DatabaseEngineRuntimeException("MAX value incorrect");
>         }
1192c695
<         EntityEntry.Builder entry = entry()
---
>         EntityEntry.Builder entry = EntityEntry.builder()
1201,1202c704
<             engine.persist("TEST", entry
<                     .build());
---
>             engine.persist("TEST", entry.build());
1204c706,707
<         List<Map<String, ResultColumn>> query = engine.query(select(min(column("COL1")).alias("MIN")).from(table("TEST")));
---
>         List<Map<String, ResultColumn>> query = engine.query(SqlBuilder.select(SqlBuilder.min(SqlBuilder.column("COL1")).alias("MIN"))
>                                                                           .from(SqlBuilder.table("TEST")));
1206c709,711
<         assertEquals("result ok?", 0, (int) query.get(0).get("MIN").toInt());
---
>         if (query.get(0).get("MIN").toInt() != 0) {
>             throw new DatabaseEngineRuntimeException("MIN value incorrect");
>         }
1213c718
<         EntityEntry.Builder entry = entry()
---
>         EntityEntry.Builder entry = EntityEntry.builder()
1222,1223c727
<             engine.persist("TEST", entry
<                     .build());
---
>             engine.persist("TEST", entry.build());
1226c730,731
<         List<Map<String, ResultColumn>> query = engine.query(select(floor(column("COL3")).alias("FLOOR")).from(table("TEST")));
---
>         List<Map<String, ResultColumn>> query = engine.query(SqlBuilder.select(SqlBuilder.floor(SqlBuilder.column("COL3")).alias("FLOOR"))
>                                                                           .from(SqlBuilder.table("TEST")));
1228c733,735
<         assertEquals("result ok?", 2.0, query.get(0).get("FLOOR").toDouble(), DELTA);
---
>         if (Math.abs(query.get(0).get("FLOOR").toDouble() - 2.0) > 1e-7) {
>             throw new DatabaseEngineRuntimeException("FLOOR value incorrect");
>         }
1235c742
<         EntityEntry.Builder entry = entry()
---
>         EntityEntry.Builder entry = EntityEntry.builder()
1244,1245c751
<             engine.persist("TEST", entry
<                     .build());
---
>             engine.persist("TEST", entry.build());
1248c754,755
<         List<Map<String, ResultColumn>> query = engine.query(select(ceiling(column("COL3")).alias("CEILING")).from(table("TEST")));
---
>         List<Map<String, ResultColumn>> query = engine.query(SqlBuilder.select(SqlBuilder.ceiling(SqlBuilder.column("COL3")).alias("CEILING"))
>                                                                           .from(SqlBuilder.table("TEST")));
1250c757,759
<         assertEquals("result ok?", 3.0, query.get(0).get("CEILING").toDouble(), DELTA);
---
>         if (Math.abs(query.get(0).get("CEILING").toDouble() - 3.0) > 1e-7) {
>             throw new DatabaseEngineRuntimeException("CEILING value incorrect");
>         }
1255c764
<         DbEntity entity = dbEntity()
---
>         DbEntity entity = DbEntity.builder()
1257,1258c766,767
<                 .addColumn("COL1", INT)
<                 .addColumn("COL2", INT)
---
>                 .addColumn("COL1", DbColumnType.INT)
>                 .addColumn("COL2", DbColumnType.INT)
1263c772
<         EntityEntry.Builder ee = entry()
---
>         EntityEntry.Builder ee = EntityEntry.builder()
1267,1268c776
<         engine.persist("TEST", ee
<                 .build());
---
>         engine.persist("TEST", ee.build());
1270c778,779
<         List<Map<String, ResultColumn>> query = engine.query(select(div(column("COL1"), column("COL2")).alias("DIV")).from(table("TEST")));
---
>         List<Map<String, ResultColumn>> query = engine.query(SqlBuilder.select(SqlBuilder.div(SqlBuilder.column("COL1"), SqlBuilder.column("COL2")).alias("DIV"))
>                                                                           .from(SqlBuilder.table("TEST")));
1272c781,783
<         assertEquals("", 0.5D, query.get(0).get("DIV").toDouble(), 0);
---
>         if (Math.abs(query.get(0).get("DIV").toDouble() - 0.5D) > 0.0) {
>             throw new DatabaseEngineRuntimeException("Division result incorrect");
>         }
1277c788
<         List<Map<String, ResultColumn>> query = engine.query(select(k(1).alias("constant")));
---
>         List<Map<String, ResultColumn>> query = engine.query(SqlBuilder.select(SqlBuilder.k(1).alias("constant")));
1279c790,792
<         assertEquals("constant ok?", 1, (int) query.get(0).get("constant").toInt());
---
>         if (query.get(0).get("constant").toInt() != 1) {
>             throw new DatabaseEngineRuntimeException("Select without from returned incorrect constant");
>         }
1284c797
<         DbEntity entity = dbEntity()
---
>         DbEntity entity = DbEntity.builder()
1286,1287c799,800
<                 .addColumn("COL1", INT)
<                 .addColumn("COL2", INT)
---
>                 .addColumn("COL1", DbColumnType.INT)
>                 .addColumn("COL2", DbColumnType.INT)
1293c806,808
<             assertEquals("exception ok?", "You have to define the entity name", de.getMessage());
---
>             if (!"You have to define the entity name".equals(de.getMessage())) {
>                 throw de;
>             }
1300c815
<         DbEntity entity = dbEntity()
---
>         DbEntity entity = DbEntity.builder()
1302,1303c817,818
<                 .addColumn("COL1", INT)
<                 .addColumn("COL2", INT)
---
>                 .addColumn("COL1", DbColumnType.INT)
>                 .addColumn("COL2", DbColumnType.INT)
1309c824,826
<             assertEquals("exception ok?", "You have to define the entity name", de.getMessage());
---
>             if (!"You have to define the entity name".equals(de.getMessage())) {
>                 throw de;
>             }
1316c833
<         DbEntity entity = dbEntity()
---
>         DbEntity entity = DbEntity.builder()
1318,1319c835,836
<                 .addColumn("COL1", INT)
<                 .addColumn("COL2", INT)
---
>                 .addColumn("COL1", DbColumnType.INT)
>                 .addColumn("COL2", DbColumnType.INT)
1325c842,844
<             assertEquals("exception ok?", "Entity name '0123456789012345678901234567891' exceeds the maximum number of characters (30)", de.getMessage());
---
>             if (!("Entity '0123456789012345678901234567891' exceeds the maximum number of characters (30)".equals(de.getMessage()))) {
>                 throw de;
>             }
1332c851
<         DbEntity entity = dbEntity()
---
>         DbEntity entity = DbEntity.builder()
1334,1335c853,854
<                 .addColumn("", INT)
<                 .addColumn("COL2", INT)
---
>                 .addColumn("", DbColumnType.INT)
>                 .addColumn("COL2", DbColumnType.INT)
1341c860,862
<             assertEquals("exception ok?", "Column in entity 'entname' must have a name", de.getMessage());
---
>             if (!("Column in entity 'entname' must have a name".equals(de.getMessage()))) {
>                 throw de;
>             }
1348c869
<         DbEntity entity = dbEntity()
---
>         DbEntity entity = DbEntity.builder()
1350,1351c871,872
<                 .addColumn("COL1", INT, true)
<                 .addColumn("COL2", INT, true)
---
>                 .addColumn("COL1", DbColumnType.INT, true)
>                 .addColumn("COL2", DbColumnType.INT, true)
1357c878,880
<             assertEquals("exception ok?", "You can only define one auto incremented column", de.getMessage());
---
>             if (!("You can only define one auto incremented column".equals(de.getMessage()))) {
>                 throw de;
>             }
1364c887
<         DbEntity entity = dbEntity()
---
>         DbEntity entity = DbEntity.builder()
1366,1367c889,890
<                 .addColumn("COL1", INT, true)
<                 .addColumn("COL2", INT)
---
>                 .addColumn("COL1", DbColumnType.INT, true)
>                 .addColumn("COL2", DbColumnType.INT)
1370d892
< 
1373c895
<         EntityEntry ee = entry()
---
>         EntityEntry ee = EntityEntry.builder()
1379c901,903
<         assertEquals("ret ok?", new Long(1), persist);
---
>         if (!new Long(1).equals(persist)) {
>             throw new DatabaseEngineRuntimeException("Generated key not as expected");
>         }
1384c908
<         DbEntity entity = dbEntity()
---
>         DbEntity entity = DbEntity.builder()
1386,1387c910,911
<                 .addColumn("COL1", INT, true)
<                 .addColumn("COL2", INT)
---
>                 .addColumn("COL1", DbColumnType.INT, true)
>                 .addColumn("COL2", DbColumnType.INT)
1390d913
< 
1393c916
<         EntityEntry ee = entry()
---
>         EntityEntry ee = EntityEntry.builder()
1399c922,924
<         assertEquals("ret ok?", new Long(1), persist);
---
>         if (!new Long(1).equals(persist)) {
>             throw new DatabaseEngineRuntimeException("Generated key not as expected");
>         }
1401c926
<         ee = entry()
---
>         ee = EntityEntry.builder()
1407c932,934
<         assertEquals("ret ok?", new Long(2), persist);
---
>         if (!new Long(2).equals(persist)) {
>             throw new DatabaseEngineRuntimeException("Generated key not as expected");
>         }
1412c939
<         DbEntity entity = dbEntity()
---
>         DbEntity entity = DbEntity.builder()
1414,1415c941,942
<                 .addColumn("COL1", INT, true)
<                 .addColumn("COL2", INT)
---
>                 .addColumn("COL1", DbColumnType.INT, true)
>                 .addColumn("COL2", DbColumnType.INT)
1418d944
< 
1424c950
<             EntityEntry ee = entry()
---
>             EntityEntry ee = EntityEntry.builder()
1430c956,958
<             assertEquals("ret ok?", new Long(1), persist);
---
>             if (!new Long(1).equals(persist)) {
>                 throw new DatabaseEngineRuntimeException("Generated key not as expected");
>             }
1432c960
<             ee = entry()
---
>             ee = EntityEntry.builder()
1438c966,968
<             assertEquals("ret ok?", new Long(2), persist);
---
>             if (!new Long(2).equals(persist)) {
>                 throw new DatabaseEngineRuntimeException("Generated key not as expected");
>             }
1448,1453d977
<     /**
<      * Tests that when persisting an entity in table that does not contain any auto generated values, the
<      * {@link DatabaseEngine#persist(String, EntityEntry)} method returns {@code null}.
<      *
<      * @throws DatabaseEngineException If any error occurs.
<      */
1456c980
<         final DbEntity entity = dbEntity()
---
>         final DbEntity entity = DbEntity.builder()
1458,1461c982,984
<             .addColumn("COL1", STRING)
<             .addColumn("COL2", STRING)
<             // Set the two columns as fields of primary key, so they belong to the generated keys.
<             .pkFields(ImmutableSet.of("COL1", "COL2"))
---
>             .addColumn("COL1", DbColumnType.STRING)
>             .addColumn("COL2", DbColumnType.STRING)
>             .pkFields("COL1", "COL2")
1464c987
<         this.engine.addEntity(entity);
---
>         engine.addEntity(entity);
1466c989
<         final EntityEntry ee = entry()
---
>         final EntityEntry ee = EntityEntry.builder()
1471,1473c994,996
<         assertThat(this.engine.persist("TEST", ee))
<             .as("The auto generated value should be null!")
<             .isNull();
---
>         if (engine.persist("TEST", ee) != null) {
>             throw new DatabaseEngineRuntimeException("Expected null generated key for non-autoIncrement entity");
>         }
1476,1479d998
<     /**
<      * Tests that when trying to add {@link DbEntity} with multiple columns with auto incremented values, the
<      * {@link DatabaseEngine#addEntity(DbEntity)} method throws a {@link DatabaseEngineException}.
<      */
1482c1001
<         final DbEntity entity = dbEntity()
---
>         final DbEntity entity = DbEntity.builder()
1484,1485c1003,1004
<             .addColumn("COL1", INT, true)
<             .addColumn("COL2", INT, true)
---
>             .addColumn("COL1", DbColumnType.INT, true)
>             .addColumn("COL2", DbColumnType.INT, true)
1488,1491c1007,1012
<         assertThatCode(() -> this.engine.addEntity(entity))
<             .as("The DatabaseEngine should not allow to setup a DbEntity with multiple auto incremented columns")
<             .isInstanceOf(DatabaseEngineException.class);
< 
---
>         try {
>             engine.addEntity(entity);
>             throw new DatabaseEngineRuntimeException("Expected exception on multiple auto-increment columns");
>         } catch (DatabaseEngineException ex) {
>             // Expected exception
>         }
1496c1017
<         DbEntity entity = dbEntity()
---
>         DbEntity entity = DbEntity.builder()
1498,1499c1019,1020
<                 .addColumn("COL1", INT)
<                 .addColumn("COL2", INT)
---
>                 .addColumn("COL1", DbColumnType.INT)
>                 .addColumn("COL2", DbColumnType.INT)
1502d1022
< 
1507c1027
<             EntityEntry ee = entry()
---
>             EntityEntry ee = EntityEntry.builder()
1518,1519c1038,1040
<             assertTrue("tx active?", engine.isTransactionActive());
< 
---
>             if (!engine.isTransactionActive()) {
>                 throw new DatabaseEngineRuntimeException("Transaction should be active");
>             }
1522c1043,1045
<             assertFalse("tx active?", engine.isTransactionActive());
---
>             if (engine.isTransactionActive()) {
>                 throw new DatabaseEngineRuntimeException("Transaction should have been rolled back");
>             }
1524c1047,1049
<             assertEquals("ret 0?", 0, engine.query(select(all()).from(table("TEST"))).size());
---
>             if (engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST"))).size() != 0) {
>                 throw new DatabaseEngineRuntimeException("Table should be empty after rollback");
>             }
1530c1055
<         DbEntity entity = dbEntity()
---
>         DbEntity entity = DbEntity.builder()
1532c1057
<                 .addColumn("COL1", INT, true)
---
>                 .addColumn("COL1", DbColumnType.INT, true)
1539c1064,1066
<         assertNotNull(removeEntity);
---
>         if (removeEntity == null) {
>             throw new DatabaseEngineRuntimeException("Entity removal failed");
>         }
1548c1075,1077
<         assertNull(removeEntity);
---
>         if (removeEntity != null) {
>             throw new DatabaseEngineRuntimeException("Expected null when removing non-existent entity");
>         }
1553d1081
< 
1557c1085
<                 select(all())
---
>                 SqlBuilder.select(SqlBuilder.all())
1559c1087
<                                 table("USER").alias("a").innerJoin(table("USER_ROLE").alias("b"), eq(column("a", "COL1"), column("b", "COL1")))
---
>                                 SqlBuilder.table("USER").alias("a").innerJoin(SqlBuilder.table("USER_ROLE").alias("b"), SqlBuilder.eq(SqlBuilder.column("a", "COL1"), SqlBuilder.column("b", "COL1")))
1564c1092
<                 select(all())
---
>                 SqlBuilder.select(SqlBuilder.all())
1566,1568c1094,1096
<                                 table("USER").alias("a")
<                                         .innerJoin(table("USER_ROLE").alias("b"), eq(column("a", "COL1"), column("b", "COL1")))
<                                         .innerJoin(table("ROLE").alias("c"), eq(column("b", "COL2"), column("c", "COL1")))
---
>                                 SqlBuilder.table("USER").alias("a")
>                                         .innerJoin(SqlBuilder.table("USER_ROLE").alias("b"), SqlBuilder.eq(SqlBuilder.column("a", "COL1"), SqlBuilder.column("b", "COL1")))
>                                         .innerJoin(SqlBuilder.table("ROLE").alias("c"), SqlBuilder.eq(SqlBuilder.column("b", "COL2"), SqlBuilder.column("c", "COL1")))
1573c1101
<                 select(all())
---
>                 SqlBuilder.select(SqlBuilder.all())
1575c1103
<                                 table("USER").alias("a").rightOuterJoin(table("USER_ROLE").alias("b"), eq(column("a", "COL1"), column("b", "COL1")))
---
>                                 SqlBuilder.table("USER").alias("a").rightOuterJoin(SqlBuilder.table("USER_ROLE").alias("b"), SqlBuilder.eq(SqlBuilder.column("a", "COL1"), SqlBuilder.column("b", "COL1")))
1580c1108
<                 select(all())
---
>                 SqlBuilder.select(SqlBuilder.all())
1582c1110
<                                 table("USER").alias("a").leftOuterJoin(table("USER_ROLE").alias("b"), eq(column("a", "COL1"), column("b", "COL1")))
---
>                                 SqlBuilder.table("USER").alias("a").leftOuterJoin(SqlBuilder.table("USER_ROLE").alias("b"), SqlBuilder.eq(SqlBuilder.column("a", "COL1"), SqlBuilder.column("b", "COL1")))
1592c1120
<                 select(all())
---
>                 SqlBuilder.select(SqlBuilder.all())
1594c1122
<                                 table("USER").alias("a")
---
>                                 SqlBuilder.table("USER").alias("a")
1596,1598c1124,1126
<                                                 select(column("COL1"))
<                                                         .from(table("USER")).alias("b")
<                                                 , eq(column("a", "COL1"), column("b", "COL1"))
---
>                                                 SqlBuilder.select(SqlBuilder.column("COL1"))
>                                                         .from(SqlBuilder.table("USER")).alias("b")
>                                                 , SqlBuilder.eq(SqlBuilder.column("a", "COL1"), SqlBuilder.column("b", "COL1"))
1609c1137
<                 select(all())
---
>                 SqlBuilder.select(SqlBuilder.all())
1611,1612c1139,1140
<                                 select(column("COL1"))
<                                         .from(table("USER")).alias("b")
---
>                                 SqlBuilder.select(SqlBuilder.column("COL1"))
>                                         .from(SqlBuilder.table("USER")).alias("b")
1614,1615c1142,1143
<                                                 table("USER").alias("a")
<                                                 , eq(column("a", "COL1"), column("b", "COL1"))
---
>                                                 SqlBuilder.table("USER").alias("a")
>                                                 , SqlBuilder.eq(SqlBuilder.column("a", "COL1"), SqlBuilder.column("b", "COL1"))
1626c1154
<                 select(all())
---
>                 SqlBuilder.select(SqlBuilder.all())
1628,1629c1156,1157
<                                 select(column("COL1"))
<                                         .from(table("USER")).alias("a")
---
>                                 SqlBuilder.select(SqlBuilder.column("COL1"))
>                                         .from(SqlBuilder.table("USER")).alias("a")
1631,1633c1159,1161
<                                                 select(column("COL1"))
<                                                         .from(table("USER")).alias("b")
<                                                 , eq(column("a", "COL1"), column("b", "COL1"))
---
>                                                 SqlBuilder.select(SqlBuilder.column("COL1"))
>                                                         .from(SqlBuilder.table("USER")).alias("b")
>                                                 , SqlBuilder.eq(SqlBuilder.column("a", "COL1"), SqlBuilder.column("b", "COL1"))
1644c1172
<                 select(all())
---
>                 SqlBuilder.select(SqlBuilder.all())
1646,1647c1174,1175
<                                 select(column("COL1"))
<                                         .from(table("USER")).alias("a")
---
>                                 SqlBuilder.select(SqlBuilder.column("COL1"))
>                                         .from(SqlBuilder.table("USER")).alias("a")
1649,1651c1177,1179
<                                                 select(column("COL1"))
<                                                         .from(table("USER")).alias("b")
<                                                 , eq(column("a", "COL1"), column("b", "COL1"))
---
>                                                 SqlBuilder.select(SqlBuilder.column("COL1"))
>                                                         .from(SqlBuilder.table("USER")).alias("b")
>                                                 , SqlBuilder.eq(SqlBuilder.column("a", "COL1"), SqlBuilder.column("b", "COL1"))
1654,1656c1182,1184
<                                                 select(column("COL1"))
<                                                         .from(table("USER")).alias("c")
<                                                 , eq(column("a", "COL1"), column("c", "COL1"))
---
>                                                 SqlBuilder.select(SqlBuilder.column("COL1"))
>                                                         .from(SqlBuilder.table("USER")).alias("c")
>                                                 , SqlBuilder.eq(SqlBuilder.column("a", "COL1"), SqlBuilder.column("c", "COL1"))
1663,1665c1191
<     @Category(SkipTestCockroachDB.class)
<     // unimplemented in CockroachDB: views do not currently support * expressions
<     // https://github.com/cockroachdb/cockroach/issues/10028
---
>     @Category(com.feedzai.commons.sql.abstraction.engine.impl.cockroach.SkipTestCockroachDB.class)
1670c1196
<                 createView("VN").as(select(all()).from(table("TEST")))
---
>                 SqlBuilder.createView("VN").as(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")))
1677,1679c1203
<     @Category(SkipTestCockroachDB.class)
<     // unimplemented in CockroachDB: views do not currently support * expressions
<     // https://github.com/cockroachdb/cockroach/issues/10028
---
>     @Category(com.feedzai.commons.sql.abstraction.engine.impl.cockroach.SkipTestCockroachDB.class)
1684c1208
<                 createView("VN").as(select(all()).from(table("TEST"))).replace()
---
>                 SqlBuilder.createView("VN").as(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST"))).replace()
1695,1696c1219,1220
<                 select(all()).distinct()
<                         .from(table("TEST"))
---
>                 SqlBuilder.select(SqlBuilder.all()).distinct()
>                         .from(SqlBuilder.table("TEST"))
1705,1706c1229,1230
<                 select(all()).distinct()
<                         .from(table("TEST")).limit(2)
---
>                 SqlBuilder.select(SqlBuilder.all()).distinct()
>                         .from(SqlBuilder.table("TEST")).limit(2)
1715,1717c1239,1241
<                 select(all())
<                         .from(table("TEST"))
<                         .where(neq(column("COL1"), k(1)))
---
>                 SqlBuilder.select(SqlBuilder.all())
>                         .from(SqlBuilder.table("TEST"))
>                         .where(SqlBuilder.neq(SqlBuilder.column("COL1"), SqlBuilder.k(1)))
1721,1725d1244
<     /**
<      * Tests that the {@link SqlBuilder#in(Expression, Expression) IN} clause with a value filters a row correctly.
<      *
<      * @throws DatabaseEngineException If a DB error occurs, thus failing the test.
<      */
1728c1247
<         runInClauseTest(in(column("COL1"), L((k(1)))));
---
>         runInClauseTest(SqlBuilder.in(SqlBuilder.column("COL1"), SqlBuilder.L(SqlBuilder.k(1))));
1731,1735d1249
<     /**
<      * Tests that the {@link SqlBuilder#in(Expression, Expression) IN} clause with SELECT filters a row correctly.
<      *
<      * @throws DatabaseEngineException If a DB error occurs, thus failing the test.
<      */
1738,1740c1252,1254
<         runInClauseTest(in(
<                 column("COL1"),
<                 select(column("COL1")).from(table("TEST")).where(eq(column("COL1"), k(1)))
---
>         runInClauseTest(SqlBuilder.in(
>                 SqlBuilder.column("COL1"),
>                 SqlBuilder.select(SqlBuilder.column("COL1")).from(SqlBuilder.table("TEST")).where(SqlBuilder.eq(SqlBuilder.column("COL1"), SqlBuilder.k(1)))
1744,1752d1257
<     /**
<      * Tests that the {@link SqlBuilder#in(Expression, Expression) IN} clause with values filters a row correctly,
<      * when many values are provided.
<      * <p>
<      * This is a regression test for Oracle, which only supports up to 1000 values in IN clauses; the test uses
<      * 20000 values.
<      *
<      * @throws DatabaseEngineException If a DB error occurs, thus failing the test.
<      */
1755c1260
<         final List<Expression> numExprs = IntStream.rangeClosed(-19998, 1)
---
>         final List<SqlBuilder.Expression> numExprs = IntStream.rangeClosed(-19998, 1)
1759c1264
<         runInClauseTest(in(column("COL1"), L(numExprs)));
---
>         runInClauseTest(SqlBuilder.in(SqlBuilder.column("COL1"), SqlBuilder.L(numExprs)));
1762,1767d1266
<     /**
<      * Tests that the {@link SqlBuilder#notIn(Expression, Expression) (Expression, Expression) negated IN} clause
<      * with a value filters a row correctly.
<      *
<      * @throws DatabaseEngineException If a DB error occurs, thus failing the test.
<      */
1770c1269
<         runInClauseTest(notIn(column("COL1"), L((k(2)))));
---
>         runInClauseTest(SqlBuilder.notIn(SqlBuilder.column("COL1"), SqlBuilder.L(SqlBuilder.k(2))));
1773,1777d1271
<     /**
<      * Tests that the {@link SqlBuilder#notIn(Expression, Expression) negated IN} clause with SELECT filters a row correctly.
<      *
<      * @throws DatabaseEngineException If a DB error occurs, thus failing the test.
<      */
1780,1782c1274,1276
<         runInClauseTest(notIn(
<                 column("COL1"),
<                 select(column("COL1")).from(table("TEST")).where(eq(column("COL1"), k(2)))
---
>         runInClauseTest(SqlBuilder.notIn(
>                 SqlBuilder.column("COL1"),
>                 SqlBuilder.select(SqlBuilder.column("COL1")).from(SqlBuilder.table("TEST")).where(SqlBuilder.eq(SqlBuilder.column("COL1"), SqlBuilder.k(2)))
1786,1794d1279
<     /**
<      * Tests that the {@link SqlBuilder#notIn(Expression, Expression) negated IN} clause with a value filters a row
<      * correctly, when many values are provided.
<      * <p>
<      * This is a regression test for Oracle, which only supports up to 1000 values in IN clauses; the test uses
<      * 20000 values.
<      *
<      * @throws DatabaseEngineException If a DB error occurs, thus failing the test.
<      */
1797c1282
<         final List<Expression> numExprs = IntStream.rangeClosed(2, 20001)
---
>         final List<SqlBuilder.Expression> numExprs = IntStream.rangeClosed(2, 20001)
1801c1286
<         runInClauseTest(notIn(column("COL1"), L(numExprs)));
---
>         runInClauseTest(SqlBuilder.notIn(SqlBuilder.column("COL1"), SqlBuilder.L(numExprs)));
1804,1820c1289
<     /**
<      * Common code to run IN clause tests.
<      * <p>
<      * This creates 2 entries in the database:
<      * <table>
<      *     <tr><td>COL1</td><td>COL5</td></tr>
<      *     <tr><td>1</td><td>s1</td></tr>
<      *     <tr><td>2</td><td>s2</td></tr>
<      * </table>
<      * <p>
<      * The verifications expect the provided {@code whereInExpression} to filter the entries such that only the first
<      * one is returned.
<      *
<      * @param whereInExpression The {@link Expression} to use in the WHERE clause of the query.
<      * @throws DatabaseEngineException If a DB error occurs.
<      */
<     private void runInClauseTest(final Expression whereInExpression) throws DatabaseEngineException {
---
>     private void runInClauseTest(final SqlBuilder.Expression whereInExpression) throws DatabaseEngineException {
1823,1824c1292,1293
<         engine.persist("TEST", entry().set("COL1", 1).set("COL5", "s1").build());
<         engine.persist("TEST", entry().set("COL1", 2).set("COL5", "s2").build());
---
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 1).set("COL5", "s1").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 2).set("COL5", "s2").build());
1827,1828c1296,1297
<                 select(all())
<                         .from(table("TEST"))
---
>                 SqlBuilder.select(SqlBuilder.all())
>                         .from(SqlBuilder.table("TEST"))
1832,1838c1301,1303
<         assertThat(results)
<                 .as("query should return only 1 result")
<                 .hasSize(1)
<                 .element(0)
<                 .as("result should have have value '1'")
<                 .extracting(result -> result.get("COL1").toInt())
<                 .isEqualTo(1);
---
>         if (results.size() != 1 || results.get(0).get("COL1").toInt() != 1) {
>             throw new DatabaseEngineRuntimeException("IN clause did not return expected result");
>         }
1845c1310
<         EntityEntry entry1 = entry()
---
>         EntityEntry entry1 = EntityEntry.builder()
1854c1319
<         EntityEntry entry2 = entry()
---
>         EntityEntry entry2 = EntityEntry.builder()
1864,1868c1329,1331
<                 select(all())
<                         .from(table("TEST"))
<                         .where(
<                                 eq(column("COL2"), k(true))
<                         )
---
>                 SqlBuilder.select(SqlBuilder.all())
>                         .from(SqlBuilder.table("TEST"))
>                         .where(SqlBuilder.eq(SqlBuilder.column("COL2"), SqlBuilder.k(true)))
1871c1334,1336
<         assertEquals(1, rows.size());
---
>         if (rows.size() != 1) {
>             throw new DatabaseEngineRuntimeException("Boolean true comparison failed");
>         }
1878c1343
<         EntityEntry entry1 = entry()
---
>         EntityEntry entry1 = EntityEntry.builder()
1887c1352
<         EntityEntry entry2 = entry()
---
>         EntityEntry entry2 = EntityEntry.builder()
1897,1901c1362,1364
<                 select(all())
<                         .from(table("TEST"))
<                         .where(
<                                 eq(column("COL2"), k(false))
<                         )
---
>                 SqlBuilder.select(SqlBuilder.all())
>                         .from(SqlBuilder.table("TEST"))
>                         .where(SqlBuilder.eq(SqlBuilder.column("COL2"), SqlBuilder.k(false)))
1904c1367,1369
<         assertEquals(1, rows.size());
---
>         if (rows.size() != 1) {
>             throw new DatabaseEngineRuntimeException("Boolean false comparison failed");
>         }
1912,1916c1377,1379
<                 select(all())
<                         .from(table("TEST"))
<                         .where(
<                                 eq(coalesce(column("COL2"), k(false)), k(false))
<                         )
---
>                 SqlBuilder.select(SqlBuilder.all())
>                         .from(SqlBuilder.table("TEST"))
>                         .where(SqlBuilder.eq(SqlBuilder.coalesce(SqlBuilder.column("COL2"), SqlBuilder.k(false)), SqlBuilder.k(false)))
1925,1929c1388,1390
<                 select(all())
<                         .from(table("TEST"))
<                         .where(
<                                 eq(coalesce(column("COL2"), k(false), k(true)), k(false))
<                         )
---
>                 SqlBuilder.select(SqlBuilder.all())
>                         .from(SqlBuilder.table("TEST"))
>                         .where(SqlBuilder.eq(SqlBuilder.coalesce(SqlBuilder.column("COL2"), SqlBuilder.k(false), SqlBuilder.k(true)), SqlBuilder.k(false)))
1938,1942c1399,1401
<                 select(all())
<                         .from(table("TEST"))
<                         .where(
<                                 between(column("COL1"), k(1), k(2))
<                         )
---
>                 SqlBuilder.select(SqlBuilder.all())
>                         .from(SqlBuilder.table("TEST"))
>                         .where(SqlBuilder.between(SqlBuilder.column("COL1"), SqlBuilder.k(1), SqlBuilder.k(2)))
1946,1947d1404
< 
< 
1951,1956c1408,1413
<         final Query query = select(
<                 cast(k("22"), INT).alias("int"),
<                 cast(k(22), STRING).alias("string"),
<                 cast(k("1"), BOOLEAN).alias("bool"),
<                 cast(k("22"), DOUBLE).alias("double"),
<                 cast(k(22), LONG).alias("long")
---
>         final Query query = SqlBuilder.select(
>                 SqlBuilder.cast(SqlBuilder.k("22"), DbColumnType.INT).alias("int"),
>                 SqlBuilder.cast(SqlBuilder.k(22), DbColumnType.STRING).alias("string"),
>                 SqlBuilder.cast(SqlBuilder.k("1"), DbColumnType.BOOLEAN).alias("bool"),
>                 SqlBuilder.cast(SqlBuilder.k("22"), DbColumnType.DOUBLE).alias("double"),
>                 SqlBuilder.cast(SqlBuilder.k(22), DbColumnType.LONG).alias("long")
1961,1965c1418,1432
<         assertEquals("Result must be 22", new Integer(22), result.get("int").toInt());
<         assertEquals("Result must be '22'", "22", result.get("string").toString());
<         assertEquals("Result must be true", true, result.get("bool").toBoolean());
<         assertEquals("Result must be 22.0", new Double(22), result.get("double").toDouble());
<         assertEquals("Result must be 22", new Long(22), result.get("long").toLong());
---
>         if (!new Integer(22).equals(result.get("int").toInt())) {
>             throw new DatabaseEngineRuntimeException("Cast to int failed");
>         }
>         if (!"22".equals(result.get("string").toString())) {
>             throw new DatabaseEngineRuntimeException("Cast to string failed");
>         }
>         if (!Boolean.TRUE.equals(result.get("bool").toBoolean())) {
>             throw new DatabaseEngineRuntimeException("Cast to boolean failed");
>         }
>         if (!new Double(22).equals(result.get("double").toDouble())) {
>             throw new DatabaseEngineRuntimeException("Cast to double failed");
>         }
>         if (!new Long(22).equals(result.get("long").toLong())) {
>             throw new DatabaseEngineRuntimeException("Cast to long failed");
>         }
1971c1438
<         final DbEntity entity = dbEntity()
---
>         final DbEntity entity = DbEntity.builder()
1973,1976c1440,1443
<                 .addColumn("COL_INT", INT)
<                 .addColumn("COL_STRING", STRING)
<                 .addColumn("COL_CAST_INT", INT)
<                 .addColumn("COL_CAST_STRING", STRING)
---
>                 .addColumn("COL_INT", DbColumnType.INT)
>                 .addColumn("COL_STRING", DbColumnType.STRING)
>                 .addColumn("COL_CAST_INT", DbColumnType.INT)
>                 .addColumn("COL_CAST_STRING", DbColumnType.STRING)
1982c1449
<         EntityEntry entry = entry()
---
>         EntityEntry entry = EntityEntry.builder()
1989,1993c1456,1461
<         // test CAST when writing values
<         final Update update = update(table("TEST"))
<                 .set(eq(column("COL_CAST_INT"), cast(k("3211"), INT)),
<                         eq(column("COL_CAST_STRING"), cast(k(1233), STRING)))
<                 .where(eq(column("COL_INT"), k(123)));
---
>         final Update update = Update.builder()
>                 .table(SqlBuilder.table("TEST"))
>                 .set(SqlBuilder.eq(SqlBuilder.column("COL_CAST_INT"), SqlBuilder.cast(SqlBuilder.k("3211"), DbColumnType.INT)),
>                      SqlBuilder.eq(SqlBuilder.column("COL_CAST_STRING"), SqlBuilder.cast(SqlBuilder.k(1233), DbColumnType.STRING)))
>                 .where(SqlBuilder.eq(SqlBuilder.column("COL_INT"), SqlBuilder.k(123)))
>                 .build();
1997d1464
<         // test CAST when reading values
1999,2004c1466,1471
<                 select(
<                         cast(column("COL_INT"), STRING).alias("COL_INT_string"),
<                         cast(column("COL_STRING"), INT).alias("COL_STRING_int"),
<                         column("COL_CAST_INT"),
<                         column("COL_CAST_STRING")
<                 ).from(table("TEST"));
---
>                 SqlBuilder.select(
>                         SqlBuilder.cast(SqlBuilder.column("COL_INT"), DbColumnType.STRING).alias("COL_INT_string"),
>                         SqlBuilder.cast(SqlBuilder.column("COL_STRING"), DbColumnType.INT).alias("COL_STRING_int"),
>                         SqlBuilder.column("COL_CAST_INT"),
>                         SqlBuilder.column("COL_CAST_STRING")
>                 ).from(SqlBuilder.table("TEST"));
2008,2020c1475,1488
<         assertEquals("The value of COL_INT cast to string must be '123'", "123", result.get("COL_INT_string").toString());
<         assertEquals("The value of COL_STRING cast to int must be 321", new Integer(321), result.get("COL_STRING_int").toInt());
<         assertEquals("The value of COL_CAST_INT must be 3211", Integer.valueOf(3211), result.get("COL_CAST_INT").toInt());
<         assertEquals("The value of COL_CAST_STRING must be '1233'", "1233", result.get("COL_CAST_STRING").toString());
< 
<         /*
<          Until now the test only really checks if the CAST doesn't cause any errors because
<           - when writing values into the DB it automatically casts into the column data type
<           - when reading values from the DB, the test reads the results from the ResultColumn as the desired type
<          Even if we used a function, it is likely the DB would try to cast the parameters to the expected type.
<          To effectively test if CAST works, we need to check if DB sorting considers the column a string or a number.
<          */
<         entry = entry()
---
>         if (!"123".equals(result.get("COL_INT_string").toString())) {
>             throw new DatabaseEngineRuntimeException("Cast of COL_INT to string failed");
>         }
>         if (!new Integer(321).equals(result.get("COL_STRING_int").toInt())) {
>             throw new DatabaseEngineRuntimeException("Cast of COL_STRING to int failed");
>         }
>         if (!new Integer(3211).equals(result.get("COL_CAST_INT").toInt())) {
>             throw new DatabaseEngineRuntimeException("COL_CAST_INT value incorrect");
>         }
>         if (!"1233".equals(result.get("COL_CAST_STRING").toString())) {
>             throw new DatabaseEngineRuntimeException("COL_CAST_STRING value incorrect");
>         }
> 
>         entry = EntityEntry.builder()
2027c1495,1497
<         query = select(column("COL_INT")).from(table("TEST")).orderby(column("COL_INT"));
---
>         query = SqlBuilder.select(SqlBuilder.column("COL_INT"))
>                 .from(SqlBuilder.table("TEST"))
>                 .orderby(SqlBuilder.column("COL_INT"));
2029c1499,1501
<         assertEquals("sorting should have considered the sort column as a number (123 < 1000)", "123", firstResult);
---
>         if (!"123".equals(firstResult)) {
>             throw new DatabaseEngineRuntimeException("Numeric sort failed");
>         }
2031,2033c1503,1505
<         query = select(column("COL_INT"), cast(column("COL_INT"), STRING).alias("COL_INT_string"))
<                 .from(table("TEST"))
<                 .orderby(column("COL_INT_string"));
---
>         query = SqlBuilder.select(SqlBuilder.column("COL_INT"), SqlBuilder.cast(SqlBuilder.column("COL_INT"), DbColumnType.STRING).alias("COL_INT_string"))
>                 .from(SqlBuilder.table("TEST"))
>                 .orderby(SqlBuilder.column("COL_INT_string"));
2035c1507,1509
<         assertEquals("sorting should have considered the sort column as a string (1000 < 123)", "1000", firstResult);
---
>         if (!"1000".equals(firstResult)) {
>             throw new DatabaseEngineRuntimeException("String sort failed");
>         }
2038,2042d1511
<     /**
<      * Check if exception is thrown when trying to cast for an unsupported type.
<      *
<      * @throws DatabaseEngineException If something goes wrong executing the query.
<      */
2045c1514
<         engine.query(select(cast(k("22"), BLOB)));
---
>         engine.query(SqlBuilder.select(SqlBuilder.cast(SqlBuilder.k("22"), DbColumnType.BLOB)));
2050c1519,1521
<         assumeFalse("MySQL doesn't support WITH", engine.getDialect() == Dialect.MYSQL);
---
>         if (engine.getDialect() == SqlBuilder.Dialect.MYSQL) {
>             return;
>         }
2054,2061c1525,1528
<         engine.persist("TEST", entry().set("COL1", 1).set("COL5", "manuel")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 2).set("COL5", "ana")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 3).set("COL5", "rita")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 4).set("COL5", "rui")
<                 .build());
---
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 1).set("COL5", "manuel").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 2).set("COL5", "ana").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 3).set("COL5", "rita").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 4).set("COL5", "rui").build());
2063,2064c1530
<         final With with = with("friends", select(all())
<                                                 .from(table("TEST")))
---
>         final With with = With.builder("friends", SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")))
2066,2068c1532,1535
<                         select(column("COL5").alias("name"))
<                         .from(table("friends"))
<                         .where(eq(column("COL1"), k(1))));
---
>                         SqlBuilder.select(SqlBuilder.column("COL5").alias("name"))
>                         .from(SqlBuilder.table("friends"))
>                         .where(SqlBuilder.eq(SqlBuilder.column("COL1"), SqlBuilder.k(1)))
>                 ).build();
2072c1539,1541
<         assertEquals("Name must be 'manuel'", "manuel", result.get(0).get("name").toString());
---
>         if (!"manuel".equals(result.get(0).get("name").toString())) {
>             throw new DatabaseEngineRuntimeException("WITH query returned unexpected result");
>         }
2077c1546,1548
<         assumeFalse("MySQL doesn't support WITH", engine.getDialect() == Dialect.MYSQL);
---
>         if (engine.getDialect() == SqlBuilder.Dialect.MYSQL) {
>             return;
>         }
2081,2088c1552,1555
<         engine.persist("TEST", entry().set("COL1", 1).set("COL5", "manuel")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 2).set("COL5", "ana")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 3).set("COL5", "rita")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 4).set("COL5", "rui")
<                 .build());
---
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 1).set("COL5", "manuel").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 2).set("COL5", "ana").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 3).set("COL5", "rita").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 4).set("COL5", "rui").build());
2091,2093c1558
<                 with("friends",
<                         select(all())
<                         .from(table("TEST")))
---
>                 With.builder("friends", SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")))
2095,2097c1560,1563
<                         select(column("COL5").alias("name"))
<                         .from(table("friends"))
<                         .orderby(column("COL5")));
---
>                         SqlBuilder.select(SqlBuilder.column("COL5").alias("name"))
>                         .from(SqlBuilder.table("friends"))
>                         .orderby(SqlBuilder.column("COL5"))
>                 ).build();
2101,2104c1567,1572
<         assertEquals("Name must be 'ana'", "ana", result.get(0).get("name").toString());
<         assertEquals("Name must be 'manuel'", "manuel", result.get(1).get("name").toString());
<         assertEquals("Name must be 'rita'", "rita", result.get(2).get("name").toString());
<         assertEquals("Name must be 'rui'", "rui", result.get(3).get("name").toString());
---
>         if (!"ana".equals(result.get(0).get("name").toString()) ||
>             !"manuel".equals(result.get(1).get("name").toString()) ||
>             !"rita".equals(result.get(2).get("name").toString()) ||
>             !"rui".equals(result.get(3).get("name").toString())) {
>             throw new DatabaseEngineRuntimeException("WITH all query returned unexpected order");
>         }
2109c1577,1579
<         assumeFalse("MySQL doesn't support WITH", engine.getDialect() == Dialect.MYSQL);
---
>         if (engine.getDialect() == SqlBuilder.Dialect.MYSQL) {
>             return;
>         }
2113,2120c1583,1586
<         engine.persist("TEST", entry().set("COL1", 1).set("COL5", "manuel")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 2).set("COL5", "ana")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 3).set("COL5", "rita")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 4).set("COL5", "rui")
<                 .build());
---
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 1).set("COL5", "manuel").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 2).set("COL5", "ana").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 3).set("COL5", "rita").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 4).set("COL5", "rui").build());
2123,2127c1589,1592
<                 with("friendsA",
<                         select(all())
<                         .from(table("TEST"))
<                         .where(or(eq(column("COL1"), k(1)), eq(column("COL1"), k(2)))))
< 
---
>                 With.builder("friendsA",
>                         SqlBuilder.select(SqlBuilder.all())
>                         .from(SqlBuilder.table("TEST"))
>                         .where(SqlBuilder.or(SqlBuilder.eq(SqlBuilder.column("COL1"), SqlBuilder.k(1)), SqlBuilder.eq(SqlBuilder.column("COL1"), SqlBuilder.k(2)))))
2129,2131c1594,1596
<                         select(all())
<                         .from(table("TEST"))
<                         .where(or(eq(column("COL1"), k(3)), eq(column("COL1"), k(4)))))
---
>                         SqlBuilder.select(SqlBuilder.all())
>                         .from(SqlBuilder.table("TEST"))
>                         .where(SqlBuilder.or(SqlBuilder.eq(SqlBuilder.column("COL1"), SqlBuilder.k(3)), SqlBuilder.eq(SqlBuilder.column("COL1"), SqlBuilder.k(4)))))
2133,2134c1598,1600
<                         union(select(all()).from(table("friendsA")),
<                               select(all()).from(table("friendsB"))));
---
>                         SqlBuilder.union(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("friendsA")),
>                                          SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("friendsB")))
>                 ).build();
2143,2146c1609,1614
<         assertEquals("Name must be 'ana'", "ana", resultSorted.get(0));
<         assertEquals("Name must be 'manuel'", "manuel", resultSorted.get(1));
<         assertEquals("Name must be 'rita'", "rita", resultSorted.get(2));
<         assertEquals("Name must be 'rui'", "rui", resultSorted.get(3));
---
>         if (!"ana".equals(resultSorted.get(0)) ||
>             !"manuel".equals(resultSorted.get(1)) ||
>             !"rita".equals(resultSorted.get(2)) ||
>             !"rui".equals(resultSorted.get(3))) {
>             throw new DatabaseEngineRuntimeException("Union query returned unexpected results");
>         }
2153,2160c1621,1624
<         engine.persist("TEST", entry().set("COL1", 1).set("COL5", "teste")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 2).set("COL5", "xpto")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 3).set("COL5", "xpto")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 4).set("COL5", "teste")
<                 .build());
---
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 1).set("COL5", "teste").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 2).set("COL5", "xpto").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 3).set("COL5", "xpto").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 4).set("COL5", "teste").build());
2163,2164c1627,1628
<                 select(caseWhen().when(eq(column("COL5"), k("teste")), k("LOL")).alias("case"))
<                         .from(table("TEST")));
---
>                 SqlBuilder.select(SqlBuilder.caseWhen().when(SqlBuilder.eq(SqlBuilder.column("COL5"), SqlBuilder.k("teste")), SqlBuilder.k("LOL")).alias("case"))
>                         .from(SqlBuilder.table("TEST")));
2166,2167c1630,1633
<         assertEquals("COL5 must be LOL", "LOL", result.get(0).get("case").toString());
<         assertEquals("COL5 must be LOL", "LOL", result.get(3).get("case").toString());
---
>         if (!"LOL".equals(result.get(0).get("case").toString()) || 
>             !"LOL".equals(result.get(3).get("case").toString())) {
>             throw new DatabaseEngineRuntimeException("CASE WHEN query returned unexpected result");
>         }
2173,2180c1639,1642
<         engine.persist("TEST", entry().set("COL1", 1).set("COL5", "teste")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 2).set("COL5", "xpto")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 3).set("COL5", "xpto")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 4).set("COL5", "teste")
<                 .build());
---
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 1).set("COL5", "teste").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 2).set("COL5", "xpto").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 3).set("COL5", "xpto").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 4).set("COL5", "teste").build());
2183,2185c1645,1647
<                 select(caseWhen().when(eq(column("COL5"), k("teste")), k("LOL"))
<                                .otherwise(k("ROFL")).alias("case"))
<                         .from(table("TEST"))
---
>                 SqlBuilder.select(SqlBuilder.caseWhen().when(SqlBuilder.eq(SqlBuilder.column("COL5"), SqlBuilder.k("teste")), SqlBuilder.k("LOL"))
>                                 .otherwise(SqlBuilder.k("ROFL")).alias("case"))
>                         .from(SqlBuilder.table("TEST"))
2188,2191c1650,1655
<         assertEquals("COL5 must be LOL", "LOL", result.get(0).get("case").toString());
<         assertEquals("COL5 must be ROFL", "ROFL", result.get(1).get("case").toString());
<         assertEquals("COL5 must be ROFL", "ROFL", result.get(2).get("case").toString());
<         assertEquals("COL5 must be LOL", "LOL", result.get(3).get("case").toString());
---
>         if (!"LOL".equals(result.get(0).get("case").toString()) ||
>             !"ROFL".equals(result.get(1).get("case").toString()) ||
>             !"ROFL".equals(result.get(2).get("case").toString()) ||
>             !"LOL".equals(result.get(3).get("case").toString())) {
>             throw new DatabaseEngineRuntimeException("CASE WHEN ELSE query returned unexpected results");
>         }
2197,2206c1661,1665
<         engine.persist("TEST", entry().set("COL1", 1).set("COL5", "teste")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 2).set("COL5", "xpto")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 3).set("COL5", "xpto")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 4).set("COL5", "teste")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 5).set("COL5", "pomme de terre")
<                 .build());
---
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 1).set("COL5", "teste").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 2).set("COL5", "xpto").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 3).set("COL5", "xpto").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 4).set("COL5", "teste").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 5).set("COL5", "pomme de terre").build());
2209,2212c1668,1671
<                 select(caseWhen().when(eq(column("COL5"), k("teste")), k("LOL"))
<                                 .when(eq(column("COL5"), k("pomme de terre")), k("KEK"))
<                                 .otherwise(k("ROFL")).alias("case"))
<                         .from(table("TEST"))
---
>                 SqlBuilder.select(SqlBuilder.caseWhen().when(SqlBuilder.eq(SqlBuilder.column("COL5"), SqlBuilder.k("teste")), SqlBuilder.k("LOL"))
>                                 .when(SqlBuilder.eq(SqlBuilder.column("COL5"), SqlBuilder.k("pomme de terre")), SqlBuilder.k("KEK"))
>                                 .otherwise(SqlBuilder.k("ROFL")).alias("case"))
>                         .from(SqlBuilder.table("TEST"))
2215,2219c1674,1680
<         assertEquals("COL5 must be LOL", "LOL", result.get(0).get("case").toString());
<         assertEquals("COL5 must be ROFL", "ROFL", result.get(1).get("case").toString());
<         assertEquals("COL5 must be ROFL", "ROFL", result.get(2).get("case").toString());
<         assertEquals("COL5 must be LOL", "LOL", result.get(3).get("case").toString());
<         assertEquals("COL5 must be KEK", "KEK", result.get(4).get("case").toString());
---
>         if (!"LOL".equals(result.get(0).get("case").toString()) ||
>             !"ROFL".equals(result.get(1).get("case").toString()) ||
>             !"ROFL".equals(result.get(2).get("case").toString()) ||
>             !"LOL".equals(result.get(3).get("case").toString()) ||
>             !"KEK".equals(result.get(4).get("case").toString())) {
>             throw new DatabaseEngineRuntimeException("Multiple CASE WHEN query returned unexpected result");
>         }
2224c1685
<         final List<Map<String, ResultColumn>> result = queryConcat(k("."));
---
>         final List<Map<String, ResultColumn>> result = queryConcat(SqlBuilder.k("."));
2226,2230c1687,1693
<         assertEquals("teste.teste", result.get(0).get("concat").toString());
<         assertEquals("xpto.xpto", result.get(1).get("concat").toString());
<         assertEquals("xpto.xpto", result.get(2).get("concat").toString());
<         assertEquals("teste.teste", result.get(3).get("concat").toString());
<         assertEquals("pomme de terre.pomme de terre", result.get(4).get("concat").toString());
---
>         if (!"teste.teste".equals(result.get(0).get("concat").toString()) ||
>             !"xpto.xpto".equals(result.get(1).get("concat").toString()) ||
>             !"xpto.xpto".equals(result.get(2).get("concat").toString()) ||
>             !"teste.teste".equals(result.get(3).get("concat").toString()) ||
>             !"pomme de terre.pomme de terre".equals(result.get(4).get("concat").toString())) {
>             throw new DatabaseEngineRuntimeException("Concat query returned incorrect values");
>         }
2235c1698
<         final List<Map<String, ResultColumn>> result = queryConcat(k(""));
---
>         final List<Map<String, ResultColumn>> result = queryConcat(SqlBuilder.k(""));
2237,2241c1700,1706
<         assertEquals("testeteste", result.get(0).get("concat").toString());
<         assertEquals("xptoxpto", result.get(1).get("concat").toString());
<         assertEquals("xptoxpto", result.get(2).get("concat").toString());
<         assertEquals("testeteste", result.get(3).get("concat").toString());
<         assertEquals("pomme de terrepomme de terre", result.get(4).get("concat").toString());
---
>         if (!"testeteste".equals(result.get(0).get("concat").toString()) ||
>             !"xptoxpto".equals(result.get(1).get("concat").toString()) ||
>             !"xptoxpto".equals(result.get(2).get("concat").toString()) ||
>             !"testeteste".equals(result.get(3).get("concat").toString()) ||
>             !"pomme de terrepomme de terre".equals(result.get(4).get("concat").toString())) {
>             throw new DatabaseEngineRuntimeException("Concat empty query returned incorrect values");
>         }
2246c1711
<         final Query query = select(concat(k(","), k("lol"), k(null), k("rofl")).alias("concat"));
---
>         final Query query = SqlBuilder.select(SqlBuilder.concat(SqlBuilder.k(","), SqlBuilder.k("lol"), SqlBuilder.k(null), SqlBuilder.k("rofl")).alias("concat"));
2248c1713,1715
<         assertEquals("lol,rofl", result.get(0).get("concat").toString());
---
>         if (!"lol,rofl".equals(result.get(0).get("concat").toString())) {
>             throw new DatabaseEngineRuntimeException("Concat with null expressions returned incorrect value");
>         }
2253c1720
<         final Query query = select(concat(k(null), k("lol"), k("nop"), k("rofl")).alias("concat"));
---
>         final Query query = SqlBuilder.select(SqlBuilder.concat(SqlBuilder.k(null), SqlBuilder.k("lol"), SqlBuilder.k("nop"), SqlBuilder.k("rofl")).alias("concat"));
2255c1722,1724
<         assertEquals("lolnoprofl", result.get(0).get("concat").toString());
---
>         if (!"lolnoprofl".equals(result.get(0).get("concat").toString())) {
>             throw new DatabaseEngineRuntimeException("Concat with null delimiter returned incorrect value");
>         }
2260c1729
<         final List<Map<String, ResultColumn>> result = queryConcat(column("COL2"));
---
>         final List<Map<String, ResultColumn>> result = queryConcat(SqlBuilder.column("COL2"));
2262,2266c1731,1737
<         assertEquals("testetesteteste", result.get(0).get("concat").toString());
<         assertEquals("xptoxptoxpto", result.get(1).get("concat").toString());
<         assertEquals("xptoxptoxpto", result.get(2).get("concat").toString());
<         assertEquals("testetesteteste", result.get(3).get("concat").toString());
<         assertEquals("pomme de terrepomme de terrepomme de terre", result.get(4).get("concat").toString());
---
>         if (!"testetesteteste".equals(result.get(0).get("concat").toString()) ||
>             !"xptoxptoxpto".equals(result.get(1).get("concat").toString()) ||
>             !"xptoxptoxpto".equals(result.get(2).get("concat").toString()) ||
>             !"testetesteteste".equals(result.get(3).get("concat").toString()) ||
>             !"pomme de terrepomme de terrepomme de terre".equals(result.get(4).get("concat").toString())) {
>             throw new DatabaseEngineRuntimeException("Concat column query returned incorrect value");
>         }
2269,2277c1740,1741
<     /**
<      * Runs a concat query on the test dataset, given a delimiter.
<      *
<      * @param delimiter the delimiter used in concat.
<      * @return the result set.
<      * @throws DatabaseEngineException if an issue when querying arises.
<      */
<     private List<Map<String, ResultColumn>> queryConcat(final Expression delimiter) throws DatabaseEngineException {
<         final DbEntity entity = dbEntity()
---
>     private List<Map<String, ResultColumn>> queryConcat(final SqlBuilder.Expression delimiter) throws DatabaseEngineException {
>         final DbEntity entity = DbEntity.builder()
2279,2281c1743,1745
<                 .addColumn("COL1", INT)
<                 .addColumn("COL2", STRING)
<                 .addColumn("COL3", STRING)
---
>                 .addColumn("COL1", DbColumnType.INT)
>                 .addColumn("COL2", DbColumnType.STRING)
>                 .addColumn("COL3", DbColumnType.STRING)
2286,2297c1750,1755
<         engine.persist("TEST", entry().set("COL1", 1).set("COL2", "teste").set("COL3", "teste").build());
<         engine.persist("TEST", entry().set("COL1", 2).set("COL2", "xpto").set("COL3", "xpto").build());
<         engine.persist("TEST", entry().set("COL1", 3).set("COL2", "xpto").set("COL3", "xpto").build());
<         engine.persist("TEST", entry().set("COL1", 4).set("COL2", "teste").set("COL3", "teste").build());
<         engine.persist(
<                 "TEST",
<                 entry().set("COL1", 5).set("COL2", "pomme de terre").set("COL3", "pomme de terre").build()
<         );
<         engine.persist(
<                 "TEST",
<                 entry().set("COL1", 6).set("COL2", "lol").set("COL3", null).build()
<         );
---
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 1).set("COL2", "teste").set("COL3", "teste").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 2).set("COL2", "xpto").set("COL3", "xpto").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 3).set("COL2", "xpto").set("COL3", "xpto").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 4).set("COL2", "teste").set("COL3", "teste").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 5).set("COL2", "pomme de terre").set("COL3", "pomme de terre").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 6).set("COL2", "lol").set("COL3", null).build());
2299,2302c1757,1758
<         final Query query =
<                 select(
<                         concat(delimiter, column("COL2"), column("COL3")).alias("concat"))
<                 .from(table("TEST"));
---
>         final Query query = SqlBuilder.select(SqlBuilder.concat(delimiter, SqlBuilder.column("COL2"), SqlBuilder.column("COL3")).alias("concat"))
>                 .from(SqlBuilder.table("TEST"));
2307,2322d1762
<     /**
<      * Reproduces an issue when using CASE ... WHEN expressions in SqlServer and MySql.
<      * <p>
<      * Since we don't have the type information for a column that is generated from the result of a WHEN expression,
<      * we need to rely on the user calling one of the ResultColumn.toXXX methods to understand what the user is
<      * expecting. In the case of ResultColumn.toBoolean(), we're first checking if the result is of boolean type,
<      * as happens normally when the driver knows that the column is of type boolean, but then we also try to parse the
<      * underlying database boolean representation. This is necessary because in WHEN expressions, the driver doesn't
<      * know the expected return type.
<      * <p>
<      * I also tried to fix this using {@code cast(1 as BIT)}, which seemed more appropriate because we would be hinting
<      * the driver about the type, but it's not possible to follow this approach in MySql because we cannot cast to
<      * tinyint(1), which is the native type for booleans in MySql.
<      *
<      * @throws DatabaseEngineException propagate
<      */
2326,2327c1766,1767
<         engine.persist("TEST", entry().set("COL1", 1).set("COL2", false).build());
<         engine.persist("TEST", entry().set("COL1", 2).set("COL2", true).set("COL5", "xpto").build());
---
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 1).set("COL2", false).build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 2).set("COL2", true).set("COL5", "xpto").build());
2329,2336c1769,1772
<         final Query query = select(
<                 column("COL2"),
<                 caseWhen()
<                         .when(column("COL5").isNotNull(), k(true))
<                         .otherwise(k(false))
<                         .alias("COL5_NOT_NULL"))
<                 .from(table("TEST"))
<                 .orderby(column("COL1").asc());
---
>         final Query query = SqlBuilder.select(SqlBuilder.column("COL2"),
>                 SqlBuilder.caseWhen().when(SqlBuilder.column("COL5").isNotNull(), SqlBuilder.k(true)).otherwise(SqlBuilder.k(false)).alias("COL5_NOT_NULL"))
>                 .from(SqlBuilder.table("TEST"))
>                 .orderby(SqlBuilder.column("COL1").asc());
2340,2343c1776,1781
<         assertFalse("COL2 should be false", result.get(0).get("COL2").toBoolean());
<         assertFalse("COL5_NOT_NULL should be false", result.get(0).get("COL5_NOT_NULL").toBoolean());
<         assertTrue("COL2 should be true", result.get(1).get("COL2").toBoolean());
<         assertTrue("COL5_NOT_NULL should be true", result.get(1).get("COL5_NOT_NULL").toBoolean());
---
>         if (result.get(0).get("COL2").toBoolean() ||
>             result.get(0).get("COL5_NOT_NULL").toBoolean() ||
>             !result.get(1).get("COL2").toBoolean() ||
>             !result.get(1).get("COL5_NOT_NULL").toBoolean()) {
>             throw new DatabaseEngineRuntimeException("CASE to boolean conversion failed");
>         }
2349,2358c1787,1791
<         engine.persist("TEST", entry().set("COL1", 1).set("COL5", "a")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 2).set("COL5", "b")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 3).set("COL5", "c")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 4).set("COL5", "d")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 5).set("COL5", "d")
<                 .build());
---
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 1).set("COL5", "a").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 2).set("COL5", "b").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 3).set("COL5", "c").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 4).set("COL5", "d").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 5).set("COL5", "d").build());
2361,2365c1794,1797
<         final Collection<Expression> queries = Arrays.stream(letters)
<                 .map(literal ->
<                         select(column("COL5"))
<                         .from(table("TEST"))
<                         .where(eq(column("COL5"), k(literal))))
---
>         final Collection<SqlBuilder.Expression> queries = Arrays.stream(letters)
>                 .map(literal -> SqlBuilder.select(SqlBuilder.column("COL5"))
>                         .from(SqlBuilder.table("TEST"))
>                         .where(SqlBuilder.eq(SqlBuilder.column("COL5"), SqlBuilder.k(literal))))
2368c1800
<         final Expression query = union(queries);
---
>         final SqlBuilder.Expression query = SqlBuilder.union(queries);
2371c1803,1805
<         assertEquals("Must return 4 results due to distinct property", 4, result.size());
---
>         if (result.size() != 4) {
>             throw new DatabaseEngineRuntimeException("Union query did not return distinct results as expected");
>         }
2378,2381c1812,1817
<         assertEquals("COL5 must be a", "a", resultSorted.get(0));
<         assertEquals("COL5 must be b", "b", resultSorted.get(1));
<         assertEquals("COL5 must be c", "c", resultSorted.get(2));
<         assertEquals("COL5 must be d", "d", resultSorted.get(3));
---
>         if (!"a".equals(resultSorted.get(0)) ||
>             !"b".equals(resultSorted.get(1)) ||
>             !"c".equals(resultSorted.get(2)) ||
>             !"d".equals(resultSorted.get(3))) {
>             throw new DatabaseEngineRuntimeException("Union query results incorrect");
>         }
2387,2396c1823,1827
<         engine.persist("TEST", entry().set("COL1", 1).set("COL5", "a")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 2).set("COL5", "b")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 3).set("COL5", "c")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 4).set("COL5", "d")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 5).set("COL5", "d")
<                 .build());
---
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 1).set("COL5", "a").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 2).set("COL5", "b").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 3).set("COL5", "c").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 4).set("COL5", "d").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 5).set("COL5", "d").build());
2399c1830
<         final Collection<Expression> queries = Arrays.stream(ids)
---
>         final Collection<SqlBuilder.Expression> queries = Arrays.stream(ids)
2401,2403c1832,1834
<                         select(column("COL5"))
<                         .from(table("TEST"))
<                         .where(eq(column("COL1"), k(literal))))
---
>                         SqlBuilder.select(SqlBuilder.column("COL5"))
>                         .from(SqlBuilder.table("TEST"))
>                         .where(SqlBuilder.eq(SqlBuilder.column("COL1"), SqlBuilder.k(literal))))
2406c1837
<         final Expression query = union(queries).all();
---
>         final SqlBuilder.Expression query = SqlBuilder.union(queries).all();
2409c1840,1842
<         assertEquals("Must return 5 results", 5, result.size());
---
>         if (result.size() != 5) {
>             throw new DatabaseEngineRuntimeException("Union all did not return all records");
>         }
2416,2420c1849,1855
<         assertEquals("COL5 must be a", "a", resultSorted.get(0));
<         assertEquals("COL5 must be b", "b", resultSorted.get(1));
<         assertEquals("COL5 must be c", "c", resultSorted.get(2));
<         assertEquals("COL5 must be d", "d", resultSorted.get(3));
<         assertEquals("COL5 must be d", "d", resultSorted.get(4));
---
>         if (!"a".equals(resultSorted.get(0)) ||
>             !"b".equals(resultSorted.get(1)) ||
>             !"c".equals(resultSorted.get(2)) ||
>             !"d".equals(resultSorted.get(3)) ||
>             !"d".equals(resultSorted.get(4))) {
>             throw new DatabaseEngineRuntimeException("Union all results incorrect");
>         }
2426,2430c1861,1866
<                 values("id", "name")
<                     .row(k(1), k("ana"))
<                     .row(k(2), k("fred"))
<                     .row(k(3), k("manuel"))
<                     .row(k(4), k("rita"));
---
>                 Values.builder("id", "name")
>                     .row(SqlBuilder.k(1), SqlBuilder.k("ana"))
>                     .row(SqlBuilder.k(2), SqlBuilder.k("fred"))
>                     .row(SqlBuilder.k(3), SqlBuilder.k("manuel"))
>                     .row(SqlBuilder.k(4), SqlBuilder.k("rita"))
>                     .build();
2444,2452c1880,1885
<         assertEquals("id must be 1", new Integer(1), ids.get(0));
<         assertEquals("id must be 2", new Integer(2), ids.get(1));
<         assertEquals("id must be 3", new Integer(3), ids.get(2));
<         assertEquals("id must be 4", new Integer(4), ids.get(3));
< 
<         assertEquals("name must be 'ana'", "ana", names.get(0));
<         assertEquals("name must be 'fred'", "fred", names.get(1));
<         assertEquals("name must be 'manuel'", "manuel", names.get(2));
<         assertEquals("name must be 'rita'", "rita", names.get(3));
---
>         if (!(ids.get(0) == 1 && ids.get(1) == 2 && ids.get(2) == 3 && ids.get(3) == 4)) {
>             throw new DatabaseEngineRuntimeException("Values query ids incorrect");
>         }
>         if (!("ana".equals(names.get(0)) && "fred".equals(names.get(1)) && "manuel".equals(names.get(2)) && "rita".equals(names.get(3)))) {
>             throw new DatabaseEngineRuntimeException("Values query names incorrect");
>         }
2458,2462c1891,1896
<                 values()
<                     .row(k(1), k("ana"))
<                     .row(k(2), k("fred"))
<                     .row(k(3), k("manuel"))
<                     .row(k(4), k("rita"));
---
>                 Values.builder()
>                     .row(SqlBuilder.k(1), SqlBuilder.k("ana"))
>                     .row(SqlBuilder.k(2), SqlBuilder.k("fred"))
>                     .row(SqlBuilder.k(3), SqlBuilder.k("manuel"))
>                     .row(SqlBuilder.k(4), SqlBuilder.k("rita"))
>                     .build();
2466c1900,1902
<             assertEquals("Values requires aliases to avoid ambiguous columns names.", e.getMessage());
---
>             if (!"Values requires aliases to avoid ambiguous columns names.".equals(e.getMessage())) {
>                 throw e;
>             }
2473c1909
<         final Values values = values("long", "uuid");
---
>         final Values values = Values.builder("long", "uuid");
2476,2477c1912,1913
<             values.row(k(ThreadLocalRandom.current().nextLong()),
<                     k(UUID.randomUUID().toString()));
---
>             values.row(SqlBuilder.k(ThreadLocalRandom.current().nextLong()),
>                     SqlBuilder.k(UUID.randomUUID().toString()));
2480d1915
<         // If it crashes, the test will fail.
2489,2493c1924,1926
<                 select(all())
<                         .from(table("TEST"))
<                         .where(
<                                 between(select(column("COL1")).from(table("TEST")).enclose(), k(1), k(2))
<                         )
---
>                 SqlBuilder.select(SqlBuilder.all())
>                         .from(SqlBuilder.table("TEST"))
>                         .where(SqlBuilder.between(SqlBuilder.enclose(SqlBuilder.select(SqlBuilder.column("COL1")).from(SqlBuilder.table("TEST"))), SqlBuilder.k(1), SqlBuilder.k(2)))
2502,2506c1935,1937
<                 select(all())
<                         .from(table("TEST"))
<                         .where(
<                                 between(column("COL1"), k(1), k(2)).enclose()
<                         )
---
>                 SqlBuilder.select(SqlBuilder.all())
>                         .from(SqlBuilder.table("TEST"))
>                         .where(SqlBuilder.enclose(SqlBuilder.between(SqlBuilder.column("COL1"), SqlBuilder.k(1), SqlBuilder.k(2))))
2515,2519c1946,1948
<                 select(all())
<                         .from(table("TEST"))
<                         .where(
<                                 notBetween(column("COL1"), k(1), k(2)).enclose()
<                         )
---
>                 SqlBuilder.select(SqlBuilder.all())
>                         .from(SqlBuilder.table("TEST"))
>                         .where(SqlBuilder.enclose(SqlBuilder.notBetween(SqlBuilder.column("COL1"), SqlBuilder.k(1), SqlBuilder.k(2))))
2525c1954
<         DbEntity entity = dbEntity()
---
>         DbEntity entity = DbEntity.builder()
2527,2531c1956,1960
<                 .addColumn("COL1", INT)
<                 .addColumn("COL2", BOOLEAN)
<                 .addColumn("COL3", DOUBLE)
<                 .addColumn("COL4", INT)
<                 .addColumn("COL5", STRING)
---
>                 .addColumn("COL1", DbColumnType.INT)
>                 .addColumn("COL2", DbColumnType.BOOLEAN)
>                 .addColumn("COL3", DbColumnType.DOUBLE)
>                 .addColumn("COL4", DbColumnType.INT)
>                 .addColumn("COL5", DbColumnType.STRING)
2536c1965
<         EntityEntry entry = entry()
---
>         EntityEntry entry = EntityEntry.builder()
2546,2548c1975,1976
<         List<Map<String, ResultColumn>> query = engine.query(select(mod(column("COL1"), column("COL4")).alias("MODULO")).from(table("TEST")));
< 
<         assertEquals("result ok?", 2, (int) query.get(0).get("MODULO").toInt());
---
>         List<Map<String, ResultColumn>> query = engine.query(SqlBuilder.select(SqlBuilder.mod(SqlBuilder.column("COL1"), SqlBuilder.column("COL4")).alias("MODULO"))
>                                                                           .from(SqlBuilder.table("TEST")));
2549a1978,1980
>         if (query.get(0).get("MODULO").toInt() != 2) {
>             throw new DatabaseEngineRuntimeException("Modulo operation returned incorrect result");
>         }
2555,2559c1986,1990
<                 select(
<                         k(1000).alias("timestamp"),
<                         column("sq_1", "one").alias("first"),
<                         column("sq_1", "two").alias("second"),
<                         column("sq_1", "three").alias("third"))
---
>                 SqlBuilder.select(
>                         SqlBuilder.k(1000).alias("timestamp"),
>                         SqlBuilder.column("sq_1", "one").alias("first"),
>                         SqlBuilder.column("sq_1", "two").alias("second"),
>                         SqlBuilder.column("sq_1", "three").alias("third"))
2561,2564c1992,1995
<                                 select(
<                                         k(1).alias("one"),
<                                         k(2L).alias("two"),
<                                         k(3.0).alias("three")).alias("sq_1")
---
>                                 SqlBuilder.select(
>                                         SqlBuilder.k(1).alias("one"),
>                                         SqlBuilder.k(2L).alias("two"),
>                                         SqlBuilder.k(3.0).alias("three")).alias("sq_1")
2568,2571c1999,2004
<         assertEquals("result ok?", 1000, (long) query.get(0).get("timestamp").toLong());
<         assertEquals("result ok?", 1, (int) query.get(0).get("first").toInt());
<         assertEquals("result ok?", 2L, (long) query.get(0).get("second").toLong());
<         assertEquals("result ok?", 3.0, query.get(0).get("third").toDouble(), 0.0);
---
>         if (query.get(0).get("timestamp").toLong() != 1000 ||
>             query.get(0).get("first").toInt() != 1 ||
>             query.get(0).get("second").toLong() != 2L ||
>             Math.abs(query.get(0).get("third").toDouble() - 3.0) > 0.0) {
>             throw new DatabaseEngineRuntimeException("Subselect query returned unexpected result");
>         }
2578,2579c2011
<         engine.persist("TEST", entry().set("COL1", 5)
<                 .build());
---
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 5).build());
2582,2583c2014,2017
<                 update(table("TEST"))
<                         .set(eq(column("COL1"), k(1)))
---
>                 Update.builder()
>                         .table(SqlBuilder.table("TEST"))
>                         .set(SqlBuilder.eq(SqlBuilder.column("COL1"), SqlBuilder.k(1)))
>                         .build()
2591,2592c2025
<         engine.persist("TEST", entry().set("COL1", 5)
<                 .build());
---
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 5).build());
2595,2598c2028,2032
<                 update(table("TEST"))
<                         .set(
<                                 eq(column("COL1"), k(1)),
<                                 eq(column("COL5"), k("ola")))
---
>                 Update.builder()
>                         .table(SqlBuilder.table("TEST"))
>                         .set(SqlBuilder.eq(SqlBuilder.column("COL1"), SqlBuilder.k(1)),
>                              SqlBuilder.eq(SqlBuilder.column("COL5"), SqlBuilder.k("ola")))
>                         .build()
2606,2607c2040
<         engine.persist("TEST", entry().set("COL1", 5)
<                 .build());
---
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 5).build());
2610,2613c2043,2047
<                 update(table("TEST").alias("T"))
<                         .set(
<                                 eq(column("COL1"), k(1)),
<                                 eq(column("COL5"), k("ola")))
---
>                 Update.builder()
>                         .table(SqlBuilder.table("TEST").alias("T"))
>                         .set(SqlBuilder.eq(SqlBuilder.column("COL1"), SqlBuilder.k(1)),
>                              SqlBuilder.eq(SqlBuilder.column("COL5"), SqlBuilder.k("ola")))
>                         .build()
2621,2622c2055
<         engine.persist("TEST", entry().set("COL1", 5)
<                 .build());
---
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 5).build());
2625,2629c2058,2063
<                 update(table("TEST").alias("T"))
<                         .set(
<                                 eq(column("COL1"), k(1)),
<                                 eq(column("COL5"), k("ola")))
<                         .where(eq(column("COL1"), k(5)))
---
>                 Update.builder()
>                         .table(SqlBuilder.table("TEST").alias("T"))
>                         .set(SqlBuilder.eq(SqlBuilder.column("COL1"), SqlBuilder.k(1)),
>                              SqlBuilder.eq(SqlBuilder.column("COL5"), SqlBuilder.k("ola")))
>                         .where(SqlBuilder.eq(SqlBuilder.column("COL1"), SqlBuilder.k(5)))
>                         .build()
2636c2070
<         final DbEntity entity = dbEntity()
---
>         final DbEntity entity = DbEntity.builder()
2638,2639c2072,2073
<                 .addColumn("COL1", INT)
<                 .addColumn("COL2", STRING)
---
>                 .addColumn("COL1", DbColumnType.INT)
>                 .addColumn("COL2", DbColumnType.STRING)
2644,2658c2078,2085
<         engine.persist("TEST", entry().set("COL1", 1).set("COL5", "teste")
<                                       .build());
<         engine.persist("TEST", entry().set("COL1", 2).set("COL5", "xpto")
<                                       .build());
<         engine.persist("TEST", entry().set("COL1", 3).set("COL5", "xpto")
<                                       .build());
<         engine.persist("TEST", entry().set("COL1", 4).set("COL5", "teste")
<                                       .build());
<         engine.persist("TEST", entry().set("COL1", 5).set("COL5", "pomme de terre")
<                                       .build());
< 
<         engine.persist("TEST2", entry().set("COL1", 1).set("COL2", "update1")
<                                       .build());
<         engine.persist("TEST2", entry().set("COL1", 5).set("COL2", "update2")
<                                       .build());
---
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 1).set("COL5", "teste").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 2).set("COL5", "xpto").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 3).set("COL5", "xpto").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 4).set("COL5", "teste").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 5).set("COL5", "pomme de terre").build());
> 
>         engine.persist("TEST2", EntityEntry.builder().set("COL1", 1).set("COL2", "update1").build());
>         engine.persist("TEST2", EntityEntry.builder().set("COL1", 5).set("COL2", "update2").build());
2661,2664c2088,2093
<                 update(table("TEST"))
<                         .from(table("TEST2"))
<                         .set(eq(column("COL5"), column("TEST2", "COL2")))
<                         .where(eq(column("TEST", "COL1"), column("TEST2", "COL1")));
---
>                 Update.builder()
>                         .table(SqlBuilder.table("TEST"))
>                         .from(SqlBuilder.table("TEST2"))
>                         .set(SqlBuilder.eq(SqlBuilder.column("COL5"), SqlBuilder.column("TEST2", "COL2")))
>                         .where(SqlBuilder.eq(SqlBuilder.column("TEST", "COL1"), SqlBuilder.column("TEST2", "COL1")))
>                         .build();
2668,2671c2097,2099
<         // check to see if TEST has changed
<         final Query query = select(column("COL5"))
<                 .from(table("TEST"))
<                 .orderby(column("COL1"));
---
>         final Query query = SqlBuilder.select(SqlBuilder.column("COL5"))
>                 .from(SqlBuilder.table("TEST"))
>                 .orderby(SqlBuilder.column("COL1"));
2675,2680c2103,2109
<         //check if only the 1st and the 5th were changed.
<         assertEquals("update1", result.get(0).get("COL5").toString());
<         assertEquals("xpto", result.get(1).get("COL5").toString());
<         assertEquals("xpto", result.get(2).get("COL5").toString());
<         assertEquals("teste", result.get(3).get("COL5").toString());
<         assertEquals("update2", result.get(4).get("COL5").toString());
---
>         if (!"update1".equals(result.get(0).get("COL5").toString()) ||
>             !"xpto".equals(result.get(1).get("COL5").toString()) ||
>             !"xpto".equals(result.get(2).get("COL5").toString()) ||
>             !"teste".equals(result.get(3).get("COL5").toString()) ||
>             !"update2".equals(result.get(4).get("COL5").toString())) {
>             throw new DatabaseEngineRuntimeException("Update from query failed");
>         }
2687,2688c2116
<         engine.persist("TEST", entry().set("COL1", 5)
<                 .build());
---
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 5).build());
2690,2692c2118
<         engine.executeUpdate(
<                 delete(table("TEST"))
<         );
---
>         engine.executeUpdate(SqlBuilder.delete(SqlBuilder.table("TEST")));
2699,2700c2125
<         engine.persist("TEST", entry().set("COL1", 5)
<                 .build());
---
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 5).build());
2703,2704c2128,2129
<                 delete(table("TEST"))
<                         .where(eq(column("COL1"), k(5)))
---
>                 SqlBuilder.delete(SqlBuilder.table("TEST"))
>                         .where(SqlBuilder.eq(SqlBuilder.column("COL1"), SqlBuilder.k(5)))
2712,2715c2137,2138
<         engine.persist("TEST", entry().set("COL1", 5)
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 6)
<                 .build());
---
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 5).build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 6).build());
2717,2719c2140
<         int rowsDeleted = engine.executeUpdate(
<                 delete(table("TEST"))
<         );
---
>         int rowsDeleted = engine.executeUpdate(SqlBuilder.delete(SqlBuilder.table("TEST")));
2721c2142,2144
<         assertEquals(2, rowsDeleted);
---
>         if (rowsDeleted != 2) {
>             throw new DatabaseEngineRuntimeException("Delete did not remove expected number of rows");
>         }
2725c2148
<     public void executePreparedStatementTest() throws DatabaseEngineException, NameAlreadyExistsException, ConnectionResetException {
---
>     public void executePreparedStatementTest() throws DatabaseEngineException, NameAlreadyExistsException, com.feedzai.commons.sql.abstraction.engine.ConnectionResetException {
2728,2731c2151
<         EntityEntry ee = entry()
<                 .set("COL1", 1)
<                 .set("COL2", true)
<                 .build();
---
>         EntityEntry ee = EntityEntry.builder().set("COL1", 1).set("COL2", true).build();
2736c2156
<         engine.createPreparedStatement("test", "SELECT * FROM " + quotize("TEST", ec) + " WHERE " + quotize("COL1", ec) + " = ?");
---
>         engine.createPreparedStatement("test", "SELECT * FROM " + SqlBuilder.quotize("TEST", ec) + " WHERE " + SqlBuilder.quotize("COL1", ec) + " = ?");
2741,2742c2161,2163
<         assertEquals("col1 ok?", 1, (int) res.get(0).get("COL1").toInt());
<         assertTrue("col2 ok?", res.get(0).get("COL2").toBoolean());
---
>         if (res.get(0).get("COL1").toInt() != 1 || !res.get(0).get("COL2").toBoolean()) {
>             throw new DatabaseEngineRuntimeException("Prepared statement did not return correct values");
>         }
2746c2167
<     public void executePreparedStatementUpdateTest() throws DatabaseEngineException, NameAlreadyExistsException, ConnectionResetException {
---
>     public void executePreparedStatementUpdateTest() throws DatabaseEngineException, NameAlreadyExistsException, com.feedzai.commons.sql.abstraction.engine.ConnectionResetException {
2749,2752c2170
<         EntityEntry ee = entry()
<                 .set("COL1", 1)
<                 .set("COL2", true)
<                 .build();
---
>         EntityEntry ee = EntityEntry.builder().set("COL1", 1).set("COL2", true).build();
2756c2174
<         engine.createPreparedStatement("test", update(table("TEST")).set(eq(column("COL1"), lit("?"))));
---
>         engine.createPreparedStatement("test", Update.builder(SqlBuilder.table("TEST")).set(SqlBuilder.eq(SqlBuilder.column("COL1"), SqlBuilder.lit("?"))).build());
2760c2178
<         List<Map<String, ResultColumn>> res = engine.query("SELECT * FROM " + quotize("TEST", engine.escapeCharacter()));
---
>         List<Map<String, ResultColumn>> res = engine.query("SELECT * FROM " + SqlBuilder.quotize("TEST", engine.escapeCharacter()));
2762,2763c2180,2182
<         assertEquals("col1 ok?", 2, (int) res.get(0).get("COL1").toInt());
<         assertTrue("col2 ok?", res.get(0).get("COL2").toBoolean());
---
>         if (res.get(0).get("COL1").toInt() != 2 || !res.get(0).get("COL2").toBoolean()) {
>             throw new DatabaseEngineRuntimeException("Prepared update did not execute correctly");
>         }
2768,2769c2187
<         DbEntity entity =
<                 dbEntity()
---
>         DbEntity entity = DbEntity.builder()
2771,2776c2189,2194
<                         .addColumn("COL1", INT)
<                         .addColumn("COL2", BOOLEAN)
<                         .addColumn("COL3", DOUBLE)
<                         .addColumn("COL4", LONG)
<                         .addColumn("COL5", STRING)
<                         .addColumn("COL6", BLOB)
---
>                         .addColumn("COL1", DbColumnType.INT)
>                         .addColumn("COL2", DbColumnType.BOOLEAN)
>                         .addColumn("COL3", DbColumnType.DOUBLE)
>                         .addColumn("COL4", DbColumnType.LONG)
>                         .addColumn("COL5", DbColumnType.STRING)
>                         .addColumn("COL6", DbColumnType.BLOB)
2782,2787c2200,2205
<         metaMap.put("COL1", INT);
<         metaMap.put("COL2", BOOLEAN);
<         metaMap.put("COL3", DOUBLE);
<         metaMap.put("COL4", LONG);
<         metaMap.put("COL5", STRING);
<         metaMap.put("COL6", BLOB);
---
>         metaMap.put("COL1", DbColumnType.INT);
>         metaMap.put("COL2", DbColumnType.BOOLEAN);
>         metaMap.put("COL3", DbColumnType.DOUBLE);
>         metaMap.put("COL4", DbColumnType.LONG);
>         metaMap.put("COL5", DbColumnType.STRING);
>         metaMap.put("COL6", DbColumnType.BLOB);
2789c2207,2209
<         assertEquals("meta ok?", metaMap, engine.getMetadata("TEST"));
---
>         if (!metaMap.equals(engine.getMetadata("TEST"))) {
>             throw new DatabaseEngineRuntimeException("Metadata does not match expected map");
>         }
2794c2214,2216
<         assertTrue("get metadata on table that does not exist is empty", engine.getMetadata("TableThatDoesNotExist").isEmpty());
---
>         if (!engine.getMetadata("TableThatDoesNotExist").isEmpty()) {
>             throw new DatabaseEngineRuntimeException("Expected empty metadata for a non-existent table");
>         }
2801,2802c2223
<         EntityEntry entry = entry().set("COL1", 2).set("COL2", false).set("COL3", 2D).set("COL4", 3L).set("COL5", "ADEUS")
<                 .build();
---
>         EntityEntry entry = EntityEntry.builder().set("COL1", 2).set("COL2", false).set("COL3", 2D).set("COL4", 3L).set("COL5", "ADEUS").build();
2804,2805c2225
<         entry = entry().set("COL1", 2).set("COL2", false).set("COL3", 2D).set("COL4", 3L).set("COL5", "ADEUS2")
<                 .build();
---
>         entry = EntityEntry.builder().set("COL1", 2).set("COL2", false).set("COL3", 2D).set("COL4", 3L).set("COL5", "ADEUS2").build();
2808c2228,2230
<         List<Map<String, ResultColumn>> result = engine.query(select(all()).from(table("TEST")).where(eq(column("COL5"), k("ADEUS' or 1 = 1 " + engine.commentCharacter()))));
---
>         List<Map<String, ResultColumn>> result = engine.query(SqlBuilder.select(SqlBuilder.all())
>                 .from(SqlBuilder.table("TEST"))
>                 .where(SqlBuilder.eq(SqlBuilder.column("COL5"), SqlBuilder.k("ADEUS' or 1 = 1 " + engine.commentCharacter()))));
2810c2232,2234
<         assertEquals("Testing sql injection", 0, result.size());
---
>         if (result.size() != 0) {
>             throw new DatabaseEngineRuntimeException("SQL injection test failed");
>         }
2815c2239
<         DbEntity entity = dbEntity()
---
>         DbEntity entity = DbEntity.builder()
2817,2818c2241,2242
<                 .addColumn("COL1", STRING)
<                 .addColumn("COL2", BLOB)
---
>                 .addColumn("COL1", DbColumnType.STRING)
>                 .addColumn("COL2", DbColumnType.BLOB)
2823,2824c2247
<         EntityEntry entry = entry().set("COL1", "CENINHAS").set("COL2", new BlobTest(1, "name"))
<                 .build();
---
>         EntityEntry entry = EntityEntry.builder().set("COL1", "CENINHAS").set("COL2", new BlobTest(1, "name")).build();
2828,2830c2251,2255
<         List<Map<String, ResultColumn>> result = engine.query(select(all()).from(table("TEST")));
<         assertEquals("CENINHAS", result.get(0).get("COL1").toString());
<         assertEquals(new BlobTest(1, "name"), result.get(0).get("COL2").<BlobTest>toBlob());
---
>         List<Map<String, ResultColumn>> result = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")));
>         if (!"CENINHAS".equals(result.get(0).get("COL1").toString()) ||
>             !new BlobTest(1, "name").equals(result.get(0).get("COL2").<BlobTest>toBlob())) {
>             throw new DatabaseEngineRuntimeException("Blob test failed");
>         }
2838c2263,2265
<         Update upd = update(table("TEST")).set(eq(column("COL2"), lit("?"))).where(eq(column("COL1"), k("CENINHAS")));
---
>         Update upd = Update.builder(SqlBuilder.table("TEST")).set(SqlBuilder.eq(SqlBuilder.column("COL2"), SqlBuilder.lit("?")))
>                 .where(SqlBuilder.eq(SqlBuilder.column("COL1"), SqlBuilder.k("CENINHAS")))
>                 .build();
2846,2848c2273,2277
<         result = engine.query(select(all()).from(table("TEST")));
<         assertEquals("CENINHAS", result.get(0).get("COL1").toString());
<         assertEquals(updBlob, result.get(0).get("COL2").<BlobTest>toBlob());
---
>         result = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")));
>         if (!"CENINHAS".equals(result.get(0).get("COL1").toString()) ||
>             !updBlob.equals(result.get(0).get("COL2").<BlobTest>toBlob())) {
>             throw new DatabaseEngineRuntimeException("Blob update failed");
>         }
2853c2282
<         DbEntity entity = dbEntity().name("TEST").addColumn("COL1", STRING).addColumn("COL2", BLOB)
---
>         DbEntity entity = DbEntity.builder().name("TEST").addColumn("COL1", DbColumnType.STRING).addColumn("COL2", DbColumnType.BLOB)
2856,2857c2285
<         EntityEntry entry = entry().set("COL1", "CENINHAS").set("COL2", new BlobTest(1, "name"))
<                 .build();
---
>         EntityEntry entry = EntityEntry.builder().set("COL1", "CENINHAS").set("COL2", new BlobTest(1, "name")).build();
2859,2861c2287,2291
<         List<Map<String, ResultColumn>> result = engine.query(select(all()).from(table("TEST")));
<         assertEquals("CENINHAS", result.get(0).get("COL1").toString());
<         assertEquals(new BlobTest(1, "name"), result.get(0).get("COL2").<BlobTest>toBlob());
---
>         List<Map<String, ResultColumn>> result = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")));
>         if (!"CENINHAS".equals(result.get(0).get("COL1").toString()) ||
>             !new BlobTest(1, "name").equals(result.get(0).get("COL2").<BlobTest>toBlob())) {
>             throw new DatabaseEngineRuntimeException("Blob setting with index test failed");
>         }
2869c2299,2301
<         Update upd = update(table("TEST")).set(eq(column("COL2"), lit("?"))).where(eq(column("COL1"), k("CENINHAS")));
---
>         Update upd = Update.builder(SqlBuilder.table("TEST")).set(SqlBuilder.eq(SqlBuilder.column("COL2"), SqlBuilder.lit("?")))
>                 .where(SqlBuilder.eq(SqlBuilder.column("COL1"), SqlBuilder.k("CENINHAS")))
>                 .build();
2873,2875c2305,2309
<         result = engine.query(select(all()).from(table("TEST")));
<         assertEquals("CENINHAS", result.get(0).get("COL1").toString());
<         assertEquals(updBlob, result.get(0).get("COL2").<BlobTest>toBlob());
---
>         result = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")));
>         if (!"CENINHAS".equals(result.get(0).get("COL1").toString()) ||
>             !updBlob.equals(result.get(0).get("COL2").<BlobTest>toBlob())) {
>             throw new DatabaseEngineRuntimeException("Blob setting with index update failed");
>         }
2880c2314
<         DbEntity entity = dbEntity()
---
>         DbEntity entity = DbEntity.builder()
2882,2883c2316,2317
<                 .addColumn("COL1", STRING)
<                 .addColumn("COL2", BLOB)
---
>                 .addColumn("COL1", DbColumnType.STRING)
>                 .addColumn("COL2", DbColumnType.BLOB)
2888d2321
<         // 10 mb
2896,2897c2329
<         EntityEntry entry = entry().set("COL1", "CENINHAS").set("COL2", bb)
<                 .build();
---
>         EntityEntry entry = EntityEntry.builder().set("COL1", "CENINHAS").set("COL2", bb).build();
2901,2904c2333,2337
<         List<Map<String, ResultColumn>> result = engine.query(select(all()).from(table("TEST")));
<         assertEquals("CENINHAS", result.get(0).get("COL1").toString());
<         assertArrayEquals(bb, result.get(0).get("COL2").toBlob());
< 
---
>         List<Map<String, ResultColumn>> result = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")));
>         if (!"CENINHAS".equals(result.get(0).get("COL1").toString()) ||
>             !java.util.Arrays.equals(bb, result.get(0).get("COL2").toBlob())) {
>             throw new DatabaseEngineRuntimeException("Blob ByteArray test failed");
>         }
2906c2339,2341
<         Update upd = update(table("TEST")).set(eq(column("COL2"), lit("?"))).where(eq(column("COL1"), k("CENINHAS")));
---
>         Update upd = Update.builder(SqlBuilder.table("TEST")).set(SqlBuilder.eq(SqlBuilder.column("COL2"), SqlBuilder.lit("?")))
>                 .where(SqlBuilder.eq(SqlBuilder.column("COL1"), SqlBuilder.k("CENINHAS")))
>                 .build();
2918,2921c2353,2357
<         result = engine.query(select(all()).from(table("TEST")));
<         assertEquals("CENINHAS", result.get(0).get("COL1").toString());
<         assertArrayEquals(bb2, result.get(0).get("COL2").toBlob());
< 
---
>         result = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")));
>         if (!"CENINHAS".equals(result.get(0).get("COL1").toString()) ||
>             !java.util.Arrays.equals(bb2, result.get(0).get("COL2").toBlob())) {
>             throw new DatabaseEngineRuntimeException("Blob ByteArray update test failed");
>         }
2926c2362
<         DbEntity entity = dbEntity()
---
>         DbEntity entity = DbEntity.builder()
2928,2929c2364,2365
<                 .addColumn("COL1", STRING)
<                 .addColumn("COL2", BLOB)
---
>                 .addColumn("COL1", DbColumnType.STRING)
>                 .addColumn("COL2", DbColumnType.BLOB)
2940,2941c2376
<         EntityEntry entry = entry().set("COL1", "CENINHAS").set("COL2", bigString)
<                 .build();
---
>         EntityEntry entry = EntityEntry.builder().set("COL1", "CENINHAS").set("COL2", bigString).build();
2945,2947c2380,2384
<         List<Map<String, ResultColumn>> result = engine.query(select(all()).from(table("TEST")));
<         assertEquals("CENINHAS", result.get(0).get("COL1").toString());
<         assertEquals(bigString, result.get(0).get("COL2").<String>toBlob());
---
>         List<Map<String, ResultColumn>> result = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")));
>         if (!"CENINHAS".equals(result.get(0).get("COL1").toString()) ||
>             !bigString.equals(result.get(0).get("COL2").<String>toBlob())) {
>             throw new DatabaseEngineRuntimeException("Blob String test failed");
>         }
2952c2389
<         DbEntity entity = dbEntity()
---
>         DbEntity entity = DbEntity.builder()
2954,2955c2391,2392
<                 .addColumn("COL1", STRING)
<                 .addColumn("COL2", BLOB)
---
>                 .addColumn("COL1", DbColumnType.STRING)
>                 .addColumn("COL2", DbColumnType.BLOB)
2961,2962c2398
<         EntityEntry entry = entry().set("COL1", "CENINHAS").set("COL2", bigString)
<                 .build();
---
>         EntityEntry entry = EntityEntry.builder().set("COL1", "CENINHAS").set("COL2", bigString).build();
2966,2968c2402,2406
<         List<Map<String, ResultColumn>> result = engine.query(select(all()).from(table("TEST")));
<         assertEquals("CENINHAS", result.get(0).get("COL1").toString());
<         assertEquals(bigString, result.get(0).get("COL2").<String>toBlob());
---
>         List<Map<String, ResultColumn>> result = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")));
>         if (!"CENINHAS".equals(result.get(0).get("COL1").toString()) ||
>             !bigString.equals(result.get(0).get("COL2").<String>toBlob())) {
>             throw new DatabaseEngineRuntimeException("Blob JSON test failed");
>         }
2973c2411
<         DbEntity.Builder entity = dbEntity()
---
>         DbEntity.Builder entity = DbEntity.builder()
2975,2979c2413,2417
<                 .addColumn("COL1", INT, true)
<                 .addColumn("COL2", BOOLEAN)
<                 .addColumn("USER", DOUBLE)
<                 .addColumn("COL4", LONG)
<                 .addColumn("COL5", STRING)
---
>                 .addColumn("COL1", DbColumnType.INT, true)
>                 .addColumn("COL2", DbColumnType.BOOLEAN)
>                 .addColumn("USER", DbColumnType.DOUBLE)
>                 .addColumn("COL4", DbColumnType.LONG)
>                 .addColumn("COL5", DbColumnType.STRING)
2981,2982c2419
<         engine.addEntity(entity
<                 .build());
---
>         engine.addEntity(entity.build());
2984,2988c2421,2427
<         assertEquals(INT, test.get("COL1"));
<         assertEquals(BOOLEAN, test.get("COL2"));
<         assertEquals(DOUBLE, test.get("USER"));
<         assertEquals(LONG, test.get("COL4"));
<         assertEquals(STRING, test.get("COL5"));
---
>         if (!DbColumnType.INT.equals(test.get("COL1")) ||
>             !DbColumnType.BOOLEAN.equals(test.get("COL2")) ||
>             !DbColumnType.DOUBLE.equals(test.get("USER")) ||
>             !DbColumnType.LONG.equals(test.get("COL4")) ||
>             !DbColumnType.STRING.equals(test.get("COL5"))) {
>             throw new DatabaseEngineRuntimeException("Initial metadata did not match");
>         }
2990,2991c2429
<         EntityEntry entry = entry().set("COL1", 1).set("COL2", true).set("USER", 2d).set("COL4", 1L).set("COL5", "c")
<                 .build();
---
>         EntityEntry entry = EntityEntry.builder().set("COL1", 1).set("COL2", true).set("USER", 2d).set("COL4", 1L).set("COL5", "c").build();
2996,2997c2434
<         engine.updateEntity(entity
<                 .build());
---
>         engine.updateEntity(entity.build());
2999,3001c2436
<         // as the fields were removed the entity mapping ignores the fields.
<         entry = entry().set("COL1", 2).set("COL2", true).set("COL3", 2d).set("COL4", 1L).set("COL5", "c")
<                 .build();
---
>         entry = EntityEntry.builder().set("COL1", 2).set("COL2", true).set("COL3", 2d).set("COL4", 1L).set("COL5", "c").build();
3004d2438
< 
3006,3012c2440,2444
<         assertEquals(INT, test.get("COL1"));
<         assertEquals(LONG, test.get("COL4"));
<         assertEquals(STRING, test.get("COL5"));
< 
<         entity.addColumn("COL6", BLOB).addColumn("COL7", DOUBLE);
<         engine.updateEntity(entity
<                 .build());
---
>         if (!DbColumnType.INT.equals(test.get("COL1")) ||
>             !DbColumnType.LONG.equals(test.get("COL4")) ||
>             !DbColumnType.STRING.equals(test.get("COL5"))) {
>             throw new DatabaseEngineRuntimeException("Metadata after column removal did not match");
>         }
3014,3015c2446,2449
<         entry = entry().set("COL1", 3).set("COL2", true).set("USER", 2d).set("COL4", 1L).set("COL5", "c").set("COL6", new BlobTest(1, "")).set("COL7", 2d)
<                 .build();
---
>         entity.addColumn("COL6", DbColumnType.BLOB).addColumn("COL7", DbColumnType.DOUBLE);
>         engine.updateEntity(entity.build());
> 
>         entry = EntityEntry.builder().set("COL1", 3).set("COL2", true).set("USER", 2d).set("COL4", 1L).set("COL5", "c").set("COL6", new BlobTest(1, "")).set("COL7", 2d).build();
3019,3024c2453,2459
<         assertEquals(INT, test.get("COL1"));
<         assertEquals(LONG, test.get("COL4"));
<         assertEquals(STRING, test.get("COL5"));
<         assertEquals(BLOB, test.get("COL6"));
<         assertEquals(DOUBLE, test.get("COL7"));
< 
---
>         if (!DbColumnType.INT.equals(test.get("COL1")) ||
>             !DbColumnType.LONG.equals(test.get("COL4")) ||
>             !DbColumnType.STRING.equals(test.get("COL5")) ||
>             !DbColumnType.BLOB.equals(test.get("COL6")) ||
>             !DbColumnType.DOUBLE.equals(test.get("COL7"))) {
>             throw new DatabaseEngineRuntimeException("Metadata after adding columns did not match");
>         }
3029,3030c2464
<         // First drop-create
<         DbEntity.Builder entity = dbEntity()
---
>         DbEntity.Builder entity = DbEntity.builder()
3032,3036c2466,2470
<                 .addColumn("COL1", INT, true)
<                 .addColumn("COL2", BOOLEAN)
<                 .addColumn("USER", DOUBLE)
<                 .addColumn("COL4", LONG)
<                 .addColumn("COL5", STRING)
---
>                 .addColumn("COL1", DbColumnType.INT, true)
>                 .addColumn("COL2", DbColumnType.BOOLEAN)
>                 .addColumn("USER", DbColumnType.DOUBLE)
>                 .addColumn("COL4", DbColumnType.LONG)
>                 .addColumn("COL5", DbColumnType.STRING)
3040,3049c2474,2479
<         assertEquals(INT, test.get("COL1"));
<         assertEquals(BOOLEAN, test.get("COL2"));
<         assertEquals(DOUBLE, test.get("USER"));
<         assertEquals(LONG, test.get("COL4"));
<         assertEquals(STRING, test.get("COL5"));
< 
<         // Clone the connection with the create now.
<         final DatabaseEngine engine2 = this.engine.duplicate(new Properties() {
<             {
<                 setProperty(SCHEMA_POLICY, "create");
---
>         if (!DbColumnType.INT.equals(test.get("COL1")) ||
>             !DbColumnType.BOOLEAN.equals(test.get("COL2")) ||
>             !DbColumnType.DOUBLE.equals(test.get("USER")) ||
>             !DbColumnType.LONG.equals(test.get("COL4")) ||
>             !DbColumnType.STRING.equals(test.get("COL5"))) {
>             throw new DatabaseEngineRuntimeException("Initial metadata did not match");
3051d2480
<         }, true);
3053,3054c2482,2486
<         EntityEntry entry = entry().set("COL1", 1).set("COL2", true).set("USER", 2d).set("COL4", 1L).set("COL5", "c")
<                 .build();
---
>         final DatabaseEngine engine2 = this.engine.duplicate(new Properties() {{
>             setProperty("SCHEMA_POLICY", "create");
>         }}, true);
> 
>         EntityEntry entry = EntityEntry.builder().set("COL1", 1).set("COL2", true).set("USER", 2d).set("COL4", 1L).set("COL5", "c").build();
3061,3064c2493
<         // as the fields were removed the entity mapping ignores the fields.
<         System.out.println("> " + engine2.getMetadata("TEST"));
<         entry = entry().set("COL1", 2).set("COL2", true).set("COL3", 2d).set("COL4", 1L).set("COL5", "c")
<                 .build();
---
>         entry = EntityEntry.builder().set("COL1", 2).set("COL2", true).set("COL3", 2d).set("COL4", 1L).set("COL5", "c").build();
3067d2495
< 
3069,3071c2497,2501
<         assertEquals(INT, test.get("COL1"));
<         assertEquals(LONG, test.get("COL4"));
<         assertEquals(STRING, test.get("COL5"));
---
>         if (!DbColumnType.INT.equals(test.get("COL1")) ||
>             !DbColumnType.LONG.equals(test.get("COL4")) ||
>             !DbColumnType.STRING.equals(test.get("COL5"))) {
>             throw new DatabaseEngineRuntimeException("Metadata post removal did not match");
>         }
3073c2503
<         entity.addColumn("COL6", BLOB).addColumn("COL7", DOUBLE);
---
>         entity.addColumn("COL6", DbColumnType.BLOB).addColumn("COL7", DbColumnType.DOUBLE);
3076,3077c2506
<         entry = entry().set("COL1", 3).set("COL2", true).set("USER", 2d).set("COL4", 1L).set("COL5", "c").set("COL6", new BlobTest(1, "")).set("COL7", 2d)
<                 .build();
---
>         entry = EntityEntry.builder().set("COL1", 3).set("COL2", true).set("USER", 2d).set("COL4", 1L).set("COL5", "c").set("COL6", new BlobTest(1, "")).set("COL7", 2d).build();
3081,3086c2510,2517
<         assertEquals(INT, test.get("COL1"));
<         assertEquals(LONG, test.get("COL4"));
<         assertEquals(STRING, test.get("COL5"));
<         assertEquals(BLOB, test.get("COL6"));
<         assertEquals(DOUBLE, test.get("COL7"));
< 
---
>         if (!DbColumnType.INT.equals(test.get("COL1")) ||
>             !DbColumnType.LONG.equals(test.get("COL4")) ||
>             !DbColumnType.STRING.equals(test.get("COL5")) ||
>             !DbColumnType.BLOB.equals(test.get("COL6")) ||
>             !DbColumnType.DOUBLE.equals(test.get("COL7"))) {
>             throw new DatabaseEngineRuntimeException("Metadata final check failed");
>         }
>         engine2.close();
3089,3092d2519
<     /**
<      * Tests that {@link AbstractDatabaseEngine#updateEntity(DbEntity)} with a "none" schema policy
<      * still creates the in-memory {@link MappedEntity} with the prepared statements for the entities.
<      */
3098c2525
<         DbEntity entity = dbEntity()
---
>         DbEntity entity = DbEntity.builder()
3100,3104c2527,2531
<                 .addColumn("COL1", INT)
<                 .addColumn("COL2", BOOLEAN)
<                 .addColumn("COL3", DOUBLE)
<                 .addColumn("COL4", LONG)
<                 .addColumn("COL5", STRING)
---
>                 .addColumn("COL1", DbColumnType.INT)
>                 .addColumn("COL2", DbColumnType.BOOLEAN)
>                 .addColumn("COL3", DbColumnType.DOUBLE)
>                 .addColumn("COL4", DbColumnType.LONG)
>                 .addColumn("COL5", DbColumnType.STRING)
3110c2537
<         properties.setProperty(SCHEMA_POLICY, "none");
---
>         properties.setProperty("SCHEMA_POLICY", "none");
3113c2540
<         EntityEntry entry = entry()
---
>         EntityEntry entry = EntityEntry.builder()
3123c2550
<             fail("Should throw an exception if trying to persist an entity before calling addEntity/updateEntity a first time");
---
>             throw new DatabaseEngineRuntimeException("Expected exception for unknown entity with NONE schema policy");
3125,3126c2552,2554
<             assertTrue("Should fail because the entity is still unknown to this DatabaseEngine instance",
<                 e.getMessage().contains("Unknown entity"));
---
>             if (!e.getMessage().contains("Unknown entity")) {
>                 throw new DatabaseEngineRuntimeException("Unexpected exception message: " + e.getMessage());
>             }
3131c2559,2561
<         assertTrue("DatabaseEngine should be aware of the entity even with a NONE schema policy.", schemaNoneEngine.containsEntity(entity.getName()));
---
>         if (!schemaNoneEngine.containsEntity(entity.getName())) {
>             throw new DatabaseEngineRuntimeException("Entity should be known after updateEntity with NONE schema policy");
>         }
3133d2562
<         // Persist the entry and make sure it was successful
3135c2564
<         List<Map<String, ResultColumn>> result = schemaNoneEngine.query(select(all()).from(table("TEST")));
---
>         List<Map<String, ResultColumn>> result = schemaNoneEngine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")));
3137c2566,2568
<         assertEquals("There should be only one entry in the table.", 1, result.size());
---
>         if (result.size() != 1) {
>             throw new DatabaseEngineRuntimeException("Expected one entry in table");
>         }
3141,3145c2572,2578
<         assertEquals("COL1 was successfully inserted", 1, resultEntry.get("COL1").toInt().intValue());
<         assertEquals("COL2 was successfully inserted", true, resultEntry.get("COL2").toBoolean());
<         assertEquals("COL3 was successfully inserted", 1.0, resultEntry.get("COL3").toDouble(), 0);
<         assertEquals("COL4 was successfully inserted", 1L, resultEntry.get("COL4").toLong().longValue());
<         assertEquals("COL5 was successfully inserted", "1", resultEntry.get("COL5").toString());
---
>         if (resultEntry.get("COL1").toInt() != 1 ||
>             !Boolean.TRUE.equals(resultEntry.get("COL2").toBoolean()) ||
>             resultEntry.get("COL3").toDouble() != 1.0 ||
>             resultEntry.get("COL4").toLong() != 1L ||
>             !"1".equals(resultEntry.get("COL5").toString())) {
>             throw new DatabaseEngineRuntimeException("Persisted values do not match expected");
>         }
3148,3151d2580
<     /**
<      * Tests that {@link AbstractDatabaseEngine#updateEntity(DbEntity)} with a "none" schema policy
<      * doesn't execute DDL.
<      */
3156c2585
<         properties.setProperty(SCHEMA_POLICY, "none");
---
>         properties.setProperty("SCHEMA_POLICY", "none");
3159c2588
<         DbEntity entity = dbEntity()
---
>         DbEntity entity = DbEntity.builder()
3161,3165c2590,2594
<                 .addColumn("COL1", INT)
<                 .addColumn("COL2", BOOLEAN)
<                 .addColumn("COL3", DOUBLE)
<                 .addColumn("COL4", LONG)
<                 .addColumn("COL5", STRING)
---
>                 .addColumn("COL1", DbColumnType.INT)
>                 .addColumn("COL2", DbColumnType.BOOLEAN)
>                 .addColumn("COL3", DbColumnType.DOUBLE)
>                 .addColumn("COL4", DbColumnType.LONG)
>                 .addColumn("COL5", DbColumnType.STRING)
3171,3172c2600,2601
<             schemaNoneEngine.query(select(all()).from(table(entity.getName())));
<             fail("Should have failed because updateEntity with schema policy NONE doesn't execute DDL");
---
>             schemaNoneEngine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table(entity.getName())));
>             throw new DatabaseEngineRuntimeException("Expected failure due to DDL not executed with NONE schema policy");
3174c2603
<             // Should fail because because updateEntity with schema policy NONE doesn't execute DDL
---
>             // Expected failure
3183c2612
<         DbEntity.Builder entity = dbEntity()
---
>         DbEntity.Builder entity = DbEntity.builder()
3185,3189c2614,2618
<                 .addColumn("COL1", INT)
<                 .addColumn("COL2", BOOLEAN)
<                 .addColumn("COL3", DOUBLE)
<                 .addColumn("COL4", LONG)
<                 .addColumn("COL5", STRING)
---
>                 .addColumn("COL1", DbColumnType.INT)
>                 .addColumn("COL2", DbColumnType.BOOLEAN)
>                 .addColumn("COL3", DbColumnType.DOUBLE)
>                 .addColumn("COL4", DbColumnType.LONG)
>                 .addColumn("COL5", DbColumnType.STRING)
3194,3198c2623,2629
<         assertEquals(INT, test.get("COL1"));
<         assertEquals(BOOLEAN, test.get("COL2"));
<         assertEquals(DOUBLE, test.get("COL3"));
<         assertEquals(LONG, test.get("COL4"));
<         assertEquals(STRING, test.get("COL5"));
---
>         if (!DbColumnType.INT.equals(test.get("COL1")) ||
>             !DbColumnType.BOOLEAN.equals(test.get("COL2")) ||
>             !DbColumnType.DOUBLE.equals(test.get("COL3")) ||
>             !DbColumnType.LONG.equals(test.get("COL4")) ||
>             !DbColumnType.STRING.equals(test.get("COL5"))) {
>             throw new DatabaseEngineRuntimeException("Initial metadata did not match");
>         }
3205,3206c2636
<         engine.updateEntity(entity
<                 .build());
---
>         engine.updateEntity(entity.build());
3209,3211c2639,2643
<         assertEquals(INT, test.get("COL1"));
<         assertEquals(LONG, test.get("COL4"));
<         assertEquals(STRING, test.get("COL5"));
---
>         if (!DbColumnType.INT.equals(test.get("COL1")) ||
>             !DbColumnType.LONG.equals(test.get("COL4")) ||
>             !DbColumnType.STRING.equals(test.get("COL5"))) {
>             throw new DatabaseEngineRuntimeException("Metadata after dropping columns did not match");
>         }
3216,3218c2648,2649
<         entity.addColumn("COL6", BLOB).addColumn("COL7", DOUBLE, DbColumnConstraint.NOT_NULL);
<         engine.updateEntity(entity
<                 .build());
---
>         entity.addColumn("COL6", DbColumnType.BLOB).addColumn("COL7", DbColumnType.DOUBLE, DbColumnConstraint.NOT_NULL);
>         engine.updateEntity(entity.build());
3221,3225c2652,2658
<         assertEquals(INT, test.get("COL1"));
<         assertEquals(LONG, test.get("COL4"));
<         assertEquals(STRING, test.get("COL5"));
<         assertEquals(BLOB, test.get("COL6"));
<         assertEquals(DOUBLE, test.get("COL7"));
---
>         if (!DbColumnType.INT.equals(test.get("COL1")) ||
>             !DbColumnType.LONG.equals(test.get("COL4")) ||
>             !DbColumnType.STRING.equals(test.get("COL5")) ||
>             !DbColumnType.BLOB.equals(test.get("COL6")) ||
>             !DbColumnType.DOUBLE.equals(test.get("COL7"))) {
>             throw new DatabaseEngineRuntimeException("Final metadata did not match");
>         }
3233,3245c2666,2676
<         DatabaseEngine engine = this.engine.duplicate(new Properties() {
<             {
<                 setProperty(SCHEMA_POLICY, "create");
<             }
<         }, true);
< 
<         DbEntity.Builder entity = dbEntity()
<                 .name("TEST")
<                 .addColumn("COL1", INT)
<                 .addColumn("COL2", BOOLEAN)
<                 .addColumn("COL3", DOUBLE)
<                 .addColumn("COL4", LONG)
<                 .addColumn("COL5", STRING)
---
>         DatabaseEngine engine = this.engine.duplicate(new Properties() {{
>             setProperty("SCHEMA_POLICY", "create");
>         }}, true);
> 
>         DbEntity.Builder entity = DbEntity.builder()
>                 .name("TEST")
>                 .addColumn("COL1", DbColumnType.INT)
>                 .addColumn("COL2", DbColumnType.BOOLEAN)
>                 .addColumn("COL3", DbColumnType.DOUBLE)
>                 .addColumn("COL4", DbColumnType.LONG)
>                 .addColumn("COL5", DbColumnType.STRING)
3250,3254c2681,2687
<         assertEquals(INT, test.get("COL1"));
<         assertEquals(BOOLEAN, test.get("COL2"));
<         assertEquals(DOUBLE, test.get("COL3"));
<         assertEquals(LONG, test.get("COL4"));
<         assertEquals(STRING, test.get("COL5"));
---
>         if (!DbColumnType.INT.equals(test.get("COL1")) ||
>             !DbColumnType.BOOLEAN.equals(test.get("COL2")) ||
>             !DbColumnType.DOUBLE.equals(test.get("COL3")) ||
>             !DbColumnType.LONG.equals(test.get("COL4")) ||
>             !DbColumnType.STRING.equals(test.get("COL5"))) {
>             throw new DatabaseEngineRuntimeException("Initial metadata did not match");
>         }
3264,3266c2697,2701
<         assertEquals(INT, test.get("COL1"));
<         assertEquals(LONG, test.get("COL4"));
<         assertEquals(STRING, test.get("COL5"));
---
>         if (!DbColumnType.INT.equals(test.get("COL1")) ||
>             !DbColumnType.LONG.equals(test.get("COL4")) ||
>             !DbColumnType.STRING.equals(test.get("COL5"))) {
>             throw new DatabaseEngineRuntimeException("Metadata after dropping columns did not match");
>         }
3271c2706
<         entity.addColumn("COL6", BLOB).addColumn("COL7", DOUBLE, DbColumnConstraint.NOT_NULL);
---
>         entity.addColumn("COL6", DbColumnType.BLOB).addColumn("COL7", DbColumnType.DOUBLE, DbColumnConstraint.NOT_NULL);
3275,3279c2710,2716
<         assertEquals(INT, test.get("COL1"));
<         assertEquals(LONG, test.get("COL4"));
<         assertEquals(STRING, test.get("COL5"));
<         assertEquals(BLOB, test.get("COL6"));
<         assertEquals(DOUBLE, test.get("COL7"));
---
>         if (!DbColumnType.INT.equals(test.get("COL1")) ||
>             !DbColumnType.LONG.equals(test.get("COL4")) ||
>             !DbColumnType.STRING.equals(test.get("COL5")) ||
>             !DbColumnType.BLOB.equals(test.get("COL6")) ||
>             !DbColumnType.DOUBLE.equals(test.get("COL7"))) {
>             throw new DatabaseEngineRuntimeException("Final metadata did not match");
>         }
3284c2721
<         DbEntity entity = dbEntity()
---
>         DbEntity entity = DbEntity.builder()
3286,3287c2723,2724
<                 .addColumn("COL1", STRING)
<                 .addColumn("COL2", CLOB)
---
>                 .addColumn("COL1", DbColumnType.STRING)
>                 .addColumn("COL2", DbColumnType.CLOB)
3292,3293c2729
<         EntityEntry entry = entry().set("COL1", "CENINHAS")
<                 .build();
---
>         EntityEntry entry = EntityEntry.builder().set("COL1", "CENINHAS").build();
3297,3300c2733,2739
<         List<Map<String, ResultColumn>> result = engine.query(select(all()).from(table("TEST")));
<         assertEquals("CENINHAS", result.get(0).get("COL1").toString());
<         System.out.println(result.get(0).get("COL2"));
<         assertNull(result.get(0).get("COL2").toString());
---
>         List<Map<String, ResultColumn>> result = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")));
>         if (!"CENINHAS".equals(result.get(0).get("COL1").toString())) {
>             throw new DatabaseEngineRuntimeException("CLOB insert test failed for COL1");
>         }
>         if (result.get(0).get("COL2").toString() != null) {
>             throw new DatabaseEngineRuntimeException("CLOB insert test failed for COL2");
>         }
3302d2740
< 
3306c2744
<         DbEntity entity = dbEntity()
---
>         DbEntity entity = DbEntity.builder()
3308,3309c2746,2747
<                 .addColumn("COL1", STRING)
<                 .addColumn("COL2", CLOB)
---
>                 .addColumn("COL1", DbColumnType.STRING)
>                 .addColumn("COL2", DbColumnType.CLOB)
3323,3324c2761
<         EntityEntry entry = entry().set("COL1", "CENINHAS").set("COL2", initialClob)
<                 .build();
---
>         EntityEntry entry = EntityEntry.builder().set("COL1", "CENINHAS").set("COL2", initialClob).build();
3328,3329c2765
<         List<Map<String, ResultColumn>> result = engine.query(select(all()).from(table("TEST")));
< 
---
>         List<Map<String, ResultColumn>> result = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")));
3331,3332c2767,2770
<         assertEquals("CENINHAS", result.get(0).get("COL1").toString());
<         assertEquals(initialClob, result.get(0).get("COL2").toString());
---
>         if (!"CENINHAS".equals(result.get(0).get("COL1").toString()) ||
>             !initialClob.equals(result.get(0).get("COL2").toString())) {
>             throw new DatabaseEngineRuntimeException("Initial CLOB values do not match");
>         }
3334c2772,2774
<         Update upd = update(table("TEST")).set(eq(column("COL2"), lit("?"))).where(eq(column("COL1"), k("CENINHAS")));
---
>         Update upd = Update.builder(SqlBuilder.table("TEST")).set(SqlBuilder.eq(SqlBuilder.column("COL2"), SqlBuilder.lit("?")))
>                 .where(SqlBuilder.eq(SqlBuilder.column("COL1"), SqlBuilder.k("CENINHAS")))
>                 .build();
3342,3345c2782,2786
<         result = engine.query(select(all()).from(table("TEST")));
<         assertEquals("CENINHAS", result.get(0).get("COL1").toString());
<         assertEquals(updateClob, result.get(0).get("COL2").toString());
< 
---
>         result = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")));
>         if (!"CENINHAS".equals(result.get(0).get("COL1").toString()) ||
>             !updateClob.equals(result.get(0).get("COL2").toString())) {
>             throw new DatabaseEngineRuntimeException("CLOB update failed");
>         }
3350c2791
<         DbEntity entity = dbEntity()
---
>         DbEntity entity = DbEntity.builder()
3352,3353c2793,2794
<                 .addColumn("COL1", STRING)
<                 .addColumn("COL2", CLOB)
---
>                 .addColumn("COL1", DbColumnType.STRING)
>                 .addColumn("COL2", DbColumnType.CLOB)
3361,3362c2802
<         EntityEntry entry = entry().set("COL1", "CENINHAS").set("COL2", initialClob)
<                 .build();
---
>         EntityEntry entry = EntityEntry.builder().set("COL1", "CENINHAS").set("COL2", initialClob).build();
3366,3368c2806,2810
<         List<Map<String, ResultColumn>> result = engine.query(select(all()).from(table("TEST")));
<         assertEquals("CENINHAS", result.get(0).get("COL1").toString());
<         assertEquals(initialClob, result.get(0).get("COL2").toString());
---
>         List<Map<String, ResultColumn>> result = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")));
>         if (!"CENINHAS".equals(result.get(0).get("COL1").toString()) ||
>             !initialClob.equals(result.get(0).get("COL2").toString())) {
>             throw new DatabaseEngineRuntimeException("CLOB encoding initial value mismatch");
>         }
3370c2812,2814
<         Update upd = update(table("TEST")).set(eq(column("COL2"), lit("?"))).where(eq(column("COL1"), k("CENINHAS")));
---
>         Update upd = Update.builder(SqlBuilder.table("TEST")).set(SqlBuilder.eq(SqlBuilder.column("COL2"), SqlBuilder.lit("?")))
>                 .where(SqlBuilder.eq(SqlBuilder.column("COL1"), SqlBuilder.k("CENINHAS")))
>                 .build();
3378,3381c2822,2826
<         result = engine.query(select(all()).from(table("TEST")));
<         assertEquals("CENINHAS", result.get(0).get("COL1").toString());
<         assertEquals(updateClob, result.get(0).get("COL2").toString());
< 
---
>         result = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")));
>         if (!"CENINHAS".equals(result.get(0).get("COL1").toString()) ||
>             !updateClob.equals(result.get(0).get("COL2").toString())) {
>             throw new DatabaseEngineRuntimeException("CLOB encoding update value mismatch");
>         }
3386c2831
<         DbEntity entity = dbEntity()
---
>         DbEntity entity = DbEntity.builder()
3388,3389c2833,2834
<                 .addColumn("COL1", INT, true)
<                 .addColumn("COL2", STRING)
---
>                 .addColumn("COL1", DbColumnType.INT, true)
>                 .addColumn("COL2", DbColumnType.STRING)
3395,3396c2840
<         EntityEntry ent = entry().set("COL2", "CENAS1")
<                 .build();
---
>         EntityEntry ent = EntityEntry.builder().set("COL2", "CENAS1").build();
3398,3399c2842
<         ent = entry().set("COL2", "CENAS2")
<                 .build();
---
>         ent = EntityEntry.builder().set("COL2", "CENAS2").build();
3402,3403c2845
<         ent = entry().set("COL2", "CENAS3").set("COL1", 3)
<                 .build();
---
>         ent = EntityEntry.builder().set("COL2", "CENAS3").set("COL1", 3).build();
3406,3407c2848
<         ent = entry().set("COL2", "CENAS5").set("COL1", 5)
<                 .build();
---
>         ent = EntityEntry.builder().set("COL2", "CENAS5").set("COL1", 5).build();
3410,3412c2851
< 
<         ent = entry().set("COL2", "CENAS6")
<                 .build();
---
>         ent = EntityEntry.builder().set("COL2", "CENAS6").build();
3415,3416c2854
<         ent = entry().set("COL2", "CENAS7")
<                 .build();
---
>         ent = EntityEntry.builder().set("COL2", "CENAS7").build();
3419,3421c2857,2861
<         final List<Map<String, ResultColumn>> query = engine.query("SELECT * FROM " + quotize("MYTEST", engine.escapeCharacter()));
<         for (Map<String, ResultColumn> stringResultColumnMap : query) {
<             assertTrue(stringResultColumnMap.get("COL2").toString().endsWith(stringResultColumnMap.get("COL1").toString()));
---
>         final List<Map<String, ResultColumn>> query = engine.query("SELECT * FROM " + SqlBuilder.quotize("MYTEST", engine.escapeCharacter()));
>         for (Map<String, ResultColumn> m : query) {
>             if (!m.get("COL2").toString().endsWith(m.get("COL1").toString())) {
>                 throw new DatabaseEngineRuntimeException("Persist override auto increment failed");
>             }
3429c2869
<         DbColumn APP_ID_COLUMN = new DbColumn.Builder().name(APP_ID).type(INT).build();
---
>         DbColumn APP_ID_COLUMN = new DbColumn.Builder().name(APP_ID).type(DbColumnType.INT).build();
3433c2873
<         DbEntity STREAM = dbEntity().name(STM_TABLE)
---
>         DbEntity STREAM = DbEntity.builder().name(STM_TABLE)
3435,3436c2875,2876
<                 .addColumn(STM_ID, INT, true)
<                 .addColumn(STM_NAME, STRING, NOT_NULL)
---
>                 .addColumn(STM_ID, DbColumnType.INT, true)
>                 .addColumn(STM_NAME, DbColumnType.STRING, true)
3442,3443c2882
<         EntityEntry ent = entry().set(APP_ID, 1).set(STM_ID, 1).set(STM_NAME, "NAME1")
<                 .build();
---
>         EntityEntry ent = EntityEntry.builder().set(APP_ID, 1).set(STM_ID, 1).set(STM_NAME, "NAME1").build();
3446,3447c2885
<         ent = entry().set(APP_ID, 2).set(STM_ID, 1).set(STM_NAME, "NAME1")
<                 .build();
---
>         ent = EntityEntry.builder().set(APP_ID, 2).set(STM_ID, 1).set(STM_NAME, "NAME1").build();
3450,3451c2888
<         ent = entry().set(APP_ID, 2).set(STM_ID, 2).set(STM_NAME, "NAME2")
<                 .build();
---
>         ent = EntityEntry.builder().set(APP_ID, 2).set(STM_ID, 2).set(STM_NAME, "NAME2").build();
3454,3455c2891
<         ent = entry().set(APP_ID, 1).set(STM_ID, 10).set(STM_NAME, "NAME10")
<                 .build();
---
>         ent = EntityEntry.builder().set(APP_ID, 1).set(STM_ID, 10).set(STM_NAME, "NAME10").build();
3458,3459c2894
<         ent = entry().set(APP_ID, 1).set(STM_ID, 2).set(STM_NAME, "NAME11")
<                 .build();
---
>         ent = EntityEntry.builder().set(APP_ID, 1).set(STM_ID, 2).set(STM_NAME, "NAME11").build();
3462,3463c2897
<         ent = entry().set(APP_ID, 2).set(STM_ID, 11).set(STM_NAME, "NAME11")
<                 .build();
---
>         ent = EntityEntry.builder().set(APP_ID, 2).set(STM_ID, 11).set(STM_NAME, "NAME11").build();
3466,3469c2900,2904
<         final List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table(STM_TABLE)));
<         for (Map<String, ResultColumn> stringResultColumnMap : query) {
<             System.out.println(stringResultColumnMap);
<             assertTrue("Assert Stream Name with id", stringResultColumnMap.get(STM_NAME).toString().endsWith(stringResultColumnMap.get(STM_ID).toString()));
---
>         final List<Map<String, ResultColumn>> query = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table(STM_TABLE)));
>         for (Map<String, ResultColumn> m : query) {
>             if (!m.get(STM_NAME).toString().endsWith(m.get(STM_ID).toString())) {
>                 throw new DatabaseEngineRuntimeException("Stream name does not match stream id");
>             }
3471d2905
< 
3476c2910
<         DbEntity entity = dbEntity()
---
>         DbEntity entity = DbEntity.builder()
3478,3479c2912,2913
<                 .addColumn("COL1", INT, true)
<                 .addColumn("COL2", STRING)
---
>                 .addColumn("COL1", DbColumnType.INT, true)
>                 .addColumn("COL2", DbColumnType.STRING)
3482d2915
< 
3485,3486c2918
<         EntityEntry ent = entry().set("COL2", "CENAS1").set("COL1", 1)
<                 .build();
---
>         EntityEntry ent = EntityEntry.builder().set("COL2", "CENAS1").set("COL1", 1).build();
3489,3490c2921
<         ent = entry().set("COL2", "CENAS2")
<                 .build();
---
>         ent = EntityEntry.builder().set("COL2", "CENAS2").build();
3493,3495c2924
< 
<         ent = entry().set("COL2", "CENAS5").set("COL1", 5)
<                 .build();
---
>         ent = EntityEntry.builder().set("COL2", "CENAS5").set("COL1", 5).build();
3498,3499c2927
<         ent = entry().set("COL2", "CENAS6")
<                 .build();
---
>         ent = EntityEntry.builder().set("COL2", "CENAS6").build();
3502,3505c2930,2934
<         final List<Map<String, ResultColumn>> query = engine.query("SELECT * FROM " + quotize("MYTEST", engine.escapeCharacter()));
<         for (Map<String, ResultColumn> stringResultColumnMap : query) {
<             System.out.println(stringResultColumnMap);
<             assertTrue(stringResultColumnMap.get("COL2").toString().endsWith(stringResultColumnMap.get("COL1").toString()));
---
>         final List<Map<String, ResultColumn>> query = engine.query("SELECT * FROM " + SqlBuilder.quotize("MYTEST", engine.escapeCharacter()));
>         for (Map<String, ResultColumn> m : query) {
>             if (!m.get("COL2").toString().endsWith(m.get("COL1").toString())) {
>                 throw new DatabaseEngineRuntimeException("Persist override auto increment failed");
>             }
3514,3515c2943
<         engine.persist("TEST", entry().set("COL1", 5)
<                 .build());
---
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 5).build());
3517c2945
<         Truncate truncate = new Truncate(table("TEST"));
---
>         SqlBuilder.Truncate truncate = new SqlBuilder.Truncate(SqlBuilder.table("TEST"));
3521,3523c2949,2952
<         final List<Map<String, ResultColumn>> test = engine.query(select(all()).from(table("TEST")));
<         assertTrue("Test truncate query empty?", test.isEmpty());
< 
---
>         final List<Map<String, ResultColumn>> test = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")));
>         if (!test.isEmpty()) {
>             throw new DatabaseEngineRuntimeException("Truncate did not clear table");
>         }
3531d2959
<         // Drop tables for sanity.
3534,3535c2962
<         // Create the "old" table.
<         DbEntity entity = dbEntity()
---
>         DbEntity entity = DbEntity.builder()
3537c2964
<                 .addColumn("timestamp", INT)
---
>                 .addColumn("timestamp", DbColumnType.INT)
3540,3541c2967
<         engine.persist(oldName, entry().set("timestamp", 20)
<                 .build());
---
>         engine.persist(oldName, EntityEntry.builder().set("timestamp", 20).build());
3543,3544c2969
<         // Rename it
<         Rename rename = new Rename(table(oldName), table(newName));
---
>         Rename rename = new Rename(SqlBuilder.table(oldName), SqlBuilder.table(newName));
3547d2971
<         // Check whether the schema matches
3549,3554c2973,2976
<         metaMap.put("timestamp", INT);
<         assertEquals("Metamap ok?", metaMap, engine.getMetadata(newName));
< 
<         // Check the data
<         List<Map<String, ResultColumn>> resultSet = engine.query(select(all()).from(table(newName)));
<         assertEquals("Count ok?", 1, resultSet.size());
---
>         metaMap.put("timestamp", DbColumnType.INT);
>         if (!metaMap.equals(engine.getMetadata(newName))) {
>             throw new DatabaseEngineRuntimeException("Renamed table metadata does not match");
>         }
3556c2978,2981
<         assertEquals("Content ok?", 20, (int) resultSet.get(0).get("timestamp").toInt());
---
>         List<Map<String, ResultColumn>> resultSet = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table(newName)));
>         if (resultSet.size() != 1 || resultSet.get(0).get("timestamp").toInt() != 20) {
>             throw new DatabaseEngineRuntimeException("Renamed table data incorrect");
>         }
3561,3565d2985
<     /**
<      * Drops a list of tables silently (i.e. if it fails, it will just keep on).
<      *
<      * @param tables The tables that we want to drop.
<      */
3569c2989
<                 engine.dropEntity(dbEntity().name(table).build());
---
>                 engine.dropEntity(DbEntity.builder().name(table).build());
3579,3586c2999,3002
<         engine.persist("TEST", entry().set("COL1", 5).set("COL5", "teste")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 5).set("COL5", "TESTE")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 5).set("COL5", "TeStE")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 5).set("COL5", "tesTte")
<                 .build());
---
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 5).set("COL5", "teste").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 5).set("COL5", "TESTE").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 5).set("COL5", "TeStE").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 5).set("COL5", "tesTte").build());
3589c3005
<             select(all()).from(table("TEST")).where(like(udf("lower", column("COL5")), k("%teste%")))
---
>             SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")).where(SqlBuilder.like(SqlBuilder.udf("lower", SqlBuilder.column("COL5")), SqlBuilder.k("%teste%")))
3591,3594c3007,3013
<         assertEquals(3, query.size());
<         query = engine.query(select(all()).from(table("TEST")).where(like(udf("lower", column("COL5")), k("%tt%"))));
<         assertEquals(1, query.size());
< 
---
>         if (query.size() != 3) {
>             throw new DatabaseEngineRuntimeException("LIKE with transformation returned incorrect number of rows");
>         }
>         query = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")).where(SqlBuilder.like(SqlBuilder.udf("lower", SqlBuilder.column("COL5")), SqlBuilder.k("%tt%"))));
>         if (query.size() != 1) {
>             throw new DatabaseEngineRuntimeException("LIKE with transformation (second check) returned incorrect number of rows");
>         }
3599,3600c3018
<         DbEntity entity =
<                 dbEntity()
---
>         DbEntity entity = DbEntity.builder()
3602,3606c3020,3024
<                         .addColumn("COL1", INT)
<                         .addColumn("COL2", BOOLEAN)
<                         .addColumn("COL3", DOUBLE)
<                         .addColumn("COL4", LONG, true)
<                         .addColumn("COL5", STRING)
---
>                         .addColumn("COL1", DbColumnType.INT)
>                         .addColumn("COL2", DbColumnType.BOOLEAN)
>                         .addColumn("COL3", DbColumnType.DOUBLE)
>                         .addColumn("COL4", DbColumnType.LONG, true)
>                         .addColumn("COL5", DbColumnType.STRING)
3609,3615c3027,3031
<         engine.persist("TEST", entry().set("COL1", 1).set("COL2", true)
<                 .build());
<         List<Map<String, ResultColumn>> test = engine.query(select(all()).from(table("TEST")));
<         assertEquals("col1 ok?", 1, (int) test.get(0).get("COL1").toInt());
<         assertTrue("col2 ok?", test.get(0).get("COL2").toBoolean());
<         assertEquals("col4 ok?", 1L, (long) test.get(0).get("COL4").toLong());
< 
---
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 1).set("COL2", true).build());
>         List<Map<String, ResultColumn>> test = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")));
>         if (test.get(0).get("COL1").toInt() != 1 || !test.get(0).get("COL2").toBoolean() || test.get(0).get("COL4").toLong() != 1L) {
>             throw new DatabaseEngineRuntimeException("Sequence on long column test failed");
>         }
3620,3621c3036
<         DbEntity entity =
<                 dbEntity()
---
>         DbEntity entity = DbEntity.builder()
3623,3667c3038,3091
<                         .addColumn("COL1", INT)
<                         .addColumn("COL2", BOOLEAN)
<                         .addColumn("COL3", DOUBLE)
<                         .addColumn("COL4", LONG, true)
<                         .addColumn("COL5", STRING)
<                         .build();
<         engine.addEntity(entity);
<         engine.persist("TEST", entry().set("COL1", 1).set("COL2", true)
<                 .build());
<         List<Map<String, ResultColumn>> test = engine.query(select(all()).from(table("TEST")).orderby(column("COL4")));
<         assertEquals("col4 ok?", 1L, (long) test.get(0).get("COL4").toLong());
< 
<         engine.persist("TEST", entry().set("COL1", 1).set("COL2", true).set("COL4", 2)
<                 .build(), false);
<         test = engine.query(select(all()).from(table("TEST")).orderby(column("COL4")));
<         assertEquals("col4 ok?", 2L, (long) test.get(1).get("COL4").toLong());
< 
<         engine.persist("TEST", entry().set("COL1", 1).set("COL2", true).build());
<         test = engine.query(select(all()).from(table("TEST")).orderby(column("COL4")));
<         assertEquals("col4 ok?", 3L, (long) test.get(2).get("COL4").toLong());
< 
<         engine.persist("TEST", entry().set("COL1", 1).set("COL2", true).set("COL4", 4)
<                 .build(), false);
<         test = engine.query(select(all()).from(table("TEST")).orderby(column("COL4")));
<         assertEquals("col4 ok?", 4L, (long) test.get(3).get("COL4").toLong());
< 
<         engine.persist("TEST", entry().set("COL1", 1).set("COL2", true)
<                 .build());
<         test = engine.query(select(all()).from(table("TEST")).orderby(column("COL4")));
<         assertEquals("col4 ok?", 5L, (long) test.get(4).get("COL4").toLong());
< 
<         engine.persist("TEST", entry().set("COL1", 1).set("COL2", true).set("COL4", 6)
<                 .build(), false);
<         test = engine.query(select(all()).from(table("TEST")).orderby(column("COL4")));
<         assertEquals("col4 ok?", 6L, (long) test.get(5).get("COL4").toLong());
< 
<         engine.persist("TEST", entry().set("COL1", 1).set("COL2", true).set("COL4", 7)
<                 .build(), false);
<         test = engine.query(select(all()).from(table("TEST")).orderby(column("COL4")));
<         assertEquals("col4 ok?", 7L, (long) test.get(6).get("COL4").toLong());
< 
<         engine.persist("TEST", entry().set("COL1", 1).set("COL2", true)
<                 .build());
<         test = engine.query(select(all()).from(table("TEST")).orderby(column("COL4")));
<         assertEquals("col4 ok?", 8L, (long) test.get(7).get("COL4").toLong());
---
>                         .addColumn("COL1", DbColumnType.INT)
>                         .addColumn("COL2", DbColumnType.BOOLEAN)
>                         .addColumn("COL3", DbColumnType.DOUBLE)
>                         .addColumn("COL4", DbColumnType.LONG, true)
>                         .addColumn("COL5", DbColumnType.STRING)
>                         .build();
>         engine.addEntity(entity);
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 1).set("COL2", true).build());
>         List<Map<String, ResultColumn>> test = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")).orderby(SqlBuilder.column("COL4")));
>         if (test.get(0).get("COL4").toLong() != 1L) {
>             throw new DatabaseEngineRuntimeException("AutoInc resume test initial failed");
>         }
> 
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 1).set("COL2", true).set("COL4", 2).build(), false);
>         test = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")).orderby(SqlBuilder.column("COL4")));
>         if (test.get(1).get("COL4").toLong() != 2L) {
>             throw new DatabaseEngineRuntimeException("AutoInc resume test second failed");
>         }
> 
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 1).set("COL2", true).build());
>         test = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")).orderby(SqlBuilder.column("COL4")));
>         if (test.get(2).get("COL4").toLong() != 3L) {
>             throw new DatabaseEngineRuntimeException("AutoInc resume test third failed");
>         }
> 
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 1).set("COL2", true).set("COL4", 4).build(), false);
>         test = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")).orderby(SqlBuilder.column("COL4")));
>         if (test.get(3).get("COL4").toLong() != 4L) {
>             throw new DatabaseEngineRuntimeException("AutoInc resume test fourth failed");
>         }
> 
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 1).set("COL2", true).build());
>         test = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")).orderby(SqlBuilder.column("COL4")));
>         if (test.get(4).get("COL4").toLong() != 5L) {
>             throw new DatabaseEngineRuntimeException("AutoInc resume test fifth failed");
>         }
> 
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 1).set("COL2", true).set("COL4", 6).build(), false);
>         test = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")).orderby(SqlBuilder.column("COL4")));
>         if (test.get(5).get("COL4").toLong() != 6L) {
>             throw new DatabaseEngineRuntimeException("AutoInc resume test sixth failed");
>         }
> 
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 1).set("COL2", true).set("COL4", 7).build(), false);
>         test = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")).orderby(SqlBuilder.column("COL4")));
>         if (test.get(6).get("COL4").toLong() != 7L) {
>             throw new DatabaseEngineRuntimeException("AutoInc resume test seventh failed");
>         }
> 
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 1).set("COL2", true).build());
>         test = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")).orderby(SqlBuilder.column("COL4")));
>         if (test.get(7).get("COL4").toLong() != 8L) {
>             throw new DatabaseEngineRuntimeException("AutoInc resume test eighth failed");
>         }
3670,3674d3093
<     /**
<      * Creates a {@link DbEntity} with 5 columns to be used in the tests.
<      *
<      * @throws DatabaseEngineException If something goes wrong creating the entity.
<      */
3676c3095
<         final DbEntity entity = dbEntity()
---
>         final DbEntity entity = DbEntity.builder()
3678,3682c3097,3101
<                 .addColumn("COL1", INT)
<                 .addColumn("COL2", BOOLEAN)
<                 .addColumn("COL3", DOUBLE)
<                 .addColumn("COL4", LONG)
<                 .addColumn("COL5", STRING)
---
>                 .addColumn("COL1", DbColumnType.INT)
>                 .addColumn("COL2", DbColumnType.BOOLEAN)
>                 .addColumn("COL3", DbColumnType.DOUBLE)
>                 .addColumn("COL4", DbColumnType.LONG)
>                 .addColumn("COL5", DbColumnType.STRING)
3688,3692d3106
<     /**
<      * Creates a {@link DbEntity} with 5 columns being the first the primary key to be used in the tests.
<      *
<      * @throws DatabaseEngineException If something goes wrong creating the entity.
<      */
3694,3699c3108,3114
<         final DbEntity entity = dbEntity().name("TEST")
<                                           .addColumn("COL1", INT)
<                                           .addColumn("COL2", BOOLEAN)
<                                           .addColumn("COL3", DOUBLE)
<                                           .addColumn("COL4", LONG)
<                                           .addColumn("COL5", STRING)
---
>         final DbEntity entity = DbEntity.builder()
>                                           .name("TEST")
>                                           .addColumn("COL1", DbColumnType.INT)
>                                           .addColumn("COL2", DbColumnType.BOOLEAN)
>                                           .addColumn("COL3", DbColumnType.DOUBLE)
>                                           .addColumn("COL4", DbColumnType.LONG)
>                                           .addColumn("COL5", DbColumnType.STRING)
3707c3122
<         DbEntity entity = dbEntity()
---
>         DbEntity entity = DbEntity.builder()
3709c3124
<                 .addColumn("COL1", INT, true)
---
>                 .addColumn("COL1", DbColumnType.INT, true)
3715c3130
<         entity = dbEntity()
---
>         entity = DbEntity.builder()
3717c3132
<                 .addColumn("COL1", INT, true)
---
>                 .addColumn("COL1", DbColumnType.INT, true)
3723c3138
<         entity = dbEntity()
---
>         entity = DbEntity.builder()
3725,3737c3140,3143
<                 .addColumn("COL1", INT)
<                 .addColumn("COL2", INT)
<                 .addFk(dbFk()
<                                 .addColumn("COL1")
<                                 .referencedTable("USER")
<                                 .addReferencedColumn("COL1")
<                                 .build(),
<                         dbFk()
<                                 .addColumn("COL2")
<                                 .referencedTable("ROLE")
<                                 .addReferencedColumn("COL1")
<                                 .build()
<                 )
---
>                 .addColumn("COL1", DbColumnType.INT)
>                 .addColumn("COL2", DbColumnType.INT)
>                 .addFk(DbFk.builder().addColumn("COL1").referencedTable("USER").addReferencedColumn("COL1").build(),
>                        DbFk.builder().addColumn("COL2").referencedTable("ROLE").addReferencedColumn("COL1").build())
3748,3761c3154,3167
<         engine.persist("TEST", entry().set("COL1", 1).set("COL5", "teste")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 2).set("COL5", "TESTE")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 3).set("COL5", "TeStE")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 4).set("COL5", "tesTte")
<                 .build());
< 
<         final List<Map<String, ResultColumn>> query = engine.query(select(all()).from(table("TEST")).where(eq(column("COL1"), k(1))).andWhere(eq(column("COL5"), k("teste"))));
< 
<         assertEquals("Resultset must have only one result", 1, query.size());
<         assertEquals("COL1 must be 1", 1, query.get(0).get("COL1").toInt().intValue());
<         assertEquals("COL5 must be teste", "teste", query.get(0).get("COL5").toString());
---
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 1).set("COL5", "teste").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 2).set("COL5", "TESTE").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 3).set("COL5", "TeStE").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 4).set("COL5", "tesTte").build());
> 
>         final List<Map<String, ResultColumn>> query = engine.query(SqlBuilder.select(SqlBuilder.all())
>                 .from(SqlBuilder.table("TEST"))
>                 .where(SqlBuilder.eq(SqlBuilder.column("COL1"), SqlBuilder.k(1))).andWhere(SqlBuilder.eq(SqlBuilder.column("COL5"), SqlBuilder.k("teste"))));
> 
>         if (query.size() != 1 ||
>             query.get(0).get("COL1").toInt() != 1 ||
>             !"teste".equals(query.get(0).get("COL5").toString())) {
>             throw new DatabaseEngineRuntimeException("AndWhere query returned incorrect result");
>         }
3768,3775c3174,3177
<         engine.persist("TEST", entry().set("COL1", 1).set("COL5", "teste")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 2).set("COL5", "TESTE")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 3).set("COL5", "TeStE")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 4).set("COL5", "tesTte")
<                 .build());
---
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 1).set("COL5", "teste").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 2).set("COL5", "TESTE").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 3).set("COL5", "TeStE").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 4).set("COL5", "tesTte").build());
3778,3791c3180,3183
<                 select(all())
<                         .from(table("TEST"))
<                         .where(
<                                 or(
<                                         eq(column("COL1"), k(1)),
<                                         eq(column("COL1"), k(4))
<                                 )
<                         )
<                         .andWhere(
<                                 or(
<                                         eq(column("COL5"), k("teste")),
<                                         eq(column("COL5"), k("TESTE"))
<                                 )
<                         )
---
>                 SqlBuilder.select(SqlBuilder.all())
>                         .from(SqlBuilder.table("TEST"))
>                         .where(SqlBuilder.or(SqlBuilder.eq(SqlBuilder.column("COL1"), SqlBuilder.k(1)), SqlBuilder.eq(SqlBuilder.column("COL1"), SqlBuilder.k(4))))
>                         .andWhere(SqlBuilder.or(SqlBuilder.eq(SqlBuilder.column("COL5"), SqlBuilder.k("teste")), SqlBuilder.eq(SqlBuilder.column("COL5"), SqlBuilder.k("TESTE"))))
3794,3796c3186,3190
<         assertEquals("Resultset must have only one result", 1, query.size());
<         assertEquals("COL1 must be 1", 1, query.get(0).get("COL1").toInt().intValue());
<         assertEquals("COL5 must be teste", "teste", query.get(0).get("COL5").toString());
---
>         if (query.size() != 1 ||
>             query.get(0).get("COL1").toInt() != 1 ||
>             !"teste".equals(query.get(0).get("COL5").toString())) {
>             throw new DatabaseEngineRuntimeException("AndWhere multiple query returned incorrect result");
>         }
3803,3810c3197,3200
<         engine.persist("TEST", entry().set("COL1", 1).set("COL5", "teste")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 2).set("COL5", "TESTE")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 3).set("COL5", "TeStE")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 4).set("COL5", "tesTte")
<                 .build());
---
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 1).set("COL5", "teste").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 2).set("COL5", "TESTE").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 3).set("COL5", "TeStE").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 4).set("COL5", "tesTte").build());
3813,3826c3203,3206
<                 select(all())
<                         .from(table("TEST"))
<                         .where(
<                                 or(
<                                         eq(column("COL1"), k(1)),
<                                         eq(column("COL1"), k(4))
<                                 )
<                         )
<                         .andWhere(
<                                 or(
<                                         eq(column("COL5"), k("teste")),
<                                         eq(column("COL5"), k("tesTte"))
<                                 )
<                         )
---
>                 SqlBuilder.select(SqlBuilder.all())
>                         .from(SqlBuilder.table("TEST"))
>                         .where(SqlBuilder.or(SqlBuilder.eq(SqlBuilder.column("COL1"), SqlBuilder.k(1)), SqlBuilder.eq(SqlBuilder.column("COL1"), SqlBuilder.k(4))))
>                         .andWhere(SqlBuilder.or(SqlBuilder.eq(SqlBuilder.column("COL5"), SqlBuilder.k("teste")), SqlBuilder.eq(SqlBuilder.column("COL5"), SqlBuilder.k("tesTte"))))
3829,3833c3209,3211
<         assertEquals("Resultset must have only one result", 2, query.size());
<         assertEquals("COL1 must be 1", 1, query.get(0).get("COL1").toInt().intValue());
<         assertEquals("COL5 must be teste", "teste", query.get(0).get("COL5").toString());
<         assertEquals("COL1 must be 1", 4, query.get(1).get("COL1").toInt().intValue());
<         assertEquals("COL5 must be teste", "tesTte", query.get(1).get("COL5").toString());
---
>         if (query.size() != 2) {
>             throw new DatabaseEngineRuntimeException("AndWhere multiple enclosed query returned incorrect result count");
>         }
3840,3847c3218,3221
<         engine.persist("TEST", entry().set("COL1", 1).set("COL5", "TESTE")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 1).set("COL5", "teste")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 2).set("COL5", "TeStE")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 2).set("COL5", "tesTte")
<                 .build());
---
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 1).set("COL5", "TESTE").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 1).set("COL5", "teste").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 2).set("COL5", "TeStE").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 2).set("COL5", "tesTte").build());
3850,3853c3224,3227
<                 select(column("COL1"), stringAgg(column("COL5")).alias("agg"))
<                         .from(table("TEST"))
<                         .groupby(column("COL1"))
<                         .orderby(column("COL1").asc())
---
>                 SqlBuilder.select(SqlBuilder.column("COL1"), SqlBuilder.stringAgg(SqlBuilder.column("COL5")).alias("agg"))
>                         .from(SqlBuilder.table("TEST"))
>                         .groupby(SqlBuilder.column("COL1"))
>                         .orderby(SqlBuilder.column("COL1").asc())
3856,3860c3230,3232
<         assertEquals("Resultset must have only 2 results", 2, query.size());
<         assertEquals("COL1 must be 1", 1, query.get(0).get("COL1").toInt().intValue());
<         assertEquals("COL5 must be TESTE,teste", "TESTE,teste", query.get(0).get("agg").toString());
<         assertEquals("COL1 must be 2", 2, query.get(1).get("COL1").toInt().intValue());
<         assertEquals("COL5 must be TeStE,tesTte", "TeStE,tesTte", query.get(1).get("agg").toString());
---
>         if (query.size() != 2) {
>             throw new DatabaseEngineRuntimeException("StringAgg query returned incorrect result count");
>         }
3867,3874c3239,3242
<         engine.persist("TEST", entry().set("COL1", 1).set("COL5", "TESTE")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 1).set("COL5", "teste")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 2).set("COL5", "TeStE")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 2).set("COL5", "tesTte")
<                 .build());
---
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 1).set("COL5", "TESTE").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 1).set("COL5", "teste").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 2).set("COL5", "TeStE").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 2).set("COL5", "tesTte").build());
3877,3880c3245,3248
<                 select(column("COL1"), stringAgg(column("COL5")).delimiter(';').alias("agg"))
<                         .from(table("TEST"))
<                         .groupby(column("COL1"))
<                         .orderby(column("COL1").asc())
---
>                 SqlBuilder.select(SqlBuilder.column("COL1"), SqlBuilder.stringAgg(SqlBuilder.column("COL5")).delimiter(';').alias("agg"))
>                         .from(SqlBuilder.table("TEST"))
>                         .groupby(SqlBuilder.column("COL1"))
>                         .orderby(SqlBuilder.column("COL1").asc())
3882,3887d3249
< 
<         assertEquals("Resultset must have only 2 results", 2, query.size());
<         assertEquals("COL1 must be 1", 1, query.get(0).get("COL1").toInt().intValue());
<         assertEquals("COL5 must be TESTE;teste", "TESTE;teste", query.get(0).get("agg").toString());
<         assertEquals("COL1 must be 2", 2, query.get(1).get("COL1").toInt().intValue());
<         assertEquals("COL5 must be TeStE;tesTte", "TeStE;tesTte", query.get(1).get("agg").toString());
3892,3893c3254,3256
<         assumeTrue("This test is only valid for engines that support StringAggDistinct",
<                 this.engine.isStringAggDistinctCapable());
---
>         if (!engine.isStringAggDistinctCapable()) {
>             return;
>         }
3897,3904c3260,3263
<         engine.persist("TEST", entry().set("COL1", 1).set("COL5", "teste")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 1).set("COL5", "teste")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 2).set("COL5", "TeStE")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 2).set("COL5", "tesTte")
<                 .build());
---
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 1).set("COL5", "teste").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 1).set("COL5", "teste").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 2).set("COL5", "TeStE").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 2).set("COL5", "tesTte").build());
3907,3910c3266,3269
<                 select(column("COL1"), stringAgg(column("COL5")).distinct().alias("agg"))
<                         .from(table("TEST"))
<                         .groupby(column("COL1"))
<                         .orderby(column("COL1").asc())
---
>                 SqlBuilder.select(SqlBuilder.column("COL1"), SqlBuilder.stringAgg(SqlBuilder.column("COL5")).distinct().alias("agg"))
>                         .from(SqlBuilder.table("TEST"))
>                         .groupby(SqlBuilder.column("COL1"))
>                         .orderby(SqlBuilder.column("COL1").asc())
3912,3917d3270
< 
<         assertEquals("Resultset must have only 2 results", 2, query.size());
<         assertEquals("COL1 must be 1", 1, query.get(0).get("COL1").toInt().intValue());
<         assertEquals("COL5 must be teste", "teste", query.get(0).get("agg").toString());
<         assertEquals("COL1 must be 2", 2, query.get(1).get("COL1").toInt().intValue());
<         assertEquals("COL5 must be TeStE,tesTte", "TeStE,tesTte", query.get(1).get("agg").toString());
3924,3931c3277,3280
<         engine.persist("TEST", entry().set("COL1", 1).set("COL5", "TESTE")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 1).set("COL5", "teste")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 2).set("COL5", "TeStE")
<                 .build());
<         engine.persist("TEST", entry().set("COL1", 2).set("COL5", "tesTte")
<                 .build());
---
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 1).set("COL5", "TESTE").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 1).set("COL5", "teste").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 2).set("COL5", "TeStE").build());
>         engine.persist("TEST", EntityEntry.builder().set("COL1", 2).set("COL5", "tesTte").build());
3934,3937c3283,3286
<                 select(column("COL1"), stringAgg(column("COL1")).alias("agg"))
<                         .from(table("TEST"))
<                         .groupby(column("COL1"))
<                         .orderby(column("COL1").asc())
---
>                 SqlBuilder.select(SqlBuilder.column("COL1"), SqlBuilder.stringAgg(SqlBuilder.column("COL1")).alias("agg"))
>                         .from(SqlBuilder.table("TEST"))
>                         .groupby(SqlBuilder.column("COL1"))
>                         .orderby(SqlBuilder.column("COL1").asc())
3939,3944d3287
< 
<         assertEquals("Resultset must have only 2 results", 2, query.size());
<         assertEquals("COL1 must be 1", 1, query.get(0).get("COL1").toInt().intValue());
<         assertEquals("COL5 must be 1,1", "1,1", query.get(0).get("agg").toString());
<         assertEquals("COL1 must be 2", 2, query.get(1).get("COL1").toInt().intValue());
<         assertEquals("COL5 must be 2,2", "2,2", query.get(1).get("agg").toString());
3948c3291
<     @Category(SkipTestCockroachDB.class)
---
>     @Category(com.feedzai.commons.sql.abstraction.engine.impl.cockroach.SkipTestCockroachDB.class)
3950,3951c3293
<         DbEntity entity =
<                 dbEntity()
---
>         DbEntity entity = DbEntity.builder()
3953,3957c3295,3299
<                         .addColumn("COL1", INT)
<                         .addColumn("COL2", BOOLEAN)
<                         .addColumn("COL3", DOUBLE)
<                         .addColumn("COL4", LONG)
<                         .addColumn("COL5", STRING)
---
>                 .addColumn("COL1", DbColumnType.INT)
>                 .addColumn("COL2", DbColumnType.BOOLEAN)
>                 .addColumn("COL3", DbColumnType.DOUBLE)
>                 .addColumn("COL4", DbColumnType.LONG)
>                 .addColumn("COL5", DbColumnType.STRING)
3961c3303
<         engine.executeUpdate(dropPK(table("TEST")));
---
>         engine.executeUpdate(SqlBuilder.dropPK(SqlBuilder.table("TEST")));
3965c3307
<     @Category(SkipTestCockroachDB.class)
---
>     @Category(com.feedzai.commons.sql.abstraction.engine.impl.cockroach.SkipTestCockroachDB.class)
3967,3968c3309
<         DbEntity entity =
<                 dbEntity()
---
>         DbEntity entity = DbEntity.builder()
3970,3974c3311,3315
<                         .addColumn("COL1", INT)
<                         .addColumn("COL2", BOOLEAN)
<                         .addColumn("COL3", DOUBLE)
<                         .addColumn("COL4", LONG)
<                         .addColumn("COL5", STRING)
---
>                 .addColumn("COL1", DbColumnType.INT)
>                 .addColumn("COL2", DbColumnType.BOOLEAN)
>                 .addColumn("COL3", DbColumnType.DOUBLE)
>                 .addColumn("COL4", DbColumnType.LONG)
>                 .addColumn("COL5", DbColumnType.STRING)
3978c3319
<         engine.executeUpdate(dropPK(table("TEST")));
---
>         engine.executeUpdate(SqlBuilder.dropPK(SqlBuilder.table("TEST")));
3983,3984c3324
<         DbEntity entity =
<                 dbEntity()
---
>         DbEntity entity = DbEntity.builder()
3986,3990c3326,3330
<                         .addColumn("COL1", INT)
<                         .addColumn("COL2", BOOLEAN)
<                         .addColumn("COL3", DOUBLE)
<                         .addColumn("COL4", LONG)
<                         .addColumn("COL5", STRING)
---
>                 .addColumn("COL1", DbColumnType.INT)
>                 .addColumn("COL2", DbColumnType.BOOLEAN)
>                 .addColumn("COL3", DbColumnType.DOUBLE)
>                 .addColumn("COL4", DbColumnType.LONG)
>                 .addColumn("COL5", DbColumnType.STRING)
3995,3997c3335
<         engine.executeUpdate(new AlterColumn(table("TEST"), new DbColumn.Builder().name("COL1").type(DbColumnType.INT).addConstraint(DbColumnConstraint
<                 .NOT_NULL)
<                 .build()));
---
>         engine.executeUpdate(new AlterColumn(SqlBuilder.table("TEST"), new DbColumn.Builder().name("COL1").type(DbColumnType.INT).addConstraint(DbColumnConstraint.NOT_NULL).build()));
4001c3339
<     @Category(SkipTestCockroachDB.class)
---
>     @Category(com.feedzai.commons.sql.abstraction.engine.impl.cockroach.SkipTestCockroachDB.class)
4003,4004c3341
<         DbEntity entity =
<                 dbEntity()
---
>         DbEntity entity = DbEntity.builder()
4006,4010c3343,3347
<                         .addColumn("COL1", INT)
<                         .addColumn("COL2", BOOLEAN)
<                         .addColumn("COL3", DOUBLE)
<                         .addColumn("COL4", LONG)
<                         .addColumn("COL5", STRING)
---
>                 .addColumn("COL1", DbColumnType.INT)
>                 .addColumn("COL2", DbColumnType.BOOLEAN)
>                 .addColumn("COL3", DbColumnType.DOUBLE)
>                 .addColumn("COL4", DbColumnType.LONG)
>                 .addColumn("COL5", DbColumnType.STRING)
4015,4016c3352
<         engine.executeUpdate(new AlterColumn(table("TEST"), dbColumn().name("COL1").type(DbColumnType.STRING)
<                 .build()));
---
>         engine.executeUpdate(new AlterColumn(SqlBuilder.table("TEST"), SqlBuilder.dbColumn().name("COL1").type(DbColumnType.STRING).build()));
4021,4022c3357
<         DbEntity.Builder entity =
<                 dbEntity()
---
>         DbEntity.Builder entity = DbEntity.builder()
4024,4027c3359,3362
<                         .addColumn("COL1", INT, new K(1))
<                         .addColumn("COL2", BOOLEAN, new K(false))
<                         .addColumn("COL3", DOUBLE, new K(2.2d))
<                         .addColumn("COL4", LONG, new K(3L))
---
>                 .addColumn("COL1", DbColumnType.INT, SqlBuilder.k(1))
>                 .addColumn("COL2", DbColumnType.BOOLEAN, SqlBuilder.k(false))
>                 .addColumn("COL3", DbColumnType.DOUBLE, SqlBuilder.k(2.2d))
>                 .addColumn("COL4", DbColumnType.LONG, SqlBuilder.k(3L))
4033c3368
<         engine.executeUpdate("INSERT INTO " + quotize("TEST", ec) + " (" + quotize("COL1", ec) + ") VALUES (10)");
---
>         engine.executeUpdate("INSERT INTO " + SqlBuilder.quotize("TEST", ec) + " (" + SqlBuilder.quotize("COL1", ec) + ") VALUES (10)");
4035,4036c3370
<         List<Map<String, ResultColumn>> test = engine.query(select(all()).from(table("TEST")));
<         assertEquals("Check size of records", 1, test.size());
---
>         List<Map<String, ResultColumn>> test = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")));
4038,4042c3372,3377
<         assertEquals("Check COL1", 10, record.get("COL1").toInt().intValue());
<         assertEquals("Check COL2", false, record.get("COL2").toBoolean());
<         assertEquals("Check COL3", 2.2d, record.get("COL3").toDouble(), 0);
<         assertEquals("Check COL4", 3L, record.get("COL4").toLong().longValue());
< 
---
>         if (record.get("COL1").toInt() != 10 ||
>             record.get("COL2").toBoolean() ||
>             Math.abs(record.get("COL3").toDouble() - 2.2d) > 1e-9 ||
>             record.get("COL4").toLong() != 3L) {
>             throw new DatabaseEngineRuntimeException("Default values not applied correctly");
>         }
4045,4047c3380,3382
<                 .addColumn("COL5", STRING, new K("mantorras"), NOT_NULL)
<                 .addColumn("COL6", BOOLEAN, new K(true), NOT_NULL)
<                 .addColumn("COL7", INT, new K(7), NOT_NULL)
---
>                 .addColumn("COL5", DbColumnType.STRING, SqlBuilder.k("mantorras"), DbColumnConstraint.NOT_NULL)
>                 .addColumn("COL6", DbColumnType.BOOLEAN, SqlBuilder.k(true), DbColumnConstraint.NOT_NULL)
>                 .addColumn("COL7", DbColumnType.INT, SqlBuilder.k(7), DbColumnConstraint.NOT_NULL)
4054c3389
<         propertiesCreate.setProperty(SCHEMA_POLICY, "create");
---
>         propertiesCreate.setProperty("SCHEMA_POLICY", "create");
4059,4060c3394
<         test = connection2.query(select(all()).from(table("TEST")));
<         assertEquals("Check size of records", 1, test.size());
---
>         test = connection2.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")));
4062,4068c3396,3404
<         assertEquals("Check COL1", 10, record.get("COL1").toInt().intValue());
<         assertEquals("Check COL2", false, record.get("COL2").toBoolean());
<         assertEquals("Check COL3", 2.2d, record.get("COL3").toDouble(), 1e-9);
<         assertEquals("Check COL4", 3L, record.get("COL4").toLong().longValue());
<         assertEquals("Check COL5", "mantorras", record.get("COL5").toString());
<         assertEquals("Check COL6", true, record.get("COL6").toBoolean());
<         assertEquals("Check COL7", 7, record.get("COL7").toInt().intValue());
---
>         if (record.get("COL1").toInt() != 10 ||
>             record.get("COL2").toBoolean() ||
>             Math.abs(record.get("COL3").toDouble() - 2.2d) > 1e-9 ||
>             record.get("COL4").toLong() != 3L ||
>             !"mantorras".equals(record.get("COL5").toString()) ||
>             !record.get("COL6").toBoolean() ||
>             record.get("COL7").toInt() != 7) {
>             throw new DatabaseEngineRuntimeException("Updated table with defaults did not match expected");
>         }
4074,4075c3410
<         DbEntity.Builder entity =
<                 dbEntity()
---
>         DbEntity.Builder entity = DbEntity.builder()
4077,4080c3412,3415
<                         .addColumn("COL1", INT, new K(1))
<                         .addColumn("COL2", BOOLEAN, new K(false), NOT_NULL)
<                         .addColumn("COL3", DOUBLE, new K(2.2d))
<                         .addColumn("COL4", LONG, new K(3L))
---
>                 .addColumn("COL1", DbColumnType.INT, SqlBuilder.k(1))
>                 .addColumn("COL2", DbColumnType.BOOLEAN, SqlBuilder.k(false), DbColumnConstraint.NOT_NULL)
>                 .addColumn("COL3", DbColumnType.DOUBLE, SqlBuilder.k(2.2d))
>                 .addColumn("COL4", DbColumnType.LONG, SqlBuilder.k(3L))
4085,4086c3420,3421
<         engine.persist("TEST", entry().build());
<         Map<String, ResultColumn> row = engine.query(select(all()).from(table("TEST"))).get(0);
---
>         engine.persist("TEST", EntityEntry.builder().build());
>         Map<String, ResultColumn> row = engine.query(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST"))).get(0);
4088,4091c3423,3428
<         assertEquals("", 1, row.get("COL1").toInt().intValue());
<         assertFalse("", row.get("COL2").toBoolean());
<         assertEquals("", 2.2d, row.get("COL3").toDouble(), 0D);
<         assertEquals("", 3L, row.get("COL4").toLong().longValue());
---
>         if (row.get("COL1").toInt() != 1 ||
>             row.get("COL2").toBoolean() ||
>             Math.abs(row.get("COL3").toDouble() - 2.2d) > 0.0 ||
>             row.get("COL4").toLong() != 3L) {
>             throw new DatabaseEngineRuntimeException("Default value on boolean columns test failed");
>         }
4097,4098c3434,3437
<         engine.persist("TEST", entry().set("COL5", "ola").build());
<         assertEquals("text is uppercase", "OLA", engine.query(select(upper(column("COL5")).alias("RES")).from(table("TEST"))).get(0).get("RES").toString());
---
>         engine.persist("TEST", EntityEntry.builder().set("COL5", "ola").build());
>         if (!"OLA".equals(engine.query(SqlBuilder.select(SqlBuilder.upper(SqlBuilder.column("COL5")).alias("RES")).from(SqlBuilder.table("TEST"))).get(0).get("RES").toString())) {
>             throw new DatabaseEngineRuntimeException("Upper test failed");
>         }
4104,4105c3443,3446
<         engine.persist("TEST", entry().set("COL5", "OLA").build());
<         assertEquals("text is lowercase", "ola", engine.query(select(lower(column("COL5")).alias("RES")).from(table("TEST"))).get(0).get("RES").toString());
---
>         engine.persist("TEST", EntityEntry.builder().set("COL5", "OLA").build());
>         if (!"ola".equals(engine.query(SqlBuilder.select(SqlBuilder.lower(SqlBuilder.column("COL5")).alias("RES")).from(SqlBuilder.table("TEST"))).get(0).get("RES").toString())) {
>             throw new DatabaseEngineRuntimeException("Lower test failed");
>         }
4111,4113c3452,3455
<         engine.persist("TEST", entry().set("COL5", "OLA").build());
<         assertEquals("text is uppercase", "ola", engine.query(select(f("LOWER", column("COL5")).alias("RES")).from(table("TEST"))).get(0).get("RES")
<                 .toString());
---
>         engine.persist("TEST", EntityEntry.builder().set("COL5", "OLA").build());
>         if (!"ola".equals(engine.query(SqlBuilder.select(SqlBuilder.f("LOWER", SqlBuilder.column("COL5")).alias("RES")).from(SqlBuilder.table("TEST"))).get(0).get("RES").toString())) {
>             throw new DatabaseEngineRuntimeException("Internal function test failed");
>         }
4124,4126c3466
<         EntityEntry entry = entry()
<                 .set(map)
<                 .build();
---
>         EntityEntry entry = EntityEntry.builder().set(map).build();
4128c3468,3470
<         assertEquals("entry's hashCode() matches map's hashCode()", map.hashCode(), entry.hashCode());
---
>         if (map.hashCode() != entry.hashCode()) {
>             throw new RuntimeException("EntityEntry hashcode does not match map's hashcode");
>         }
4131,4137d3472
<     /**
<      * Tests that creating a {@link DatabaseEngine} using try-with-resources will close the engine
<      * (and thus the underlying connection to the database) once the block is exited from.
<      *
<      * @throws Exception if something goes wrong while checking if the connection of the engine is closed.
<      * @since 2.1.12
<      */
4140c3475
<         final AtomicReference<Connection> connReference = new AtomicReference<>();
---
>         final AtomicReference<java.sql.Connection> connReference = new AtomicReference<>();
4144,4145c3479,3481
<             assertFalse("close() method should not be called within the try-with-resources block, for an existing DatabaseEngine",
<                     connReference.get().isClosed());
---
>             if (connReference.get().isClosed()) {
>                 throw new RuntimeException("Connection should not be closed within try-with-resources block");
>             }
4148,4149c3484,3486
<         assertTrue("close() method should be called after exiting try-with-resources block, for an existing DatabaseEngine",
<                 connReference.get().isClosed());
---
>         if (!connReference.get().isClosed()) {
>             throw new RuntimeException("Connection should be closed after try-with-resources block");
>         }
4153,4154c3490,3492
<             assertFalse("close() method should not be called within the try-with-resources block, for a DatabaseEngine created in the block",
<                     connReference.get().isClosed());
---
>             if (connReference.get().isClosed()) {
>                 throw new RuntimeException("Connection should not be closed within try-with-resources block");
>             }
4157,4159c3495,3497
<         assertTrue("close() method should be called after exiting try-with-resources block, for a DatabaseEngine created in the block",
<                 connReference.get().isClosed());
< 
---
>         if (!connReference.get().isClosed()) {
>             throw new RuntimeException("Connection should be closed after try-with-resources block");
>         }
4162,4171d3499
<     /**
<      * Test that closing a database engine a 'create-drop' policy with multiple entities closes all insert statements
<      * associated with each entity, regardless of the schema policy used.
<      *
<      * Each entity is associated with 3 prepared statements. This test ensures that 3 PSs per entity are closed.
<      *
<      * @throws DatabaseEngineException  If something goes wrong while adding an entity to the engine.
<      * @throws DatabaseFactoryException If the database engine class specified in the properties does not exist.
<      * @since 2.1.13
<      */
4176,4177c3504
<         // Force the schema policy to be 'create-drop'
<         properties.setProperty(SCHEMA_POLICY, "create-drop");
---
>         properties.setProperty("SCHEMA_POLICY", "create-drop");
4180,4181c3507,3508
<         engine.addEntity(buildEntity("ENTITY-1"));
<         engine.addEntity(buildEntity("ENTITY-2"));
---
>         engine.addEntity(EntityEntryBuilder.buildEntity("ENTITY-1"));
>         engine.addEntity(EntityEntryBuilder.buildEntity("ENTITY-2"));
4183d3509
<         // Force invocation counting to start here
4191d3516
< 
4194,4199d3518
<     /**
<      * Assesses whether the current row count is incremented if the .next()/.nextResult()
<      * methods are called in the iterator.
<      *
<      * @throws DatabaseEngineException If a database access error happens.
<      */
4204d3522
<         // Create 4 entries
4206c3524
<             engine.persist("TEST", entry().set("COL1", i).build());
---
>             engine.persist("TEST", EntityEntry.builder().set("COL1", i).build());
4209c3527
<         final ResultIterator resultIterator = engine.iterator(select(all()).from(table("TEST")));
---
>         final ResultIterator resultIterator = engine.iterator(SqlBuilder.select(SqlBuilder.all()).from(SqlBuilder.table("TEST")));
4211c3529,3531
<         assertEquals("The current row count should be 0 if the iteration hasn't started", 0, resultIterator.getCurrentRowCount());
---
>         if (resultIterator.getCurrentRowCount() != 0) {
>             throw new DatabaseEngineRuntimeException("Row count should be 0 before iteration");
>         }
4213d3532
<         // If the .next() method is called once then the current row count should be updated to 1
4216c3535,3537
<         assertEquals("The current row count is equal to 1", 1,resultIterator.getCurrentRowCount());
---
>         if (resultIterator.getCurrentRowCount() != 1) {
>             throw new DatabaseEngineRuntimeException("Row count should be 1 after one next()");
>         }
4218,4219d3538
<         // If for the same iterator the .nextResult() method is called 3 additional
<         // times then the current row count should be updated to 4
4224c3543,3545
<         assertEquals("The current row count is equal to 4", 4, resultIterator.getCurrentRowCount());
---
>         if (resultIterator.getCurrentRowCount() != 4) {
>             throw new DatabaseEngineRuntimeException("Row count should be 4 after four iterations");
>         }
4227,4233d3547
<     /**
<      * Tests that a {@link com.feedzai.commons.sql.abstraction.dml.K constant expression} with an enum value behaves
<      * as if the enum is a string (obtained from {@link Enum#name()}, both when persisting an entry and when using
<      * the enum value for filtering in a WHERE clause.
<      *
<      * @throws DatabaseEngineException If something goes wrong creating the test entity or persisting entries.
<      */
4238,4239c3552
<         // should fail here if enum is not supported, or it will just put garbage, which will be detected later
<         engine.persist("TEST", entry().set("COL5", TestEnum.TEST_ENUM_VAL).build());
---
>         engine.persist("TEST", EntityEntry.builder().set("COL5", TestEnum.TEST_ENUM_VAL).build());
4241c3554
<         engine.persist("TEST", entry().set("COL5", "something else").build());
---
>         engine.persist("TEST", EntityEntry.builder().set("COL5", "something else").build());
4244,4246c3557,3559
<                 select(all())
<                         .from(table("TEST"))
<                         .where(eq(column("COL5"), k(TestEnum.TEST_ENUM_VAL)))
---
>                 SqlBuilder.select(SqlBuilder.all())
>                         .from(SqlBuilder.table("TEST"))
>                         .where(SqlBuilder.eq(SqlBuilder.column("COL5"), SqlBuilder.k(TestEnum.TEST_ENUM_VAL)))
4249,4255c3562,3564
<         assertThat(results)
<                 .as("One (and only one) result expected.")
<                 .hasSize(1)
<                 .element(0)
<                 .extracting(element -> element.get("COL5").toString())
<                 .as("An enum value should be persisted as its string representation")
<                 .isEqualTo(TestEnum.TEST_ENUM_VAL.name());
---
>         if (results.size() != 1 || !TestEnum.TEST_ENUM_VAL.name().equals(results.get(0).get("COL5").toString())) {
>             throw new DatabaseEngineRuntimeException("Enum test failed");
>         }
4258,4268d3566
<     /**
<      * Tests that when inserting duplicated entries in a table the right exception is returned.
<      *
<      * The steps performed on this test are:
<      * <ol>
<      *     <li>Add duplicated entries in a transaction and fail to persist</li>
<      *     <li>Ensure the exception is a {@link DatabaseEngineUniqueConstraintViolationException}</li>
<      * </ol>
<      *
<      * @throws DatabaseEngineException If there is a problem on {@link DatabaseEngine} operations.
<      */
4273c3571
<         EntityEntry entry = entry().set("COL1", 2)
---
>         EntityEntry entry = EntityEntry.builder().set("COL1", 2)
4280d3577
<         // Add the same entry twice (repeated value for COL1, id)
4282,4287c3579,3588
<         assertThatCode(() -> engine.persist("TEST", entry))
<                 .as("Is unique constraint violation exception")
<                 .isInstanceOf(DatabaseEngineUniqueConstraintViolationException.class)
<                 .as("Encapsulated exception is SQLException")
<                 .hasCauseInstanceOf(SQLException.class)
<                 .hasMessage("Something went wrong persisting the entity [unique_constraint_violation]");
---
>         try {
>             engine.persist("TEST", entry);
>         } catch (final DatabaseEngineException e) {
>             if (!(e instanceof DatabaseEngineUniqueConstraintViolationException) ||
>                 !(e.getCause() instanceof SQLException) ||
>                 !"Something went wrong persisting the entity [unique_constraint_violation]".equals(e.getMessage())) {
>                 throw e;
>             }
>             throw e;
>         }
4290,4300d3590
<     /**
<      * Tests that on a duplicated batch entry situation the right exception is returned.
<      *
<      * The steps performed on this test are:
<      * <ol>
<      *     <li>Add duplicated batch entries to transaction and fail to flush</li>
<      *     <li>Ensure the exception is a {@link DatabaseEngineUniqueConstraintViolationException}</li>
<      * </ol>
<      *
<      * @throws DatabaseEngineException If there is a problem on {@link DatabaseEngine} operations.
<      */
4305c3595
<         EntityEntry entry = entry().set("COL1", 2)
---
>         EntityEntry entry = EntityEntry.builder().set("COL1", 2)
4312d3601
<         // Add the same entry twice (repeated value for COL1, id)
4316,4322c3605,3614
<         // Flush the duplicated entries and check the exception
<         assertThatCode(() -> engine.flush())
<                 .as("Is unique constraint violation exception")
<                 .isInstanceOf(DatabaseEngineUniqueConstraintViolationException.class)
<                 .as("Encapsulated exception is SQLException")
<                 .hasCauseInstanceOf(SQLException.class)
<                 .hasMessage("Something went wrong while flushing [unique_constraint_violation]");
---
>         try {
>             engine.flush();
>         } catch (final DatabaseEngineException e) {
>             if (!(e instanceof DatabaseEngineUniqueConstraintViolationException) ||
>                 !(e.getCause() instanceof SQLException) ||
>                 !"Something went wrong while flushing [unique_constraint_violation]".equals(e.getMessage())) {
>                 throw e;
>             }
>             throw e;
>         }
4325,4327d3616
<     /**
<      * An enum for tests.
<      */
4330d3618
< 
