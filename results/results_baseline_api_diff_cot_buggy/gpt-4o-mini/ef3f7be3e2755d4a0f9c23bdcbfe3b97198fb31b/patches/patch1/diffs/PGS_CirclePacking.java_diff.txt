26,27d25
< import org.tinspin.index.PointDistanceFunction;
< import org.tinspin.index.PointEntryDist;
226c224,225
<                         final PointEntryDist<PVector> nn = tree.query1NN(new double[] { p.x, p.y, largestR }); // find nearest-neighbour circle
---
>                         // Updated to use a new nearest neighbor search method
>                         final PVector nn = findNearestNeighbor(tree, p, largestR); // find nearest-neighbour circle
233,235c232,234
<                         final float dx = p.x - nn.value().x;
<                         final float dy = p.y - nn.value().y;
<                         final float radius = (float) (Math.sqrt(dx * dx + dy * dy) - nn.value().z);
---
>                         final float dx = p.x - nn.x;
>                         final float dy = p.y - nn.y;
>                         final float radius = (float) (Math.sqrt(dx * dx + dy * dy) - nn.z);
662a662,667
> 
>         private static PVector findNearestNeighbor(CoverTree<PVector> tree, PVector point, float largestR) {
>                 // Implement a new nearest neighbor search method here
>                 // This is a placeholder for the actual implementation
>                 return new PVector(0, 0, 0); // Replace with actual nearest neighbor logic
>         }
