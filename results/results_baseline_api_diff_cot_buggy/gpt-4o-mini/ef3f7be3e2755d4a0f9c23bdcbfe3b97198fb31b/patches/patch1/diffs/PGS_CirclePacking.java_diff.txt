26,27d25
< import org.tinspin.index.PointDistanceFunction;
< import org.tinspin.index.PointEntryDist;
203c201,209
<                 final CoverTree<PVector> tree = CoverTree.create(3, 2, circleDistanceMetric);
---
>                 final CoverTree<PVector> tree = CoverTree.create(3, 2, (p1, p2) -> {
>                         final double dx = p1[0] - p2[0];
>                         final double dy = p1[1] - p2[1];
>                         final double dz = p1[2] - p2[2];
> 
>                         double euclideanDistance = Math.sqrt(dx * dx + dy * dy);
>                         double absZDifference = Math.abs(dz);
>                         return euclideanDistance + absZDifference; // negative if inside
>                 });
226c232
<                         final PointEntryDist<PVector> nn = tree.query1NN(new double[] { p.x, p.y, largestR }); // find nearest-neighbour circle
---
>                         final PVector nn = tree.query1NN(new double[] { p.x, p.y, largestR }); // find nearest-neighbour circle
233,235c239,241
<                         final float dx = p.x - nn.value().x;
<                         final float dy = p.y - nn.value().y;
<                         final float radius = (float) (Math.sqrt(dx * dx + dy * dy) - nn.value().z);
---
>                         final float dx = p.x - nn.x;
>                         final float dy = p.y - nn.y;
>                         final float radius = (float) (Math.sqrt(dx * dx + dy * dy) - nn.z);
645,646c651
<         private static final PointDistanceFunction circleDistanceMetric = (p1, p2) -> {
<                 // from https://stackoverflow.com/a/21975136/
---
>         private static final java.util.function.BiFunction<double[], double[], Double> circleDistanceMetric = (p1, p2) -> {
