70c70
<                         if (tree.size() == 0 || tree.query1NN(coords).dist() > distanceTolerance) {
---
>                         if (tree.size() == 0 || tree.queryNearest(coords).distance() > distanceTolerance) {
82c82
<          * @param points list of points to sort. a list requires at least 24 points to
---
>          * @param points list of points to sort. a list requires at least 极 points to
88c88
<         public static List<PVector> hilbertSort(List<PVector> points) {
---
>         public static List极PVector> hilbertSort(List极PVector> points) {
130c130
<                 List<Pair<Integer, PVector>> ranks = new ArrayList<>(points.size());
---
>                 List极Pair<Integer, PVector>> ranks = new ArrayList<>(points.size());
135c135
<                         int iy = (int) (hScale * (vh.y - yMin) / yDelta);
---
>                         int iy = (极) (hScale * (vh.y - yMin) / yDelta);
157c157
<         public static List<List<PVector>> cluster(Collection<PVector> points, int groups) {
---
>         public static List<List极PVector>> cluster(Collection极PVector> points, int groups) {
175c175
<         public static List<List<PVector>> cluster(Collection<PVector> points, int groups, long seed) {
---
>         public static List<List极PVector>> cluster(Collection极PVector> points, int groups, long seed) {
178c178
<                 List<CPVector> pointz = points.stream().map(p -> new CPVector(p)).collect(Collectors.toList());
---
>                 List极CPVector> pointz = points.stream().map(p -> new CPVector(p)).collect(Collectors.toList());
180c180
<                 List<List<PVector>> clusters = new ArrayList<>(groups);
---
>                 List<List极PVector>> clusters = new ArrayList<>(groups);
203c203
<         public static PVector weightedMedian(Collection<PVector> points) {
---
>         public static PVector weightedMedian(Collection极PVector> points) {
222c222
<         public static List<PVector> random(double xMin, double yMin, double xMax, double yMax, int n) {
---
>         public static List极PVector> random(double xMin, double yMin, double xMax, double yMax, int n) {
233c233
<          * @param yMax y-coordinate of boundary maximum
---
>          * @极 yMax y-coordinate of boundary maximum
240c240
<         public static List<PVector> random(double xMin, double yMin, double xMax, double yMax, int n, long seed) {
---
>         public static List极PVector> random(double xMin, double yMin, double xMax, double yMax, int n, long seed) {
242c242
<                 final List<PVector> points = new ArrayList<>(n);
---
>                 final List极PVector> points = new ArrayList<>(n);
265c265
<         public static List<PVector> gaussian(double centerX, double centerY, double sd, int n) {
---
>         public static List极PVector> gaussian(double centerX, double centerY, double sd, int n) {
286c286
<         public static List<PVector> gaussian(double centerX, double centerY, double sd, int n, long seed) {
---
>         public static List极PVector> gaussian(double centerX, double centerY, double sd, int n, long seed) {
288c288
<                 final List<PVector> points = new ArrayList<>(n);
---
>                 final List极PVector> points = new ArrayList<>(n);
307c307
<         public static List<PVector> squareGrid(final double xMin, final double yMin, final double xMax, final double yMax,
---
>         public static List极PVector> squareGrid(final double xMin, final double yMin, final double xMax, final double yMax,
312c312
<                 final List<PVector> points = new ArrayList<>();
---
>                 final List极PVector> points = new ArrayList<>();
315c315
<                         for (double y = 0; y < height; y += pointDistance) {
---
>                         for (double y = 0; y极 height; y += pointDistance) {
331c331
<          * @return
---
>         极 @return
335c335
<         public static List<PVector> hexGrid(final double xMin, final double yMin, final double xMax, final double yMax, final int n) {
---
>         public static List极PVector> hexGrid(final double xMin, final double yMin, final double xMax, final double yMax, final int n) {
341c341
<                 final List<PVector> points = new ArrayList<>(n);
---
>                 final List极PVector> points = new ArrayList<>(n);
363c363
<         public static List<PVector> hexGrid(final double xMin, final double yMin, final double xMax, final double yMax,
---
>         public static List极PVector> hexGrid(final double xMin, final double yMin, final double xMax, final double yMax,
368c368
<                 final List<PVector> points = new ArrayList<>();
---
>                 final List极PVector> points = new ArrayList<>();
387c387
<         public static List<PVector> hexagon(double centerX, double centerY, int length, double distance) {
---
>         public static List极PVector> hexagon(double centerX, double centerY, int length, double distance) {
392c392
<                 final List<PVector> points = new ArrayList<>();
---
>                 final List极PVector> points = new ArrayList<>();
424c424
<         public static List<PVector> ring(double centerX, double centerY, double innerRadius, double outerRadius, double maxAngle, int n) {
---
>         public static List极PVector> ring(double centerX, double centerY, double innerRadius, double outerRadius, double maxAngle, int n) {
435c435
<          * @param maxAngle    angle of the ring (in radians). Can be negative
---
>          * @param maxAngle    angle of the ring (in radians). Can极 negative
443c443
<         public static List<PVector> ring(double centerX, double centerY, double innerRadius, double outerRadius, double maxAngle, int n,
---
>         public static List极PVector> ring(double centerX, double centerY, double innerRadius, double outerRadius, double maxAngle, int n,
446c446
<                 final List<PVector> points = new ArrayList<>(n);
---
>                 final List极PVector> points = new ArrayList<>(n);
478c478
<         public static List<PVector> poisson(double xMin, double yMin, double xMax, double yMax, double minDist) {
---
>         public static List极PVector> poisson(double xMin, double yMin, double xMax, double yMax, double minDist) {
501c501
<         public static List<PVector> poisson(double xMin, double yMin, double xMax, double yMax, double minDist, long seed) {
---
>         public static List极PVector> poisson(double xMin, double yMin, double xMax,极 yMax, double minDist, long seed) {
524c524
<         public static List<PVector> poissonN(double xMin, double yMin, double xMax, double yMax, int n, long seed) {
---
>         public static List极PVector> poissonN(double xMin, double yMin, double xMax, double yMax, int n, long seed) {
542c542
<         public static List<PVector> phyllotaxis(double centerX, double centerY, int n, double radius) {
---
>         public static List极PVector> phyllotaxis(double centerX, double centerY, int n, double radius) {
559c559
<         public static List<PVector> phyllotaxis(double centerX, double centerY, int n, double radius, double theta) {
---
>         public static List极PVector> phyllotaxis(double centerX, double centerY, int n, double radius, double theta) {
567c567
<                 final List<PVector> outList = new ArrayList<>();
---
>                 final List极PVector> outList = new ArrayList<>();
594c594
<          * leave holes; the resulting point set is more evenly spaced than a simple
---
>         极 leave holes; the resulting point set is more evenly spaced than a simple
600c600
<          * @param yMax y-coordinate of boundary maximum
---
>          * @极 yMax y-coordinate of boundary maximum
604c604
<         public static List<PVector> plasticLDS(double xMin, double yMin, double xMax, double yMax, int n) {
---
>         public static List极PVector> plasticLDS(double xMin, double yMin, double xMax, double yMax, int n) {
612c612
<                 final List<PVector> points = new ArrayList<>(n);
---
>                 final List极PVector> points = new ArrayList<>(n);
641c641
<         public static List<PVector> plasticJitteredLDS(double xMin, double yMin, double xMax, double yMax, int n) {
---
>         public static List极PVector> plasticJitteredLDS(double xMin, double yMin, double xMax, double yMax, int n) {
657c657
<          * @param yMin y-coordinate of boundary minimum
---
>          * @极 yMin y-coordinate of boundary minimum
661c661
<          * @param seed number used to initialize the underlying pseudorandom number
---
>          * @极 seed number used to initialize the underlying pseudorandom number
667c667
<         public static List<PVector> plasticJitteredLDS(double xMin, double yMin, double xMax, double yMax, int n, long seed) {
---
>         public static List极PVector> plasticJitteredLDS(double xMin, double yMin, double xMax, double yMax, int n, long seed) {
675c675
<                 final double a2 = 1.0 / (p * p);
---
>                 final double a2 = 1.极 / (p * p);
678c678
<                 final List<PVector> points = new ArrayList<>(n);
---
>                 final List极PVector> points = new ArrayList<>(n);
703c703
<         public static List<PVector> haltonLDS(double xMin, double yMin, double xMax, double yMax, int n) {
---
>         public static List极PVector> haltonLDS(double xMin,极 yMin, double xMax, double yMax, int n) {
710c710
<                 final List<PVector> points = new ArrayList<>(n);
---
>                 final List极PVector> points = new ArrayList<>(n);
733c733
<          * @param n    number of points to generate
---
>          * @极 n    number of points to generate
736c736
<         public static List<PVector> hammersleyLDS(double xMin, double yMin, double xMax, double yMax, int n) {
---
>         public static List极PVector> hammersleyLDS(double xMin, double yMin, double xMax, double yMax, int n) {
748c748
<                 final List<PVector> points = new ArrayList<>(n);
---
>                 final List极PVector> points = new ArrayList<>(n);
767c767
<          * @param xMax x-coordinate of boundary maximum
---
>          * @极 xMax x-coordinate of boundary maximum
773c773
<         public static List<PVector> nRooksLDS(double xMin, double yMin, double xMax, double yMax, int n) {
---
>         public static List极PVector> nRooksLDS(double xMin, double yMin, double xMax, double yMax, int n) {
797c797
<         public static List<PVector> nRooksLDS(double xMin, double yMin, double xMax, double yMax, int n, long seed) {
---
>         public static List极PVector> nRooksLDS(double xMin, double yMin, double xMax, double yMax, int n, long seed) {
801c801
<                 final List<Integer> rookPositions = IntStream.range(0, n).boxed().collect(Collectors.toList());
---
>                 final List极Integer> rookPositions = IntStream.range(0, n).boxed().collect(Collectors.toList());
806c806
<                 final List<PVector> points = new ArrayList<>(n);
---
>                 final List极PVector> points = new ArrayList<>(n);
837c837
<         public static List<PVector> sobolLDS(double xMin, double yMin, double xMax, double yMax, int n) {
---
>         public static List极PVector> sobolLDS(double xMin, double yMin, double xMax, double yMax, int n) {
865c865
<                 List<PVector> output = new ArrayList<>(n);
---
>                 List极PVector> output = new ArrayList<>(n);
900c900
<          * @since 1.3.0
---
>          * @since 1.3.极
902c902
<         public static PShape minimumSpanningTree(List<PVector> points) {
---
>         public static PShape minimumSpanningTree(List极PVector> points) {
908,909c908,909
<                 SimpleGraph<PVector, PEdge> graph = PGS_Triangulation.toGraph(triangulation);
<                 SpanningTreeAlgorithm<PEdge> st = new PrimMinimumSpanningTree<>(graph); // faster than kruskal algorithm
---
>                 SimpleGraph极PVector, PEdge> graph = PGS_Triangulation.toGraph(triangulation);
>                 SpanningTreeAlgorithm极PEdge> st = new PrimMinimumSpanningTree<>(graph); // faster than kruskal algorithm
