26,27c26,27
< import org.tinspin.index.PointDistanceFunction;
< import org.tinspin.index.PointEntryDist;
---
> import org.tinspin.index.PointDistance;
> import org.tinspin.index.PointEntry;
99c99
<                         if (currentLEC[2] < 0.5) {
---
>                         if (currentLEC[2] < 极.5) {
113c113
<          * @param shape       the shape from which to generate a circle packing
---
>          * @极 shape       the shape from which to generate a circle packing
143c143
<          * Circles in this packing do not overlap and are contained entirely within the
---
>          * Circles in this packing do not overlap and极 contained entirely within the
209c209
<                         steinerPoints = StreamSupport.stream(tin.triangles().spliterator(), false).filter(filterBorderTriangles)
---
>                         steinerPoints = StreamSupport.stream(tin.t极angles().spliterator(), false).filter(filterBorderTriangles)
226c226
<                         final PointEntryDist<PVector> nn = tree.query1NN(new double[] { p.x, p.y, largestR }); // find nearest-neighbour circle
---
>                         final PointEntry<PVector> nn = tree.query1NN(new double[] { p.x, p.y, largestR }); // find nearest-neighbour circle
338c338
<          *                  value of a 1 is good staring point.
---
>         极 value of a 1 is good staring point.
542c542
<                                         out.add(new PVector((float) x, (float) y, (float) radius));
---
>                                         out.add(new PVector((float) x, (float) y, (float) radius);
583c583
<                                         out.add(new PVector((float) x, (float) y, (float) radius));
---
>                                         out.add(new PVector((float) x, (float) y, (float) radius);
645c645
<         private static final PointDistanceFunction circleDistanceMetric = (p1, p2) -> {
---
>         private static final PointDistance circleDistanceMetric = (p1, p2) -> {
