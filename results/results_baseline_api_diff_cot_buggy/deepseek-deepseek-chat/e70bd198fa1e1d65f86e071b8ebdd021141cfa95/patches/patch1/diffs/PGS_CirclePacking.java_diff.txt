26,27d25
< import org.tinspin.index.PointDistanceFunction;
< import org.tinspin.index.PointEntryDist;
56a55,68
>     private interface PointDistance {
>         double distance(double[] p1, double[] p2);
>     }
> 
>     private static class PointEntry<T> {
>         final double[] point;
>         final T value;
> 
>         PointEntry(double[] point, T value) {
>             this.point = point;
>             this.value = value;
>         }
>     }
> 
203c215,222
<                 final CoverTree<PVector> tree = CoverTree.create(3, 2, circleDistanceMetric);
---
>         final CoverTree<PVector> tree = CoverTree.create(3, 2, (p1, p2) -> {
>             final double dx = p1[0] - p2[0];
>             final double dy = p1[1] - p2[1];
>             final double dz = p1[2] - p2[2];
>             double euclideanDistance = Math.sqrt(dx * dx + dy * dy);
>             double absZDifference = Math.abs(dz);
>             return euclideanDistance + absZDifference;
>         });
219,222d237
<                 /*
<                  * "To find the circle nearest to a center (x, y), do a proximity search at (x,
<                  * y, R), where R is greater than or equal to the maximum radius of a circle."
<                  */
226c241,242
<                         final PointEntryDist<PVector> nn = tree.query1NN(new double[] { p.x, p.y, largestR }); // find nearest-neighbour circle
---
>             PointEntry<PVector> nearest = null;
>             double minDistance = Double.MAX_VALUE;
228,235c244,255
<                         /*
<                          * nn.dist() does not return the radius (since it's a distance metric used to
<                          * find nearest circle), so calculate maximum radius for candidate circle using
<                          * 2d euclidean distance between center points minus radius of nearest circle.
<                          */
<                         final float dx = p.x - nn.value().x;
<                         final float dy = p.y - nn.value().y;
<                         final float radius = (float) (Math.sqrt(dx * dx + dy * dy) - nn.value().z);
---
>             for (PointEntry<PVector> entry : tree.queryAll()) {
>                 double distance = circleDistanceMetric.distance(new double[] { p.x, p.y, largestR }, entry.point);
>                 if (distance < minDistance) {
>                     minDistance = distance;
>                     nearest = entry;
>                 }
>             }
> 
>             if (nearest != null) {
>                 final float dx = p.x - nearest.value.x;
>                 final float dy = p.y - nearest.value.y;
>                 final float radius = (float) (Math.sqrt(dx * dx + dy * dy) - nearest.value.z);
242a263
>         }
352c373
<                                 out.add(new PVector((float) currentLEC[0], (float) currentLEC[1], (float) currentLEC[2]));
---
>                 out.add(new PVector((float) currentLEC[0], (float) currentLEC[1], (float) currentLEC[2]);
626,646c647
<         /**
<          * Calculate the distance between two points in 3D space, where each point
<          * represents a circle with (x, y, r) coordinates. This custom metric considers
<          * both the Euclidean distance between the centers of the circles and the
<          * absolute difference of their radii.
<          * <p>
<          * The metric is defined as follows: Given two points A and B, representing
<          * circles centered at (x1, y1) and (x2, y2) with radii r1 and r2 respectively,
<          * the distance is calculated as sqrt((x1 - x2)^2 + (y1 - y2)^2) + |r1 - r2|.
<          * <p>
<          * This metric can be used to find the nearest circle to a given center (x, y)
<          * in a proximity search. To perform the search, use a point (x, y, R) where R
<          * is greater than or equal to the maximum radius of a circle in the proximity
<          * structure.
<          *
<          * @param p1 3D point representing the first circle (x1, y1, r1)
<          * @param p2 3D point representing the second circle (x2, y2, r2)
<          * @return the distance between the two points based on the custom metric
<          */
<         private static final PointDistanceFunction circleDistanceMetric = (p1, p2) -> {
<                 // from https://stackoverflow.com/a/21975136/
---
>     private static final PointDistance circleDistanceMetric = (p1, p2) -> {
650d650
< 
653c653
<                 return euclideanDistance + absZDifference; // negative if inside
---
>         return euclideanDistance + absZDifference;
