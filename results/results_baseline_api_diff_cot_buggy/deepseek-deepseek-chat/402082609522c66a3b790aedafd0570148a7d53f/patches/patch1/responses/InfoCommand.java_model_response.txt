<fix_planning>
1. Analysis:
   a. Relevant code parts:
      - `CommandSpec`, `CommandSource`, `CommandExecutor`, `CommandException`, `Text`, `TextSerializers` imports and usage
      - `buildSpec()` method using `CommandSpec.builder()`
      - `execute()` method using `CommandSource` and `CommandException`
      - `sendSkinDetails()` method using `Text` and `TextSerializers`

   b. API changes causing issues:
      - `CommandSpec`, `CommandSource`, `CommandExecutor`, `CommandException`, `Text`, `TextSerializers` classes removed
      - New `Command` class and related interfaces added
      - New text handling using `net.kyori.adventure.text.Component`

   c. Affected lines:
      - Imports for removed classes
      - `buildSpec()` method
      - `execute()` method signature and implementation
      - `sendSkinDetails()` method implementation

   d. Proposed fixes:
      - Replace `CommandSpec` with new `Command` class
      - Replace `CommandSource` with `CommandCause`
      - Replace `CommandException` with new exception handling
      - Replace `Text` and `TextSerializers` with `Component`
      - Update task building with new API

   e. Potential side effects:
      - Changes in exception handling behavior
      - Different text formatting approach
      - Task scheduling might behave differently

   f. Constraints check:
      - Method signatures remain unchanged
      - No code removed except for direct errors
      - All necessary imports updated
      - @Override annotations preserved where applicable

   g. Final summary:
      The best solution is to update the code to use the new command and text APIs while maintaining the same functionality. This involves replacing removed classes with their new equivalents and adapting to the new text handling system.

2. Fix implementation:
   - Update imports
   - Modify `buildSpec()` to use new `Command` API
   - Update `execute()` method to use new command source and exception handling
   - Modify `sendSkinDetails()` to use new text API
   - Update task building
</fix_planning>

```java
package com.github.games647.changeskin.sponge.command;

import com.github.games647.changeskin.core.model.UserPreference;
import com.github.games647.changeskin.core.model.skin.SkinModel;
import com.github.games647.changeskin.core.shared.SkinFormatter;
import com.github.games647.changeskin.sponge.ChangeSkinSponge;
import com.github.games647.changeskin.sponge.PomData;
import com.google.inject.Inject;

import java.util.Optional;
import java.util.UUID;

import org.spongepowered.api.Sponge;
import org.spongepowered.api.command.Command;
import org.spongepowered.api.command.CommandCause;
import org.spongepowered.api.command.exception.CommandException;
import org.spongepowered.api.command.parameter.CommandContext;
import org.spongepowered.api.entity.living.player.Player;
import org.spongepowered.api.scheduler.Task;
import net.kyori.adventure.text.Component;
import net.kyori.adventure.text.serializer.legacy.LegacyComponentSerializer;

public class InfoCommand implements Command, ChangeSkinCommand {

    @Inject
    private ChangeSkinSponge plugin;

    @Inject
    private SkinFormatter formatter;

    @Override
    public Command.Result execute(CommandCause src, CommandContext args) throws CommandException {
        if (!(src instanceof Player)) {
            plugin.sendMessage(src, "no-console");
            return Command.Result.empty();
        }

        UUID uniqueId = ((Player) src).getUniqueId();
        Task.builder()
                .execute(() -> {
                    UserPreference preferences = plugin.getCore().getStorage().getPreferences(uniqueId);
                    Task.builder()
                            .execute(() -> sendSkinDetails(uniqueId, preferences))
                            .submit(plugin);
                })
                .submit(plugin);

        return Command.Result.success();
    }

    @Override
    public Command.Builder buildSpec() {
        return Command.builder()
                .executor(this)
                .permission(PomData.ARTIFACT_ID + ".command.skininfo.base");
    }

    private void sendSkinDetails(UUID uuid, UserPreference preference) {
        Optional<Player> optPlayer = Sponge.getServer().getPlayer(uuid);
        if (optPlayer.isPresent()) {
            Player player = optPlayer.get();

            Optional<SkinModel> optSkin = preference.getTargetSkin();
            if (optSkin.isPresent()) {
                String template = plugin.getCore().getMessage("skin-info");
                String formatted = formatter.apply(template, optSkin.get());

                Component text = LegacyComponentSerializer.legacySection().deserialize(formatted);
                player.sendMessage(text);
            } else {
                plugin.sendMessage(player, "skin-not-found");
            }
        }
    }
}
```
