<fix_planning>
1. **Analysis of the Problem:**
   - The error occurs in the line `textField.getLineBox().getPen().setLineWidth(border.getLineWidth());`.
   - The API change indicates that the method `setLineWidth(float)` has been removed from `JRPen` and `JRBasePen`.
   - The error message suggests that there is a type mismatch: `int` cannot be converted to `Float`.

2. **Affected Lines of Code:**
   - `textField.getLineBox().getPen().setLineWidth(border.getLineWidth());`

3. **Proposed Fix:**
   - Since `setLineWidth(float)` has been removed, we need to find an alternative way to set the line width. 
   - The new API might require setting the line width using a different method or approach. However, without specific information on the new API, we can assume that the line width can be set directly on the `JRPen` object using a different method or property.
   - Given the error message, we can cast the `int` value returned by `border.getLineWidth()` to `float` to ensure type compatibility.

4. **Potential Side Effects:**
   - Casting `int` to `float` might lead to precision loss, but in this context, it is acceptable since line width is typically a small integer value.

5. **Adherence to Constraints:**
   - The proposed fix does not change the function signature.
   - No new variables are introduced.
   - No imports are added or removed.
   - No existing code is removed.

6. **Final Summary:**
   - The best solution is to cast the `int` value returned by `border.getLineWidth()` to `float` to ensure type compatibility with the new API. This adheres to all constraints and resolves the compilation error.

**Chosen Fix:**
```java
textField.getLineBox().getPen().setLineWidth((float) border.getLineWidth());
```
</fix_planning>

```java
package xdev.tableexport.export;

/*-
 * #%L
 * XDEV BI Suite
 * %%
 * Copyright (C) 2011 - 2020 XDEV Software
 * %%
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Lesser Public License for more details.
 * 
 * You should have received a copy of the GNU General Lesser Public
 * License along with this program.  If not, see
 * <http://www.gnu.org/licenses/lgpl-3.0.html>.
 * #L%
 */


import java.awt.Color;
import java.awt.Font;
import java.util.HashSet;
import java.util.Set;

import javax.swing.JLabel;

import net.sf.jasperreports.engine.JRException;
import net.sf.jasperreports.engine.JRLineBox;
import net.sf.jasperreports.engine.JasperCompileManager;
import net.sf.jasperreports.engine.JasperReport;
import net.sf.jasperreports.engine.design.JRDesignBand;
import net.sf.jasperreports.engine.design.JRDesignExpression;
import net.sf.jasperreports.engine.design.JRDesignField;
import net.sf.jasperreports.engine.design.JRDesignSection;
import net.sf.jasperreports.engine.design.JRDesignStaticText;
import net.sf.jasperreports.engine.design.JRDesignTextElement;
import net.sf.jasperreports.engine.design.JRDesignTextField;
import net.sf.jasperreports.engine.design.JasperDesign;
import net.sf.jasperreports.engine.type.ModeEnum;
import net.sf.jasperreports.engine.type.PositionTypeEnum;
import net.sf.jasperreports.engine.type.SplitTypeEnum;
import xdev.tableexport.config.ColumnBorder;
import xdev.tableexport.config.ColumnPadding;
import xdev.tableexport.config.ColumnStyle;
import xdev.tableexport.config.ContentColumn;
import xdev.tableexport.config.HeaderColumn;
import xdev.tableexport.config.PageProperties;
import xdev.tableexport.config.TemplateColumn;
import xdev.tableexport.config.TemplateConfig;
import xdev.vt.XdevBlob;
import xdev.vt.XdevClob;


/**
 * The {@link ReportBuilder} generates a {@link JasperReport} based on the
 * information of the {@link TemplateConfig}.
 * 
 * @author XDEV Software (FHAE)
 * 
 * @see TemplateConfig
 * @see ReportExporter
 * 
 */
public class ReportBuilder
{
	private final TemplateConfig			config;
	private final Set<JRDesignField>		fieldSet	= new HashSet<>();
	
	
	public ReportBuilder(final TemplateConfig tempConfig)
	{
		this.config = tempConfig;
	}
	
	
	private JRDesignBand initDetailBand()
	{
		final JRDesignBand detailBand = new JRDesignBand();
		detailBand.setHeight(TemplateConfig.DEFAULT_DETAIL_BAND_HEIGHT);
		detailBand.setSplitType(SplitTypeEnum.STRETCH);
		
		return detailBand;
	}
	
	
	private JRDesignBand initHeaderBand()
	{
		// Header
		final JRDesignBand headerBand = new JRDesignBand();
		headerBand.setHeight(TemplateConfig.DEFAULT_HEADER_BAND_HEIGHT);
		
		return headerBand;
	}
	
	
	private JasperDesign createDefaultDesign()
	{
		final JasperDesign jasperDesign = new JasperDesign();
		jasperDesign.setName("DefaultDesign");
		final PageProperties properties = this.config.getPageProperties();
		
		jasperDesign.setPageWidth(this.calcPageWidth(properties));
		jasperDesign.setColumnWidth(this.calcColumnsWidth());
		
		jasperDesign.setPageHeight(properties.getPageHeight());
		jasperDesign.setColumnSpacing(properties.getColumnSpacing());
		jasperDesign.setLeftMargin(properties.getLeftMargin());
		jasperDesign.setRightMargin(properties.getRightMargin());
		jasperDesign.setTopMargin(properties.getTopMargin());
		jasperDesign.setBottomMargin(properties.getBottomMargin());
		
		return jasperDesign;
	}
	
	
	private int calcColumnsWidth()
	{
		int width = 0;
		
		for(final TemplateColumn col : this.config.getColumns())
		{
			width += col.getWidth();
		}
		
		return width;
	}

	/***
	 * Calculated the page width including the margins.
	 * 
	 * @param properties
	 * 
	 * @return
	 */
	private int calcPageWidth(final PageProperties properties)
	{
		int width = 0;
		
		for(final TemplateColumn col : this.config.getColumns())
		{
			width += col.getWidth();
		}
		
		width += properties.getLeftMargin() + properties.getRightMargin();
		
		return width;
	}
	
	
	/**
	 * 
	 * @return
	 */
	private int calcMaxHeaderHeight()
	{
		
		final JLabel lbl = new JLabel("a");
		int maxHeight = 0;
		
		for(final TemplateColumn col : this.config.getColumns())
		{
			final ColumnStyle style = col.getHeaderColumn().getStyle();
			final Font font = style.getFont();
			lbl.setFont(font);
			//get the normal height of the label
			int lblHeigh = (int)lbl.getPreferredSize().getHeight();
			//add the column border width
			lblHeigh+= style.getColBorder().getLineWidth()*2;
			//Add padding
			lblHeigh+= style.getColumnPadding().getTopWidth() + style.getColumnPadding().getBottomWidth();
			
			if(lblHeigh > maxHeight)
			{
				maxHeight = lblHeigh;
			}
		}
		
		return maxHeight;
	}
	
	private int calcMaxContentHeight()
	{
		
		final JLabel lbl = new JLabel("a");
		int maxHeight = 0;
		
		for(final TemplateColumn col : this.config.getColumns())
		{
			final ColumnStyle style = col.getContentColumn().getStyle();
			final Font font = style.getFont();
			lbl.setFont(font);
			int lblHeigh = (int)lbl.getPreferredSize().getHeight();
			//Add border width
			lblHeigh+= style.getColBorder().getLineWidth()*2;
			//Add padding
			lblHeigh+= style.getColumnPadding().getTopWidth() + style.getColumnPadding().getBottomWidth();
			
			if(lblHeigh > maxHeight)
			{
				maxHeight = lblHeigh;
			}
		}
		
		return maxHeight;
	}
	
	
	private void createTemplateFields(final JasperDesign jasperDesign) throws ExportException
	{
		JRDesignField field;
		
		for(final TemplateColumn col : this.config.getColumns())
		{
			field = new JRDesignField();
			field.setName(col.getContentColumn().getFieldName());
			this.chooseValueClass(col,field);
			
			try
			{
				jasperDesign.addField(field);
				this.fieldSet.add(field);
			}
			catch(final JRException e)
			{
				throw new ExportException("error during add the field "
						+ col.getContentColumn().getFieldName(),e);
			}
		}
		
	}

	
	private JRDesignField chooseValueClass(final TemplateColumn col, final JRDesignField field)
	{
		final Class<?> valueClass = col.getContentColumn().getColumnValueClass();
		
		if(valueClass.isAssignableFrom(byte[].class) || valueClass.isAssignableFrom(XdevBlob.class) || valueClass.isAssignableFrom(XdevClob.class))
		{
			field.setValueClass(String.class);
		}
		else
		{
			field.setValueClass(valueClass);
		}
		
		return field;
	}
	
	
	private void createHeaderAndContent(final JRDesignBand headerBand, final JRDesignBand detailBand)
	{
		JRDesignStaticText headerLabel;
		JRDesignStaticText emptyHeaderLabel;
		JRDesignTextField textField;
				
		final int headerLabelHeight = this.calcMaxHeaderHeight();
		headerBand.setHeight(headerLabelHeight);
		
		final int contentLabelHeight = this.calcMaxContentHeight();
		detailBand.setHeight(contentLabelHeight);
				
		final boolean createHeader = this.config.hasAnyHeader();
		
		int x = 0;
		
		for(final TemplateColumn col : this.config.getColumns())
		{
			// Header is created
			if(createHeader)
			{
				// If this column has a header the JRDesignStaticText get the
				// propertys of the Column
				if(col.hasHeaderColumn())
	
