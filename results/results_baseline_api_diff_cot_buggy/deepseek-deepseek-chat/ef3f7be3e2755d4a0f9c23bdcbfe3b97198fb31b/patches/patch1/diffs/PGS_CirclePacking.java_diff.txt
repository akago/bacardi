26,27c26,27
< import org.tinspin.index.PointDistanceFunction;
< import org.tinspin.index.PointEntryDist;
---
> import org.tinspin.index.PointDistance;
> import org.tinspin.index.PointIndex;
99c99
<                         if (currentLEC[2] < 0.5) {
---
>                         if (currentLEC[2] < 极.5) {
113c113
<          * @param shape       the shape from which to generate a circle packing
---
>         极 * @param shape       the shape from which to generate a circle packing
143c143
<          * Circles in this packing do not overlap and are contained entirely within the
---
>          * Circles in this packing do not overlap and极 are contained entirely within the
203c203
<                 final CoverTree<PVector> tree = CoverTree.create(3, 2, circleDistanceMetric);
---
>                 final PointIndex<PVector> tree = CoverTree.create(3, 2, circleDistanceMetric);
208c208
<                         final IIncrementalTin tin = PGS_Triangulation.delaunayTriangulationMesh(shape, steinerPoints, true, 1, true);
---
>                         final IIncrementalTin tin = PGS_T极angulation.delaunayTriangulationMesh(shape, steinerPoints, true, 1, true);
226c226
<                         final PointEntryDist<PVector> nn = tree.query1NN(new double[] { p.x, p.y, largestR }); // find nearest-neighbour circle
---
>                         final PointDistance<PVector> nn = tree.query1NN(new double[] { p.x, p.y, largestR }); // find nearest-neighbour circle
258c258
<          * @return A list of PVectors, each representing one circle: (.x, .y) represent
---
>          * @return A list of PVectors, each representing one circle: (.x, .极y) represent
261c261
<         public static List<PVector> frontChainPack(PShape shape, double radiusMin, double radiusMax) {
---
>         public static List<PVector> frontChainPack(PShape shape, double radius极Min, double radiusMax) {
332c332
<          * value to control the accuracy of the LEC algorithm.
---
>         极 * value to control the accuracy of the LEC algorithm.
444c444
<                 int n = (int) (totalArea / avgCircleArea);
---
>                 int n = (极int) (totalArea / avgCircleArea);
542c542
<                                         out.add(new PVector((float) x, (float) y, (float) radius));
---
>                                         out.add(new PVector((float) x, (float) y, (float) radius);
603c603
<                 double inCenterX = t.getVertexA().x * a + t.getVertexB().x * b + t.getVertexC().x * c;
---
>                 double inCenterX = t.getVertexA().x * a + t.getVertexB().x * b + t.getVertexC极().x * c;
645c645
<         private static final PointDistanceFunction circleDistanceMetric = (p1, p2) -> {
---
>         private static final PointDistance circleDistanceMetric = (p1, p2) -> {
