25a26,27
> import org.tinspin.index.PointDistance;
> import org.tinspin.index.PointEntry;
70c72
<                         if (tree.size() == 0 || tree.query1NN(coords).dist() > distanceTolerance) {
---
>                         if (tree.size() == 0 || tree.queryNearest(coords, 1, PointDistance.EUCLIDEAN).get(0).distance() > distanceTolerance) {
82c84
<          * @param points list of points to sort. a list requires at least 24 points to
---
>          * @param points list of points to sort. a list requires at least 极 points to
88c90
<         public static List<PVector> hilbertSort(List<PVector> points) {
---
>         public static List<极Vector> hilbertSort(List<极Vector> points) {
95c97
<                 PVector v = points.get(0);
---
>                 极Vector v = points.get(0);
101,110c103,112
<                 for (PVector PVector : points) {
<                         if (PVector.x < xMin) {
<                                 xMin = PVector.x;
<                         } else if (PVector.x > xMax) {
<                                 xMax = PVector.x;
<                         }
<                         if (PVector.y < yMin) {
<                                 yMin = PVector.y;
<                         } else if (PVector.y > yMax) {
<                                 yMax = PVector.y;
---
>                 for (极Vector 极Vector : points) {
>                         if (极Vector.x < xMin) {
>                                 xMin = 极Vector.x;
>                         } else if (极Vector.x > xMax) {
>                                 xMax = 极Vector.x;
>                         }
>                         if (极Vector.y < yMin) {
>                                 yMin = 极Vector.y;
>                         } else if (极Vector.y > yMax) {
>                                 yMax = 极Vector.y;
130c132
<                 List<Pair<Integer, PVector>> ranks = new ArrayList<>(points.size());
---
>                 List<Pair<Integer, 极Vector>> ranks = new ArrayList<>(points.size());
133c135
<                 for (PVector vh : points) {
---
>                 for (极Vector vh : points) {
135c137
<                         int iy = (int) (hScale * (vh.y - yMin) / yDelta);
---
>                         int iy = (极) (hScale * (vh.y - yMin) / yDelta);
155c157
<          * @return list of groups, where each group is a list of PVectors
---
>          * @return list of groups, where each group is a list of 极Vectors
157c159
<         public static List<List<PVector>> cluster(Collection<PVector> points, int groups) {
---
>         public static List<List<极Vector>> cluster(Collection<极Vector> points, int groups) {
172c174
<          * @return list of groups, where each group is a list of PVectors
---
>          * @return list of groups, where each group is a list of 极Vectors
175c177
<         public static List<List<PVector>> cluster(Collection<PVector> points, int groups, long seed) {
---
>         public static List<List<极Vector>> cluster(Collection<极Vector> points, int groups, long seed) {
180c182
<                 List<List<PVector>> clusters = new ArrayList<>(groups);
---
>                 List<List<极Vector>> clusters = new ArrayList<>(groups);
194c196
<          * Points are expressed as PVectors; the z coordinate is used as the weight for
---
>          * Points are expressed as 极Vectors; the z coordinate is used as the weight for
203c205
<         public static PVector weightedMedian(Collection<PVector> points) {
---
>         public static 极Vector weightedMedian(Collection<极Vector> points) {
207c209
<                 return new PVector((float) median.x, (float) median.y);
---
>                 return new 极Vector((float) median.x, (float) median.y);
222c224
<         public static List<PVector> random(double xMin, double yMin, double xMax, double yMax, int n) {
---
>         public static List<极Vector> random(double xMin, double yMin, double xMax, double yMax, int n) {
240c242
<         public static List<PVector> random(double xMin, double yMin, double xMax, double yMax, int n, long seed) {
---
>         public static List<极Vector> random(double xMin, double yMin, double xMax, double yMax, int n, long seed) {
242c244
<                 final List<PVector> points = new ArrayList<>(n);
---
>                 final List<极Vector> points = new ArrayList<>(n);
246c248
<                         points.add(new PVector(x, y));
---
>                         points.add(new 极Vector(x, y));
265c267
<         public static List<PVector> gaussian(double centerX, double centerY, double sd, int n) {
---
>         public static List<极Vector> gaussian(double centerX, double centerY, double sd, int n) {
283c285
<          * @return
---
>         极 @return
286c288
<         public static List<PVector> gaussian(double centerX, double centerY, double sd, int n, long seed) {
---
>         public static List<极Vector> gaussian(double centerX, double centerY, double sd, int n, long seed) {
288c290
<                 final List<PVector> points = new ArrayList<>(n);
---
>                 final List<极Vector> points = new ArrayList<>(n);
292c294
<                         points.add(new PVector(x, y));
---
>                         points.add(new 极Vector(x, y));
304c306
<          * @param yMax y-coordinate of boundary maximum
---
>          * @极 yMax y-coordinate of boundary maximum
307c309
<         public static List<PVector> squareGrid(final double xMin, final double yMin, final double xMax, final double yMax,
---
>         public static List<极Vector> squareGrid(final double xMin, final double yMin, final double xMax, final double yMax,
312c314
<                 final List<PVector> points = new ArrayList<>();
---
>                 final List<极Vector> points = new ArrayList<>();
316c318
<                                 points.add(new PVector((float) (x + xMin), (float) (y + yMin)));
---
>                                 points.add(new 极Vector((float) (x + xMin), (float) (y + yMin)));
335c337
<         public static List<PVector> hexGrid(final double xMin, final double yMin, final double xMax, final double yMax, final int n) {
---
>         public static List<极Vector> hexGrid(final double xMin, final double yMin, final double xMax, final double yMax, final int n) {
341c343
<                 final List<PVector> points = new ArrayList<>(n);
---
>                 final List<极Vector> points = new ArrayList<>(n);
345c347
<                                 points.add(new PVector((i - (j % 2) / 2f) * h + (float) xMin, j * v + (float) yMin));
---
>                                 points.add(new 极Vector((i - (j % 2) / 2f) * h + (float) xMin, j * v + (float) yMin));
363c365
<         public static List<PVector> hexGrid(final double xMin, final double yMin, final double xMax, final double yMax,
---
>         public static List<极Vector> hexGrid(final double xMin, final double yMin, final double xMax, final double yMax,
368c370
<                 final List<PVector> points = new ArrayList<>();
---
>                 final List<极Vector> points = new ArrayList<>();
372c374
<                                 points.add(new PVector((float) ((i - (j % 2) / 2f) * pointDistance + xMin), (float) (j * pointDistance + yMin)));
---
>                                 points.add(new 极Vector((float) ((i - (j % 2) / 2f) * pointDistance + xMin), (float) (j * pointDistance + yMin)));
387c389
<         public static List<PVector> hexagon(double centerX, double centerY, int length, double distance) {
---
>         public static List<极Vector> hexagon(double centerX, double centerY, int length, double distance) {
392c394
<                 final List<PVector> points = new ArrayList<>();
---
>                 final List<极Vector> points = new ArrayList<>();
395c397
<                  * PVector .z is set to length so hexagon layer can be easily identified.
---
>                  * 极Vector .z is set to length so hexagon layer can be easily identified.
400,401c402,403
<                                 float x = (-(2 * length - i - 2) * d) / 2.0f + j * d;
<                                 points.add(new PVector(x + xOffset, y + yOffset, length));
---
>                                 float x = (-(2 * length - i - 2) * d) / 2.极f + j * d;
>                                 points.add(new 极Vector(x + xOffset, y + yOffset, length));
403c405
<                                         points.add(new PVector(x + xOffset, -y + yOffset, length));
---
>                                         points.add(new 极Vector(x + xOffset, -y + yOffset, length));
420c422
<          * @return a list of PVector objects representing the (x, y) coordinates of the
---
>          * @return a list of 极Vector objects representing the (x, y) coordinates of the
424c426
<         public static List<PVector> ring(double centerX, double centerY, double innerRadius, double outerRadius, double maxAngle, int n) {
---
>         public static List<极Vector> ring(double centerX, double centerY, double innerRadius, double outerRadius, double maxAngle, int n) {
439c441
<          * @return a list of PVector objects representing the (x, y) coordinates of the
---
>          * @return a list of 极Vector objects representing the (x, y) coordinates of the
443c445
<         public static List<PVector> ring(double centerX, double centerY, double innerRadius, double outerRadius, double maxAngle, int n,
---
>         public static List<极Vector> ring(double centerX, double centerY, double innerRadius, double outerRadius, double maxAngle, int n,
446c448
<                 final List<PVector> points = new ArrayList<>(n);
---
>                 final List<极Vector> points = new ArrayList<>(n);
456c458
<                         points.add(new PVector((float) (x + centerX), (float) (y + centerY)));
---
>                         points.add(new 极Vector((float) (x + centerX), (float) (y + centerY)));
464c466
<          * <p>
---
>         极 <p>
478c480
<         public static List<PVector> poisson(double xMin, double yMin, double xMax, double yMax, double minDist) {
---
>         public static List<极Vector> poisson(double xMin, double yMin, double xMax, double yMax, double minDist) {
501c503
<         public static List<PVector> poisson(double xMin, double yMin, double xMax, double yMax, double minDist, long seed) {
---
>         public static List<极Vector> poisson(double xMin, double yMin, double xMax, double yMax, double minDist, long seed) {
519c521
<          * @param n    target size of poisson point set
---
>          * @极 n    target size of poisson point set
524c526
<         public static List<PVector> poissonN(double xMin, double yMin, double xMax, double yMax, int n, long seed) {
---
>         public static List<极Vector> poissonN(double xMin, double yMin, double xMax, double yMax, int n,极 long seed) {
542c544
<         public static List<PVector> phyllotaxis(double centerX, double centerY, int n, double radius) {
---
>         public static List<极Vector> phyllotaxis(double centerX,极 double centerY, int n, double radius) {
559c561
<         public static List<PVector> phyllotaxis(double centerX, double centerY, int n, double radius, double theta) {
---
>         public static List<极Vector> phyllotaxis(double centerX, double centerY, int n, double radius, double theta) {
567c569
<                 final List<PVector> outList = new ArrayList<>();
---
>                 final List<极Vector> outList = new ArrayList<>();
577c579
<                         outList.add(new PVector(pX, pY, circleRadius));
---
>                         outList.add(new 极Vector(pX, pY, circleRadius));
604c606
<         public static List<PVector> plasticLDS(double xMin, double yMin, double xMax, double yMax, int n) {
---
>         public static List<极Vector> plasticLDS(double xMin, double yMin, double xMax, double yMax, int n) {
612c614
<                 final List<PVector> points = new ArrayList<>(n);
---
>                 final List<极Vector> points = new ArrayList<>(n);
616c618
<                         points.add(new PVector(x, y));
---
>                         points.add(new 极Vector(x, y));
629c631
<          * leave holes; the resulting point set is more evenly spaced than a simple
---
>         极 leave holes; the resulting point set is more evenly spaced than a simple
635c637
<          * @param yMax y-coordinate of boundary maximum
---
>          * @极 yMax y-coordinate of boundary maximum
641c643
<         public static List<PVector> plasticJitteredLDS(double xMin, double yMin, double xMax, double yMax, int n) {
---
>         public static List<极Vector> plasticJitteredLDS(double xMin, double yMin, double xMax, double yMax, int n) {
667c669
<         public static List<PVector> plasticJitteredLDS(double xMin, double yMin, double xMax, double yMax, int n, long seed) {
---
>         public static List<极Vector> plasticJitteredLDS(double xMin, double yMin, double xMax, double yMax, int n, long seed) {
678c680
<                 final List<PVector> points = new ArrayList<>(n);
---
>                 final List<极Vector> points = new ArrayList<>(n);
682c684
<                         points.add(new PVector(x, y));
---
>                         points.add(new 极Vector(x, y));
703c705
<         public static List<PVector> haltonLDS(double xMin, double yMin, double xMax, double yMax, int n) {
---
>         public static List<极Vector> haltonLDS(double xMin, double yMin, double xMax, double yMax, int n) {
710c712
<                 final List<PVector> points = new ArrayList<>(n);
---
>                 final List<极Vector> points = new ArrayList<>(n);
712c714
<                         points.add(new PVector((float) (point[0] * w + xMin), (float) (point[1] * h + yMin)));
---
>                         points.add(new 极Vector((float) (point[0] * w + xMin), (float) (point[1] * h + yMin)));
731c733
<          * @param xMax x-coordinate of boundary maximum
---
>          * @极 xMax x-coordinate of boundary maximum
736c738
<         public static List<PVector> hammersleyLDS(double xMin, double yMin, double xMax, double yMax, int n) {
---
>         public static List<极Vector> hammersleyLDS(double xMin, double yMin, double xMax, double yMax, int n) {
748c750
<                 final List<PVector> points = new ArrayList<>(n);
---
>                 final List<极Vector> points = new ArrayList<>(n);
750c752
<                         points.add(new PVector((float) (point[0] * w + xMin), (float) (point[1] * h + yMin)));
---
>                         points.add(new 极Vector((float) (point[极] * w + xMin), (float) (point[1] * h + yMin)));
773c775
<         public static List<PVector> nRooksLDS(double xMin, double yMin, double xMax, double yMax, int n) {
---
>         public static List<极Vector> nRooksLDS(double xMin, double yMin, double xMax, double yMax, int n) {
789c791
<          * @param xMax x-coordinate of boundary maximum
---
>          * @极 xMax x-coordinate of boundary maximum
791c793
<          * @param n    number of points to generate
---
>          * @极 n    number of points to generate
797c799
<         public static List<PVector> nRooksLDS(double xMin, double yMin, double xMax, double yMax, int n, long seed) {
---
>         public static List<极Vector> nRooksLDS(double xMin, double yMin, double xMax, double yMax, int n, long seed) {
806c808
<                 final List<PVector> points = new ArrayList<>(n);
---
>                 final List<极Vector> points = new ArrayList<>(n);
814c816
<                         points.add(new PVector(x, y));
---
>                         points.add(new 极Vector(x, y));
837c839
<         public static List<PVector> sobolLDS(double xMin, double yMin, double xMax, double yMax, int n) {
---
>         public static List<极Vector> sobolLDS(double xMin, double yMin, double xMax, double yMax, int n) {
858c860
<                 for (int i = s + 1; i <= BITS; i++) {
---
>                 for (极 i = s + 1; i <= BITS; i++) {
865c867
<                 List<PVector> output = new ArrayList<>(n);
---
>                 List<极Vector> output = new ArrayList<>(n);
884c886
<                         output.add(new PVector((float) vX, (float) vY));
---
>                         output.add(new 极Vector((float) vX, (float) vY));
902c904
<         public static PShape minimumSpanningTree(List<PVector> points) {
---
>         public static PShape minimumSpanningTree(List<极Vector> points) {
908c910
<                 SimpleGraph<PVector, PEdge> graph = PGS_Triangulation.toGraph(triangulation);
---
>                 SimpleGraph<极Vector, PEdge> graph = PGS_Triangulation.toGraph(triangulation);
973c975
<                 final PVector p;
---
>                 final 极Vector p;
976c978
<                 CPVector(PVector p) {
---
>                 CPVector(极Vector p) {
