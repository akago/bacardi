47,51c47,60
<   protected NodeTuple representJavaBeanProperty(Object javaBean, Property property,
<                                                 Object propertyValue, Tag customTag) {
<     if (property != null && property.getName().equals("pomFile")) {
<       // "pomFile" is not a part of POM http://maven.apache.org/xsd/maven-4.0.0.xsd
<       return null;
---
>   protected Set<Property> getProperties(Class<? extends Object> type) throws IntrospectionException {
>     if (type.isAssignableFrom(Model.class)) {
>       return sortTypeWithOrder(type, ORDER_MODEL);
>     } else if (type.isAssignableFrom(Developer.class)) {
>       return sortTypeWithOrder(type, ORDER_DEVELOPER);
>     } else if (type.isAssignableFrom(Contributor.class)) {
>       return sortTypeWithOrder(type, ORDER_CONTRIBUTOR);
>     } else if (type.isAssignableFrom(Dependency.class)) {
>       return sortTypeWithOrder(type, ORDER_DEPENDENCY);
>     } else if (type.isAssignableFrom(Plugin.class)) {
>       return sortTypeWithOrder(type, ORDER_PLUGIN);
>     } else {
>       return PropertyUtils.getProperties(type);
>     }
54,57c63,68
<     if (propertyValue == null) return null;
<     if (propertyValue instanceof Map) {
<       Map map = (Map) propertyValue;
<       if (map.isEmpty()) return null;
---
>   private Set<Property> sortTypeWithOrder(Class<? extends Object> type, List<String> order)
>           throws IntrospectionException {
>     Set<Property> standard = PropertyUtils.getProperties(type);
>     Set<Property> sorted = new TreeSet<>(new ModelPropertyComparator(order));
>     sorted.addAll(standard);
>     return sorted;
59,61c70,75
<     if (propertyValue instanceof List) {
<       List map = (List) propertyValue;
<       if (map.isEmpty()) return null;
---
> 
>   private class ModelPropertyComparator implements Comparator<Property> {
>     private List<String> names;
> 
>     public ModelPropertyComparator(List<String> names) {
>       this.names = names;
63,67c77,83
<     if (javaBean instanceof Dependency) {
<       //skip optional if it is false
<       if (skipBoolean(property, "optional", propertyValue, false)) return null;
<       //skip type if it is jar
<       if (skipString(property, "type", propertyValue, "jar")) return null;
---
> 
>     public int compare(Property o1, Property o2) {
>       // important go first
>       for (String name : names) {
>         int c = compareByName(o1, o2, name);
>         if (c != 0) {
>           return c;
69,73d84
<     if (javaBean instanceof Plugin) {
<       //skip extensions if it is false
<       if (skipBoolean(property, "extensions", propertyValue, false)) return null;
<       //skip inherited if it is true
<       if (skipBoolean(property, "inherited", propertyValue, true)) return null;
75c86,87
<     return super.representJavaBeanProperty(javaBean, property, propertyValue, customTag);
---
>       // all the rest
>       return o1.compareTo(o2);
78,83c90,94
<   private boolean skipString(Property property, String name, Object propertyValue, String value) {
<     if (name.equals(property.getName())) {
<       String v = (String) propertyValue;
<       return (value.equals(v));
<     }
<     return false;
---
>     private int compareByName(Property o1, Property o2, String name) {
>       if (o1.getName().equals(name)) {
>         return -1;
>       } else if (o2.getName().equals(name)) {
>         return 1;
85,89c96
< 
<   private boolean skipBoolean(Property property, String name, Object propertyValue, boolean value) {
<     if (name.equals(property.getName())) {
<       Boolean v = (Boolean) propertyValue;
<       return (v.equals(value));
---
>       return 0;// compare further
91d97
<     return false;
94d99
< 
107a113
> 
122,131d127
<           boolean isList = singularName != null;
<           if (isList) { // check for eventual list construction
<             for (int j = 0, grandChildCount = child.getChildCount(); j < grandChildCount; j++) {
<               String grandChildName = child.getChild(j).getName();
<               isList &= grandChildName.equals(singularName);
<             }
<           }
<           if (isList) {
<             childValue = toList(child, singularName);
<           } else {
134d129
<         }
170c165
<   private static List<String> ORDER_MODEL = new ArrayList<String>(Arrays.asList(
---
>   private static List<String> ORDER_MODEL = new ArrayList<>(Arrays.asList(
204c199
<   private static List<String> ORDER_DEVELOPER = new ArrayList<String>(Arrays.asList(
---
>   private static List<String> ORDER_DEVELOPER = new ArrayList<>(Arrays.asList(
206c201
<   private static List<String> ORDER_CONTRIBUTOR = new ArrayList<String>(Arrays.asList(
---
>   private static List<String> ORDER_CONTRIBUTOR = new ArrayList<>(Arrays.asList(
208c203
<   private static List<String> ORDER_DEPENDENCY = new ArrayList<String>(Arrays.asList(
---
>   private static List<String> ORDER_DEPENDENCY = new ArrayList<>(Arrays.asList(
210c205
<   private static List<String> ORDER_PLUGIN = new ArrayList<String>(Arrays.asList(
---
>   private static List<String> ORDER_PLUGIN = new ArrayList<>(Arrays.asList(
213,270d207
< 
<   /*
<    * Change the default order. Important data goes first.
<    */
<   @Override
<   protected Set<Property> getProperties(Class<? extends Object> type)
<           throws IntrospectionException {
<     if (type.isAssignableFrom(Model.class)) {
<       return sortTypeWithOrder(type, ORDER_MODEL);
<     } else if (type.isAssignableFrom(Developer.class)) {
<       return sortTypeWithOrder(type, ORDER_DEVELOPER);
<     } else if (type.isAssignableFrom(Contributor.class)) {
<       return sortTypeWithOrder(type, ORDER_CONTRIBUTOR);
<     }  else if (type.isAssignableFrom(Dependency.class)) {
<       return sortTypeWithOrder(type, ORDER_DEPENDENCY);
<     }  else if (type.isAssignableFrom(Plugin.class)) {
<       return sortTypeWithOrder(type, ORDER_PLUGIN);
<     } else {
<       return super.getProperties(type);
<     }
<   }
< 
<   private Set<Property> sortTypeWithOrder(Class<? extends Object> type, List<String> order)
<           throws IntrospectionException {
<       Set<Property> standard = super.getProperties(type);
<       Set<Property> sorted = new TreeSet<Property>(new ModelPropertyComparator(order));
<       sorted.addAll(standard);
<       return sorted;
<   }
< 
<   private class ModelPropertyComparator implements Comparator<Property> {
<     private List<String> names;
< 
<     public ModelPropertyComparator(List<String> names) {
<       this.names = names;
<     }
< 
<     public int compare(Property o1, Property o2) {
<       // important go first
<       for (String name : names) {
<         int c = compareByName(o1, o2, name);
<         if (c != 0) {
<           return c;
<         }
<       }
<       // all the rest
<       return o1.compareTo(o2);
<     }
< 
<     private int compareByName(Property o1, Property o2, String name) {
<       if (o1.getName().equals(name)) {
<         return -1;
<       } else if (o2.getName().equals(name)) {
<         return 1;
<       }
<       return 0;// compare further
<     }
<   }
