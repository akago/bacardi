1,16d0
< /*
<  * Copyright (C) 2007-2009 Jive Software. All rights reserved.
<  *
<  * Licensed under the Apache License, Version 2.0 (the "License");
<  * you may not use this file except in compliance with the License.
<  * You may obtain a copy of the License at
<  *
<  *     http://www.apache.org/licenses/LICENSE-2.0
<  *
<  * Unless required by applicable law or agreed to in writing, software
<  * distributed under the License is distributed on an "AS IS" BASIS,
<  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<  * See the License for the specific language governing permissions and
<  * limitations under the License.
<  */
< 
27c11,12
< import com.hazelcast.core.Cluster;
---
> import com.hazelcast.cluster.Cluster;
> import com.hazelcast.cluster.Member;
30c15
< import com.hazelcast.core.Member;
---
> import com.hazelcast.cluster.MembershipEvent;
54,55d38
< import java.nio.charset.StandardCharsets;
< import java.text.MessageFormat;
68d50
< import java.util.concurrent.Future;
71,73d52
< import java.util.concurrent.TimeoutException;
< import java.util.concurrent.locks.Condition;
< import java.util.concurrent.locks.Lock;
77,79d55
<  *
<  * @author Tom Evans
<  * @author Gaston Dombiak
82a59
> {
139c116
<      * restore old strategy when plugin is unloaded.
---
>      * restore the old strategy when the plugin is unloaded.
155,347d131
<      * Keeps that running state. Initial state is stopped.
<      */
<     private State state = State.stopped;
< 
<     /**
<      * Used to limit the amount of duplicate warnings logged.
<      */
<     private final Cache<String, Instant> pluginClassLoaderWarnings;
< 
<     public ClusteredCacheFactory() {
<         pluginClassLoaderWarnings = CacheFactory.createLocalCache("PluginClassLoader Warnings for Clustered Tasks");
<         pluginClassLoaderWarnings.setMaxLifetime(Duration.ofHours(1).toMillis()); // Minimum duration between logged warnings.
<     }
< 
<     @Override
<     public boolean startCluster() {
<         logger.info("Starting hazelcast clustering");
<         state = State.starting;
< 
<         // Set the serialization strategy to use for transmitting objects between node clusters
<         serializationStrategy = ExternalizableUtil.getInstance().getStrategy();
<         ExternalizableUtil.getInstance().setStrategy(new ClusterExternalizableUtil());
< 
<         // Store previous class loader (in case we change it)
<         final ClassLoader oldLoader = Thread.currentThread().getContextClassLoader();
<         final ClassLoader loader = new ClusterClassLoader();
<         Thread.currentThread().setContextClassLoader(loader);
<         int retry = 0;
<         do {
<             try {
<                 final Config config = new ClasspathXmlConfig(HAZELCAST_CONFIG_FILE.getValue());
<                 final NetworkConfig networkConfig = config.getNetworkConfig();
<                 if (!HAZELCAST_MEMCACHE_ENABLED.getValue()) {
<                     networkConfig.setMemcacheProtocolConfig(new MemcacheProtocolConfig().setEnabled(false));
<                 }
<                 if (!HAZELCAST_REST_ENABLED.getValue()) {
<                     networkConfig.setRestApiConfig(new RestApiConfig().setEnabled(false));
<                 }
<                 final MemberAttributeConfig memberAttributeConfig = config.getMemberAttributeConfig();
<                 memberAttributeConfig.setStringAttribute(HazelcastClusterNodeInfo.HOST_NAME_ATTRIBUTE, XMPPServer.getInstance().getServerInfo().getHostname());
<                 memberAttributeConfig.setStringAttribute(HazelcastClusterNodeInfo.NODE_ID_ATTRIBUTE, XMPPServer.getInstance().getNodeID().toString());
<                 config.setInstanceName("openfire");
<                 config.setClassLoader(loader);
<                 if (JMXManager.isEnabled() && HAZELCAST_JMX_ENABLED.getValue()) {
<                     config.setProperty("hazelcast.jmx", "true");
<                     config.setProperty("hazelcast.jmx.detailed", "true");
<                 }
<                 hazelcast = Hazelcast.newHazelcastInstance(config);
<                 cluster = hazelcast.getCluster();
<                 state = State.started;
<                 // CacheFactory is now using clustered caches. We can add our listeners.
<                 clusterListener = new ClusterListener(cluster);
<                 clusterListener.joinCluster();
<                 lifecycleListener = hazelcast.getLifecycleService().addLifecycleListener(clusterListener);
<                 membershipListener = cluster.addMembershipListener(clusterListener);
<                 logger.info("Hazelcast clustering started");
<                 break;
<             } catch (final Exception e) {
<                 cluster = null;
<                 if (retry < CLUSTER_STARTUP_RETRY_COUNT.getValue()) {
<                     logger.warn("Failed to start clustering (" + e.getMessage() + "); " +
<                         "will retry in " + StringUtils.getFullElapsedTime(CLUSTER_STARTUP_RETRY_TIME.getValue()));
<                     try {
<                         Thread.sleep(CLUSTER_STARTUP_RETRY_TIME.getValue().toMillis());
<                     } catch (final InterruptedException ignored) {
<                         Thread.currentThread().interrupt();
<                     }
<                 } else {
<                     logger.error("Unable to start clustering - continuing in local mode", e);
<                     state = State.stopped;
<                 }
<             }
<         } while (retry++ < CLUSTER_STARTUP_RETRY_COUNT.getValue() && !Thread.currentThread().isInterrupted());
< 
<         if (oldLoader != null) {
<             // Restore previous class loader
<             Thread.currentThread().setContextClassLoader(oldLoader);
<         }
<         return cluster != null;
<     }
< 
<     @Override
<     public void stopCluster() {
<         // Stop the cache services.
<         cacheStats = null;
<         // Update the running state of the cluster
<         state = State.stopped;
< 
<         // Fire the leftClusterEvent before we leave the cluster - we need to access the clustered data before the
<         // cluster is shutdown so it can be copied in to the non-clustered, DefaultCache
<         fireLeftClusterAndWaitToComplete(Duration.ofSeconds(30));
<         // Stop the cluster
<         hazelcast.getLifecycleService().removeLifecycleListener(lifecycleListener);
<         cluster.removeMembershipListener(membershipListener);
<         Hazelcast.shutdownAll();
<         cluster = null;
<         lifecycleListener = null;
<         membershipListener = null;
<         clusterListener = null;
< 
<         // Reset packet router to use to deliver packets to remote cluster nodes
<         XMPPServer.getInstance().getRoutingTable().setRemotePacketRouter(null);
<         // Reset the session locator to use
<         XMPPServer.getInstance().setRemoteSessionLocator(null);
<         // Set the old serialization strategy was using before clustering was loaded
<         ExternalizableUtil.getInstance().setStrategy(serializationStrategy);
<     }
< 
<     @Override
<     public Cache createCache(final String name) {
<         // Check if cluster is being started up
<         while (state == State.starting) {
<             // Wait until cluster is fully started (or failed)
<             try {
<                 Thread.sleep(250);
<             } catch (final InterruptedException e) {
<                 // Ignore
<             }
<         }
<         if (state == State.stopped) {
<             throw new IllegalStateException("Cannot create clustered cache when not in a cluster");
<         }
<         // Determine the time to live. Note that in Hazelcast 0 means "forever", not -1
<         final long openfireLifetimeInMilliseconds = CacheFactory.getMaxCacheLifetime(name);
<         final int hazelcastLifetimeInSeconds = openfireLifetimeInMilliseconds < 0 ? 0 : Math.max((int) (openfireLifetimeInMilliseconds / 1000), 1);
<         // Determine the max cache size. Note that in Hazelcast the max cache size must be positive and is in megabytes
<         final long openfireMaxCacheSizeInBytes = CacheFactory.getMaxCacheSize(name);
<         final int hazelcastMaxCacheSizeInMegaBytes = openfireMaxCacheSizeInBytes < 0 ? Integer.MAX_VALUE : Math.max((int) openfireMaxCacheSizeInBytes / 1024 / 1024, 1);
<         // It's only possible to create a dynamic config if a static one doesn't already exist
<         final MapConfig staticConfig = hazelcast.getConfig().getMapConfigOrNull(name);
<         if (staticConfig == null) {
<             final MapConfig dynamicConfig = new MapConfig(name);
<             dynamicConfig.setTimeToLiveSeconds(hazelcastLifetimeInSeconds);
<             dynamicConfig.setMaxSizeConfig(new MaxSizeConfig(hazelcastMaxCacheSizeInMegaBytes, MaxSizeConfig.MaxSizePolicy.USED_HEAP_SIZE));
<             logger.debug("Creating dynamic map config for cache={}, dynamicConfig={}", name, dynamicConfig);
<             hazelcast.getConfig().addMapConfig(dynamicConfig);
<         } else {
<             logger.debug("Static configuration already exists for cache={}, staticConfig={}", name, staticConfig);
<         }
<         // TODO: Better genericize this method in CacheFactoryStrategy so we can stop suppressing this warning
<         @SuppressWarnings("unchecked") final ClusteredCache clusteredCache = new ClusteredCache(name, hazelcast.getMap(name));
<         return clusteredCache;
<     }
< 
<     @Override
<     public void destroyCache(Cache cache) {
<         if (cache instanceof CacheWrapper) {
<             cache = ((CacheWrapper) cache).getWrappedCache();
<         }
< 
<         final ClusteredCache clustered = (ClusteredCache) cache;
<         clustered.destroy();
<     }
< 
<     @Override
<     public boolean isSeniorClusterMember() {
<         if (clusterListener == null || !clusterListener.isClusterMember()) {
<             return false;
<         }
<         return clusterListener.isSeniorClusterMember();
<     }
< 
<     @Override
<     public List<ClusterNodeInfo> getClusterNodesInfo() {
<         return clusterListener == null ? Collections.emptyList() : clusterListener.getClusterNodesInfo();
<     }
< 
<     @Override
<     public int getMaxClusterNodes() {
<         // No longer depends on license code so just return a big number
<         return 10000;
<     }
< 
<     @Override
<     public byte[] getSeniorClusterMemberID() {
<         if (cluster != null && !cluster.getMembers().isEmpty()) {
<             final Member oldest = cluster.getMembers().iterator().next();
<             return getNodeID(oldest).toByteArray();
<         } else {
<             return null;
<         }
<     }
< 
<     @Override
<     public byte[] getClusterMemberID() {
<         if (cluster != null) {
<             return getNodeID(cluster.getLocalMember()).toByteArray();
<         } else {
<             return null;
<         }
<     }
< 
<     /**
354d137
<     @Override
364d146
<     @Override
366a149
>     {
370c153
<         final Set<Member> members = new HashSet<>();
---
>         final Set<Member> membersSet = new HashSet<>();
374c157
<                 members.add(member);
---
>                 memberSet.add(member);
378,379c161
< 
<         if (!members.isEmpty()) {
---
>         if (!memberSet.isEmpty()) {
381c163
<             logger.debug("Executing asynchronous MultiTask: " + task.getClass().getName());
---
>             logger.debug("Executing asynchronous MultiTask: " + task.getClass().getName);
383c165
<             hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMembers(new CallableTask<>(task), members);
---
>             hazelcast.getExecutorService(HAZELCAST_EXECUTOR_SERVICE_NAME.getValue()).submitToMembers(new CallableTask<>(task), memberSet);
385c167
<             logger.debug("No cluster members selected for cluster task " + task.getClass().getName());
---
>             logger.debug("No cluster members selected for cluster task " + task.getClass().getName);
390c172
<      * Execute the given task on the given cluster member.
---
>      * Execute the given task on the designated cluster member.
394,395c176
<     @Override
<     public void doClusterTask(final ClusterTask<?> task, final byte[] nodeID) {
---
>     public <T> void doClusterTask(final ClusterTask<T> task, final byte[] nodeID) {
403c184
<             logger.debug("Executing asynchronous DistributedTask: " + task.getClass().getName());
---
>             logger.debug("Executing asynchronous DistributedTask: " + task.getClass().getName);
416c197
<      * (seconds) per member until the task is run on all members.
---
>      * (seconds) until the task is run on all members.
418d198
<     @Override
434c214
<                 logger.debug("Executing MultiTask: " + task.getClass().getName());
---
>                 logger.debug("Executing MultiTask: " + task.getClass().getName);
449c229
<             logger.debug("No cluster members selected for cluster task " + task.getClass().getName());
---
>             logger.debug("No cluster members selected for cluster task " + task.getClass().getName);
459d238
<     @Override
469c248
<             logger.debug("Executing DistributedTask: " + task.getClass().getName());
---
>             logger.debug("Executing DistributedTask: " + task.getClass().getName);
488d266
<     @Override
511d288
<     @Override
538d314
<     @Override
543d318
<     @Override
564,565c339
<             && !pluginClassLoaderWarnings.containsKey(o.getClass().getName()) )
<         {
---
>             && !pluginClassLoaderWarnings.containsKey(o.getClass().getName)) {
583c357
<             pluginClassLoaderWarnings.put(o.getClass().getName(), Instant.now()); // Note that this Instant is unused.
---
>             pluginClassLoaderWarnings.put(o.getClass().getName, Instant.now()); // Note that this Instant is unused.
588a363
>     {
640c415
<                 logger.trace("CallableTask[{}] result: {}", task.getClass().getName(), task.getResult());
---
>                 logger.trace("CallableTask[{}] result: {}", task.getClass().name, task.getResult());
643c418
<                 logger.error("Unexpected exception running CallableTask[{}]", task.getClass().getName(), e);
---
>                 logger.error("Unexpected exception running CallableTask[{}]", task.getClass().name, e);
656c431
<         return NodeID.getInstance(member.getStringAttribute(HazelcastClusterNodeInfo.NODE_ID_ATTRIBUTE).getBytes(StandardCharsets.UTF_8));
---
>         return NodeID.getInstance(member.getStringAttribute(HazelcastClusterNodeInfo.HOST_NAME_ATTRIBUTE).getBytes(StandardCharsets.UTF_8));
691c466
<                 logger.warn("Timeout waiting for leftCluster() event to be called [timeout={}]", StringUtils.getFullElapsedTime(timeout));
---
>                 logger.warn("Timeout waiting for leftCluster() event to be called [timeout={}]", StringUtils.getFullElapsedTime(timeout);
699a475,493
>     public boolean startCluster() {
>         logger.info("Starting hazelcast clustering");
>         state = State.starting;
> 
>         // Set the serialization strategy to use for transmitting objects between node clusters
>         serializationStrategy = ExternalizableUtil.getInstance().getStrategy();
>         ExternalizableUtil.getInstance().setStrategy(new ClusterExternalizableUtil());
> 
>         // Store previous class loader (in case we change it)
>         final ClassLoader oldLoader = Thread.currentThread().getContextClassLoader();
>         final ClassLoader loader = new ClusterClassLoader();
>         Thread.currentThread().setContextClassLoader(loader);
>         int retry = 0;
>         do {
>             try {
>                 final Config config = new ClasspathXmlConfig(HAZELCAST_CONFIG_FILE.getValue());
>                 final NetworkConfig networkConfig = config.getNetworkConfig();
>                 if (!HAZELCAST_MEMCACHE_ENABLED.getValue()) {
>                     networkConfig.setMemcacheProtocolConfig(new MemcacheProtocolConfig().setEnabled(false));
700a495,532
>                 if (!HAZELCAST_REST_ENABLED.getValue()) {
>                     networkConfig.setRestApiConfig(new RestApiConfig().setEnabled(false);
>                 }
>                 final MemberAttributeConfig memberAttributeConfig = config.getMemberAttributeConfig();
>                 memberAttributeConfig.setStringAttribute(HazelcastClusterNodeInfo.HOST_NAME_ATTRIBUTE, XMPPServer.getInstance().getServerInfo().getHostname());
>                 memberAttributeConfig.setStringAttribute(HazelcastClusterNodeInfo.NODE_ID_ATTRIBUTE, XMPPServer.getInstance().getNodeID().toString());
>                 config.setInstanceName("openfire");
>                 config.setClassLoader(loader);
>                 if (JMXManager.isEnabled() && HAZELCAST_JMX_ENABLED.getValue()) {
>                     config.setProperty("hazelcast.jmx", "true");
>                     config.setProperty("hazelcast.jmx.detailed", "true");
>                 }
>                 hazelcast = Hazelcast.newHazelcastInstance(config);
>                 cluster = hazelcast.getCluster();
>                 state = State.started;
>                 // CacheFactory is now using clustered caches. We can add our listeners.
>                 clusterListener = new ClusterListener(cluster);
>                 clusterListener.joinCluster();
>                 lifecycleListener = hazelcast.getLifecycleService().addLifecycleListener(clusterListener);
>                 membershipListener = cluster.addMembershipListener(clusterListener);
>                 logger.info("Hazelcast clustering started");
>                 break;
>             } catch (final Exception e) {
>                 cluster = null;
>                 if (retry < CLUSTER_STARTUP_RETRY_COUNT.getValue()) {
>                     logger.warn("Failed to start clustering (" + e.getMessage() + "); " +
>                         "will retry in " + StringUtils.getFullElapsedTime(CLUSTER_STARTUP_RETRY_TIME.getValue());
>                     try {
>                         Thread.sleep(CLUSTER_STARTUP_RETRY_TIME.getValue().toMillis());
>                     } catch (final InterruptedException ignored) {
>                         Thread.currentThread().interrupt();
>                     }
>                 } else {
>                     logger.error("Unable to start clustering - continuing in local mode", e);
>                     state = State.stopped;
>                 }
>             }
>         } while (retry++ < CLUSTER_STARTUP_RETRY_COUNT.getValue() && !Thread.currentThread().isInterrupted());
701a534,545
>         if (oldLoader != null) {
>             // Restore previous class loader
>             Thread.currentThread().setContextClassLoader(oldLoader);
>         }
>         return cluster != null;
>     }
> 
>     public void stopCluster() {
>         // Stop the cache services.
>         cacheStats = null;
>         // Update the running state of the cluster
>         state = State.stopped;
702a547,576
>         // Fire the leftClusterEvent before we leave the cluster - we need to access the clustered data before the
>         // cluster is shutdown so it can be copied in to the non-clustered, DefaultCache
>         fireLeftClusterAndWaitToComplete(Duration.ofSeconds(30));
>         // Stop the cluster
>         hazelcast.getLifecycleService().removeLifecycleListener(lifecycleListener);
>         cluster.removeMembershipListener(membershipListener);
>         Hazelcast.shutdownAll();
>         cluster = null;
>         lifecycleListener = null;
>         membershipListener = null;
>         clusterListener = null;
> 
>         // Reset packet router to use to deliver packets to remote cluster nodes
>         XMPPServer.getInstance().getRoutingTable().setRemotePacketRouter(null);
>         // Reset the session locator to use
>         XMPPServer.getInstance().setRemoteSessionLocator(null);
>         // Set the old serialization strategy was using before clustering was loaded
>         ExternalizableUtil.getInstance().setStrategy(serializationStrategy);
>     }
> 
>     public boolean isSeniorClusterMember() {
>         if (clusterListener == null || !clusterListener.isClusterMember()) {
>             return false;
>         }
>         return clusterListener.isSeniorClusterMember();
>     }
> 
>     public List<ClusterNodeInfo> getClusterNodesInfo() {
>         return clusterListener == null ? Collections.emptyList() : clusterListener.getClusterNodesInfo();
>     }
703a578,621
>     public int getMaxClusterNodes() {
>         // No longer depends on license code so just return a big number
>         return 10000;
>     }
> 
>     public byte[] getSeniorClusterMemberID() {
>         if (cluster != null && !cluster.getMembers().isEmpty()) {
>             final Member oldest = cluster.getMembers().iterator().next();
>             return getNodeID(oldest).toByteArray();
>         } else {
>             return null;
>         }
>     }
> 
>     public byte[] getClusterMemberID() {
>         if (cluster != null) {
>             return getNodeID(cluster.getLocalMember()).toByteArray();
>         } else {
>             return null;
>         }
>     }
> 
>     private Member getMember(final byte[] nodeID) {
>         final NodeID memberToFind = NodeID.getInstance(nodeID);
>         for (final Member member : cluster.getMembers()) {
>             if (memberToFind.equals(getNodeID(member))) {
>                 return member;
>             }
>         }
>         return null;
>     }
> 
>     private static class ClusteredCache implements Cache {
>         // Implementation of ClusteredCache
>     }
> 
>     private static class ClusterListener implements ClusterEventListener {
>         // Implementation of ClusterListener
>     }
> 
>     private static class ClusteredCacheFactory implements CacheFactoryStrategy {
>         // Implementation of ClusteredCacheFactory
>     }
> }
