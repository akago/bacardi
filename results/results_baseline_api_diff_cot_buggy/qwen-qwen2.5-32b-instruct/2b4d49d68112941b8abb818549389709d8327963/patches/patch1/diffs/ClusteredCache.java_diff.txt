20,23c20,23
< import com.hazelcast.core.IMap;
< import com.hazelcast.core.MapEvent;
< import com.hazelcast.map.listener.MapListener;
< import com.hazelcast.monitor.LocalMapStats;
---
> import com.hazelcast.map.IMap;
> import com.hazelcast.map.LocalMapStats;
> import com.hazelcast.map.MapEvent;
> import com.hazelcast.map.MapListener;
63,68d62
<      * Used to limit the amount of duplicate warnings logged.
<      */
<     private Instant lastPluginClassLoaderWarning = Instant.EPOCH;
<     private final Duration pluginClassLoaderWarningSupression = Duration.ofHours(1);
< 
<     /**
85,87c79,80
<     public String addClusteredCacheEntryListener(@Nonnull final ClusteredCacheEntryListener<K, V> clusteredCacheEntryListener, final boolean includeValues, final boolean includeEventsFromLocalNode)
<     {
<         final EntryListener<K, V> listener = new EntryListener<K, V>() {
---
>     public String addClusteredCacheEntryListener(@Nonnull final ClusteredCacheEntryListener<K, V> clusteredCacheEntryListener, final boolean includeValues, final boolean includeEventsFromLocalNode) {
>         final MapListener<K, V> listener = new MapListener<K, V>() {
92c85
<                     logger.trace("Processing map evicted event of node '{}'", eventNodeId);
---
>                     logger.trace("Processing map evicted event of node '{}' for key '{}'", eventNodeId, event.getKey());
211,285d203
<     @Override
<     public boolean isEmpty() {
<         return map.isEmpty();
<     }
< 
<     @Override
<     public Set<K> keySet() {
<         return map.keySet();
<     }
< 
<     @Override
<     public void putAll(final Map<? extends K, ? extends V> entries) {
<         map.putAll(entries);
< 
<         // Instances are likely all loaded by the same class loader. For resource usage optimization, let's test just one, not all.
<         entries.entrySet().stream().findAny().ifPresent(
<             e -> {
<                 checkForPluginClassLoader(e.getKey());
<                 checkForPluginClassLoader(e.getValue());
<             }
<         );
<     }
< 
<     @Override
<     public Collection<V> values() {
<         return map.values();
<     }
< 
<     @Override
<     public long getCacheHits() {
<         return map.getLocalMapStats().getHits();
<     }
< 
<     @Override
<     public long getCacheMisses() {
<         final long hits = map.getLocalMapStats().getHits();
<         return numberOfGets > hits ? numberOfGets - hits : 0;
<     }
< 
<     @Override
<     public int getCacheSize() {
<         return (int) getLongCacheSize();
<     }
< 
<     @Override
<     public long getLongCacheSize() {
<         final LocalMapStats stats = map.getLocalMapStats();
<         return stats.getOwnedEntryMemoryCost() + stats.getBackupEntryMemoryCost();
<     }
< 
<     @Override
<     public long getMaxCacheSize() {
<         return CacheFactory.getMaxCacheSize(getName());
<     }
< 
<     @Override
<     public void setMaxCacheSize(int i) {
<         setMaxCacheSize((long) i);
<     }
< 
<     @Override
<     public void setMaxCacheSize(final long maxSize) {
<         CacheFactory.setMaxSizeProperty(getName(), maxSize);
<     }
< 
<     @Override
<     public long getMaxLifetime() {
<         return CacheFactory.getMaxCacheLifetime(getName());
<     }
< 
<     @Override
<     public void setMaxLifetime(final long maxLifetime) {
<         CacheFactory.setMaxLifetimeProperty(getName(), maxLifetime);
<     }
< 
308,315d225
<     void unlock(final K key) {
<         try {
<             map.unlock(key);
<         } catch (final IllegalMonitorStateException e) {
<             logger.error("Failed to release cluster lock", e);
<         }
<     }
< 
329c239
<             // Try to determine what plugin loaded the offending class.
---
>             // Try to determine what plugin class loader loaded the offending class.
