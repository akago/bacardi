1,15d0
< /*
<  * Copyright (C) 1999-2009 Jive Software. All rights reserved.
<  *
<  * Licensed under the Apache License, Version 2.0 (the "License");
<  * you may not use this file except in compliance with the License.
<  * You may obtain a copy of the License at
<  *
<  *     http://www.apache.org/licenses/LICENSE-2.0
<  *
<  * Unless required by applicable law or agreed to in writing, software
<  * distributed under the License is distributed on an "AS IS" BASIS,
<  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<  * See the License for the specific language governing permissions and
<  * limitations under the License.
<  */
18,26c3,15
< import com.hazelcast.core.Cluster;
< import com.hazelcast.core.EntryListener;
< import com.hazelcast.core.LifecycleEvent;
< import com.hazelcast.core.LifecycleEvent.LifecycleState;
< import com.hazelcast.core.LifecycleListener;
< import com.hazelcast.core.Member;
< import com.hazelcast.core.MemberAttributeEvent;
< import com.hazelcast.core.MembershipEvent;
< import com.hazelcast.core.MembershipListener;
---
> import com.hazelcast.cluster.Cluster;
> import com.hazelcast.cluster.Member;
> import com.hazelcast.cluster.MembershipEvent;
> import com.hazelcast.cluster.MembershipListener;
> import com.hazelcast.cluster.LifecycleEvent;
> import com.hazelcast.cluster.LifecycleListener;
> import com.hazelcast.cluster.LifecycleState;
> import com.hazelcast.cluster.MemberAttributeEvent;
> import com.hazelcast.cluster.MemberAttributeEvent.MemberAttributeOperationType;
> import com.hazelcast.cluster.impl.MemberImpl;
> import com.hazelcast.cluster.impl.MembershipEventImpl;
> import com.hazelcast.cluster.impl.MembershipListenerImpl;
> import com.hazelcast.cluster.impl.MemberAttributeEventImpl;
53a43
> {
76a67,68
>     {
> 
86c78
<             final Cache wrapped = ((CacheWrapper)cache).getWrappedCache();
---
>             final Cache wrapped = ((CacheWrapper)cache).getWrappedCache());
122c114
<             new Object[]{ClusteredCacheFactory.getNodeID(cluster.getLocalMember()), cluster.getLocalMember().getUuid(), seniorClusterMember});
---
>             new Object[]{ClusteredCacheFactory.nodeID(cluster.getLocalMember()), cluster.localMember().getUuid(), seniorClusterMember});
128,129c120,121
<         final Iterator<Member> members = cluster.getMembers().iterator();
<         return members.next().getUuid().equals(cluster.getLocalMember().getUuid());
---
>         final Iterator<Member> membersIterator = cluster.getMembers().iterator();
>         return memberIterator.next().getUuid().equals(cluster.localMember().getUuid());
150c142
<             new Object[]{ClusteredCacheFactory.getNodeID(cluster.getLocalMember()), cluster.getLocalMember().getUuid(), wasSeniorClusterMember});
---
>             new Object[]{ClusteredCacheFactory.nodeID(cluster.localMember()), cluster.localMember().getUuid(), wasSeniorClusterMember});
161c153
<         final NodeID nodeID = ClusteredCacheFactory.getNodeID(event.getMember());
---
>         final NodeID nodeID = ClusteredCacheFactory.nodeID(event.getMember());
181d172
<                 // TODO Instead of the 30 second wait, we should look (and then wait) for some trigger or event that signifies that local handling has completed and caches have stabilized.
230a222
>         final boolean wasSenior = isSenior;
232,233c224,225
<         final NodeID nodeID = ClusteredCacheFactory.getNodeID(event.getMember());
< 
---
>         // local member only
>         final NodeID nodeID = ClusteredCacheFactory.nodeID(event.getMember());
256,269d247
<     @SuppressWarnings("WeakerAccess")
<     public List<ClusterNodeInfo> getClusterNodesInfo() {
<         return new ArrayList<>(clusterNodesInfo.values());
<     }
< 
<     @Override
<     public void stateChanged(final LifecycleEvent event) {
<         if (event.getState().equals(LifecycleState.SHUTDOWN)) {
<             leaveCluster();
<         } else if (event.getState().equals(LifecycleState.STARTED)) {
<             joinCluster();
<         }
<     }
< 
274,275c252,253
<         final ClusterNodeInfo priorNodeInfo = clusterNodesInfo.get(ClusteredCacheFactory.getNodeID(event.getMember()));
<         clusterNodesInfo.put(ClusteredCacheFactory.getNodeID(event.getMember()),
---
>         final ClusterNodeInfo priorNodeInfo = clusterNodesInfo.get(ClusteredCacheFactory.nodeID(event.getMember()));
>         clusterNodesInfo.put(ClusteredCacheFactory.nodeID(event.getMember()),
