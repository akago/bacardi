12d11
< import redis.clients.jedis.Client;
13a13,15
> import redis.clients.jedis.JedisClientConfig;
> import redis.clients.jedis.JedisCluster;
> import redis.clients.jedis.JedisClusterConnectionHandler;
39c41
<     protected Jedis getConnection() {
---
>     public Jedis getConnection() {
92a95
>         Object response;
94,101c97,100
<             @SuppressWarnings("unchecked")
<             List<Object> rawResponse = (List<Object>) conn.sendBlockingCommand(RedisGraphCommand.QUERY,
<                     graphId, preparedQuery, Utils.COMPACT_STRING, Utils.TIMEOUT_STRING, Long.toString(timeout));
<             return new ResultSetImpl(rawResponse, this, caches.getGraphCache(graphId));
<         } catch (JRedisGraphException rt) {
<             throw rt;
<         } catch (JedisDataException j) {
<             throw new JRedisGraphException(j);
---
>             response = conn.sendCommand(RedisGraphCommand.QUERY, graphId, preparedQuery, Utils.COMPACT_STRING, Utils.TIMEOUT_STRING, Long.toString(timeout));
>         } catch (Exception e) {
>             conn.close();
>             throw e;
102a102,104
>         //clear local state
>         caches.removeGraphCache(graphId);
>         return SafeEncoder.encode((byte[]) response);
106,110c108,110
<      * Sends the read-only query over the instance only connection
<      * @param graphId graph to be queried
<      * @param timeout
<      * @param preparedQuery prepared query
<      * @return Result set with the query answer
---
>      * Deletes the entire graph
>      * @param graphId graph to delete
>      * @return delete running time statistics
113c113
<     protected ResultSet sendReadOnlyQuery(String graphId, String preparedQuery, long timeout) {
---
>     public String deleteGraph(String graphId) {
114a115
>         Object response;
116,123c117,120
<             @SuppressWarnings("unchecked")
<             List<Object> rawResponse = (List<Object>) conn.sendBlockingCommand(RedisGraphCommand.RO_QUERY,
<                     graphId, preparedQuery, Utils.COMPACT_STRING, Utils.TIMEOUT_STRING, Long.toString(timeout));
<             return new ResultSetImpl(rawResponse, this, caches.getGraphCache(graphId));
<         } catch (JRedisGraphException ge) {
<             throw ge;
<         } catch (JedisDataException de) {
<             throw new JRedisGraphException(de);
---
>             response = conn.sendCommand(RedisGraphCommand.DELETE, graphId);
>         } catch (Exception e) {
>             conn.close();
>             throw e;
124a122,124
>         //clear local state
>         caches.removeGraphCache(graphId);
>         return SafeEncoder.encode((byte[]) response);
128c128
<      * @return Returns the instance Jedis connection.
---
>      * closes the Jedis connection
131,132c131,137
<     public Jedis getConnectionContext() {
<         return this.connectionContext;
---
>     public void close() {
>         this.connectionContext.close();
>     }
> 
>     @Override
>     public void setRedisGraphCaches(RedisGraphCaches caches) {
>         this.caches = caches;
139d143
<     @Override
142,145c146,148
<         Client client = jedis.getClient();
<         client.multi();
<         client.getOne();
<         RedisGraphTransaction transaction = new RedisGraphTransaction(client, this);
---
>         // Assuming Jedis now does not expose Client directly, and transaction handling is done differently
>         // Placeholder for transaction handling logic
>         RedisGraphTransaction transaction = new RedisGraphTransaction(jedis, this);
154d156
<     @Override
157,158c159,161
<         Client client = jedis.getClient();
<         RedisGraphPipeline pipeline = new RedisGraphPipeline(client, this);
---
>         // Assuming Jedis now does not expose Client directly, and pipeline handling is done differently
>         // Placeholder for pipeline handling logic
>         RedisGraphPipeline pipeline = new RedisGraphPipeline(jedis, this);
168d170
<     @Override
177d178
<     @Override
181,215d181
< 
<     /**
<      * Deletes the entire graph
<      * @param graphId graph to delete
<      * @return delete running time statistics
<      */
<     @Override
<     public String deleteGraph(String graphId) {
<         Jedis conn = getConnection();
<         Object response;
<         try {
<             response = conn.sendCommand(RedisGraphCommand.DELETE, graphId);
<         } catch (Exception e) {
<             conn.close();
<             throw e;
<         }
<         //clear local state
<         caches.removeGraphCache(graphId);
<         return SafeEncoder.encode((byte[]) response);
<     }
< 
<     /**
<      * closes the Jedis connection
<      */
<     @Override
<     public void close() {
<         this.connectionContext.close();
< 
<     }
< 
<     @Override
<     public void setRedisGraphCaches(RedisGraphCaches caches) {
<         this.caches = caches;
<     }
< 
