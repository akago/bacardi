You are an Automatic Program Repair (APR) tool specialized in fixing Java code issues caused by breaking dependency updates. Your task is to analyze the provided code, error information, and API changes, then propose and apply a patch to fix the issue while adhering to specific constraints.

Here is the Java code that is failing:

```java
/**
 * Copyright (c) 2012 to original author or authors
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 */
package org.sonatype.maven.polyglot.yaml;

import org.apache.maven.model.Contributor;
import org.apache.maven.model.Dependency;
import org.apache.maven.model.Developer;
import org.apache.maven.model.Model;
import org.apache.maven.model.Plugin;
import org.codehaus.plexus.util.xml.Xpp3Dom;
import org.yaml.snakeyaml.error.YAMLException;
import org.yaml.snakeyaml.introspector.Property;
import org.yaml.snakeyaml.nodes.Node;
import org.yaml.snakeyaml.nodes.NodeTuple;
import org.yaml.snakeyaml.nodes.Tag;
import org.yaml.snakeyaml.representer.Represent;
import org.yaml.snakeyaml.representer.Representer;

import java.beans.IntrospectionException;
import java.util.*;

import static java.lang.String.format;

/**
 * YAML model representer.
 *
 * @author jvanzyl
 * @author bentmann
 * @since 0.7
 */
class ModelRepresenter extends Representer {
  public ModelRepresenter() {
    this.representers.put(Xpp3Dom.class, new RepresentXpp3Dom());
    Represent stringRepresenter = this.representers.get(String.class);
    this.representers.put(Boolean.class, stringRepresenter);
    this.multiRepresenters.put(Number.class, stringRepresenter);
    this.multiRepresenters.put(Date.class, stringRepresenter);
    this.multiRepresenters.put(Enum.class, stringRepresenter);
    this.multiRepresenters.put(Calendar.class, stringRepresenter);
  }

  protected NodeTuple representJavaBeanProperty(Object javaBean, Property property,
                                                Object propertyValue, Tag customTag) {
    if (property != null && property.getName().equals("pomFile")) {
      // "pomFile" is not a part of POM http://maven.apache.org/xsd/maven-4.0.0.xsd
      return null;
    }

    if (propertyValue == null) return null;
    if (propertyValue instanceof Map) {
      Map map = (Map) propertyValue;
      if (map.isEmpty()) return null;
    }
    if (propertyValue instanceof List) {
      List map = (List) propertyValue;
      if (map.isEmpty()) return null;
    }
    if (javaBean instanceof Dependency) {
      //skip optional if it is false
      if (skipBoolean(property, "optional", propertyValue, false)) return null;
      //skip type if it is jar
      if (skipString(property, "type", propertyValue, "jar")) return null;
    }
    if (javaBean instanceof Plugin) {
      //skip extensions if it is false
      if (skipBoolean(property, "extensions", propertyValue, false)) return null;
      //skip inherited if it is true
      if (skipBoolean(property, "inherited", propertyValue, true)) return null;
    }
    return super.representJavaBeanProperty(javaBean, property, propertyValue, customTag);
  }

  private boolean skipString(Property property, String name, Object propertyValue, String value) {
    if (name.equals(property.getName())) {
      String v = (String) propertyValue;
      return (value.equals(v));
    }
    return false;
  }

  private boolean skipBoolean(Property property, String name, Object propertyValue, boolean value) {
    if (name.equals(property.getName())) {
      Boolean v = (Boolean) propertyValue;
      return (v.equals(value));
    }
    return false;
  }


  private class RepresentXpp3Dom implements Represent {
    private static final String ATTRIBUTE_PREFIX = "attr/";

    public Node representData(Object data) {
      return representMapping(Tag.MAP, toMap((Xpp3Dom) data), null);
    }

    private Map<String, Object> toMap(Xpp3Dom node) {
      Map<String, Object> map = new LinkedHashMap<>();

      int n = node.getChildCount();
      for (int i = 0; i < n; i++) {
        Xpp3Dom child = node.getChild(i);
        String childName = child.getName();

        String singularName = null;
        int childNameLength = childName.length();
        if ("reportPlugins".equals(childName)) {
          singularName = "plugin";
        } else if (childNameLength > 3 && childName.endsWith("ies")) {
          singularName = childName.substring(0, childNameLength - 3);
        } else if (childNameLength > 1 && childName.endsWith("s")) {
          singularName = childName.substring(0, childNameLength - 1);
        }

        Object childValue = child.getValue();
        if (childValue == null) {
          boolean isList = singularName != null;
          if (isList) { // check for eventual list construction
            for (int j = 0, grandChildCount = child.getChildCount(); j < grandChildCount; j++) {
              String grandChildName = child.getChild(j).getName();
              isList &= grandChildName.equals(singularName);
            }
          }
          if (isList) {
            childValue = toList(child, singularName);
          } else {
            childValue = toMap(child);
          }
        }
        map.put(childName, childValue);
      }

      for (String attrName : node.getAttributeNames()) {
        map.put(ATTRIBUTE_PREFIX + attrName, node.getAttribute(attrName));
      }

      return map;
    }

    private List<Object> toList(Xpp3Dom node, String childName) {
      List<Object> list = new ArrayList<>();

      int n = node.getChildCount();
      for (int i = 0; i < n; i++) {
        Xpp3Dom child = node.getChild(i);

        if (!childName.equals(child.getName())) {
          throw new YAMLException(format("child name: '%s' does not match expected name: '%s' at node %s",
              child.getName(), childName, node));
        }

        Object childValue = child.getValue();
        if (childValue == null) {
          childValue = toMap(child);
        }
        list.add(childValue);
      }

      return list;
    }
  }

  // Model elements order {
  //TODO move to polyglot-common, or to org.apache.maven:maven-model
  private static List<String> ORDER_MODEL = new ArrayList<String>(Arrays.asList(
		  "modelEncoding",
          "modelVersion",
          "parent",
          "groupId",
          "artifactId",
          "version",
          "packaging",

          "name",
          "description",
          "url",
          "inceptionYear",
          "organization",
          "licenses",
          "developers",
          "contributers",
          "mailingLists",
          "scm",
          "issueManagement",
          "ciManagement",

          "properties",
          "prerequisites",
          "modules",
          "dependencyManagement",
          "dependencies",
          "distributionManagement",
          //"repositories",
          //"pluginRepositories",
          "build",
          "profiles",
          "reporting"
          ));
  private static List<String> ORDER_DEVELOPER = new ArrayList<String>(Arrays.asList(
		  "name", "id", "email"));
  private static List<String> ORDER_CONTRIBUTOR = new ArrayList<String>(Arrays.asList(
		  "name", "id", "email"));
  private static List<String> ORDER_DEPENDENCY = new ArrayList<String>(Arrays.asList(
		  "groupId", "artifactId", "version", "type", "classifier", "scope"));
  private static List<String> ORDER_PLUGIN = new ArrayList<String>(Arrays.asList(
		  "groupId", "artifactId", "version", "inherited", "extensions", "configuration"));
  //}

  /*
   * Change the default order. Important data goes first.
   */
  @Override
  protected Set<Property> getProperties(Class<? extends Object> type)
          throws IntrospectionException {
    if (type.isAssignableFrom(Model.class)) {
      return sortTypeWithOrder(type, ORDER_MODEL);
    } else if (type.isAssignableFrom(Developer.class)) {
      return sortTypeWithOrder(type, ORDER_DEVELOPER);
    } else if (type.isAssignableFrom(Contributor.class)) {
      return sortTypeWithOrder(type, ORDER_CONTRIBUTOR);
    }  else if (type.isAssignableFrom(Dependency.class)) {
      return sortTypeWithOrder(type, ORDER_DEPENDENCY);
    }  else if (type.isAssignableFrom(Plugin.class)) {
      return sortTypeWithOrder(type, ORDER_PLUGIN);
    } else {
      return super.getProperties(type);
    }
  }

  private Set<Property> sortTypeWithOrder(Class<? extends Object> type, List<String> order)
          throws IntrospectionException {
      Set<Property> standard = super.getProperties(type);
      Set<Property> sorted = new TreeSet<Property>(new ModelPropertyComparator(order));
      sorted.addAll(standard);
      return sorted;
  }

  private class ModelPropertyComparator implements Comparator<Property> {
    private List<String> names;

    public ModelPropertyComparator(List<String> names) {
      this.names = names;
    }

    public int compare(Property o1, Property o2) {
      // important go first
      for (String name : names) {
        int c = compareByName(o1, o2, name);
        if (c != 0) {
          return c;
        }
      }
      // all the rest
      return o1.compareTo(o2);
    }

    private int compareByName(Property o1, Property o2, String name) {
      if (o1.getName().equals(name)) {
        return -1;
      } else if (o2.getName().equals(name)) {
        return 1;
      }
      return 0;// compare further
    }
  }
}

```

The errors are triggered in the following specific lines:

<error_lines>
```java
protected Set<Property> getProperties(Class<? extends Object> type)
```
```java
public ModelRepresenter() {
```
```java
protected Set<Property> getProperties(Class<? extends Object> type)
```
```java
public ModelRepresenter() {
```
</error_lines>

The API of the dependency has changed. Here are the relevant changes:

     Method org.yaml.snakeyaml.representer.Representer has been removed in the new version of the dependency.
     Type reference org.yaml.snakeyaml.representer.Representer(org.yaml.snakeyaml.DumperOptions) has been added in the new version of the dependency.
     Constructor org.yaml.snakeyaml.representer.Representer() has been removed in the new version of the dependency.
     Constructor org.yaml.snakeyaml.representer.Representer(org.yaml.snakeyaml.DumperOptions) has been added in the new version of the dependency.
     Method org.yaml.snakeyaml.introspector.PropertyUtils.getProperties(java.lang.Class,org.yaml.snakeyaml.introspector.BeanAccess) has been removed in the new version of the dependency.
     Method org.yaml.snakeyaml.representer.Representer.getProperties(java.lang.Class) has been added in the new version of the dependency.
     Method org.yaml.snakeyaml.introspector.PropertyUtils.getProperties(java.lang.Class,org.yaml.snakeyaml.introspector.BeanAccess) has been added in the new version of the dependency.
     Method org.yaml.snakeyaml.introspector.PropertyUtils.getProperties(java.lang.Class) has been removed in the new version of the dependency.
     Method org.yaml.snakeyaml.representer.Representer.getProperties(java.lang.Class) has been removed in the new version of the dependency.
     Method org.yaml.snakeyaml.introspector.PropertyUtils.getProperties(java.lang.Class) has been added in the new version of the dependency.
     Method org.yaml.snakeyaml.TypeDescription.getProperties() has been added in the new version of the dependency.

Additional error information:

<error_information>
[ERROR] /polyglot-maven/polyglot-yaml/src/main/java/org/sonatype/maven/polyglot/yaml/ModelRepresenter.java:[218,27] Exception IntrospectionException is not compatible with throws clause in Representer.getProperties(Class<? extends Object>)

[ERROR] /polyglot-maven/polyglot-yaml/src/main/java/org/sonatype/maven/polyglot/yaml/ModelRepresenter.java:[37,10] Implicit super constructor Representer() is undefined. Must explicitly invoke another constructor

[ERROR] /polyglot-maven/polyglot-yaml/src/main/java/org/sonatype/maven/polyglot/yaml/ModelRepresenter.java:[218,27] Exception IntrospectionException is not compatible with throws clause in Representer.getProperties(Class<? extends Object>)

[ERROR] /polyglot-maven/polyglot-yaml/src/main/java/org/sonatype/maven/polyglot/yaml/ModelRepresenter.java:[37,10] Implicit super constructor Representer() is undefined. Must explicitly invoke another constructor
<error_information>

Your task is to fix the issue by modifying only the client code. Follow these steps:

1. Analyze the problem and propose changes by wrapping the work inside fix_planning tags. This analysis is for your internal use only and will not be included in the final output. In your analysis:
   a. Quote relevant parts of the code and API changes
   b. Identify the specific API changes causing the issue
   c. List the affected lines of code
   d. Propose potential fixes for each affected line
   e. Consider any potential side effects of the proposed changes
   f. Explicitly check if the proposed changes adhere to all the given constraints
   g. Provide a final summary of the chosen fix and why it's the best solution

2. Apply the fix to the Java code.

3. Output the complete, fixed Java class in a fenced code block. This should be the only visible output in your response.

Constraints:
1. Do not change the function signature of any method.
2. You may create variables if it simplifies the code.
3. Remove the @Override annotation if and only if the method no longer overrides a method in the updated dependency version.
4. If fixing the issue requires addressing missing imports, ensure the correct package or class is used in accordance with the newer dependency version.
5. Do not remove any existing code unless it directly causes a compilation or functionality error.
6. Include all code, even unchanged portions, in your final output.
7. Do not use placeholder comments like "// ... (rest of the code remains unchanged)".

Your final output should only contain the complete, fixed Java class in a fenced code block, without any explanations or analysis visible. The <fix_planning> section is for your internal use only.

Example output structure:

```java
[Complete, fixed Java class]
```

Please proceed with your analysis and solution.
