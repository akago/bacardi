<fix_planning>
a. Code and API changes:
- The code uses `liquibase.util.StringUtils.trimToNull(statement.getTablespace())`.
- The API changes indicate that `liquibase.util.StringUtils` has been removed, and `liquibase.util.StringUtils.trimToNull` has been replaced by `liquibase.util.StringUtil.trimToNull` and `liquibase.repackaged.org.apache.commons.lang3.StringUtils.trimToNull`.

b. Specific API changes causing the issue:
- The removal of `liquibase.util.StringUtils` and `liquibase.util.StringUtils.trimToNull`.

c. Affected lines of code:
- `if (StringUtils.trimToNull(statement.getTablespace()) != null && database.supportsTablespaces()) {`
- `import liquibase.util.StringUtils;`

d. Proposed fixes:
- Replace `liquibase.util.StringUtils` with `liquibase.util.StringUtil` and use `liquibase.util.StringUtil.trimToNull`.
- Replace `liquibase.util.StringUtils` with `liquibase.repackaged.org.apache.commons.lang3.StringUtils` and use `liquibase.repackaged.org.apache.commons.lang3.StringUtils.trimToNull`.

e. Potential side effects:
- Using `liquibase.util.StringUtil` seems like the most direct replacement within the Liquibase library itself.
- Using `liquibase.repackaged.org.apache.commons.lang3.StringUtils` might introduce a dependency on a repackaged library, which could be less desirable if `liquibase.util.StringUtil` is available.

f. Adherence to constraints:
- The proposed changes do not change function signatures.
- The proposed changes involve replacing the import statement and the method call, which adheres to the constraints.
- The `@Override` annotation remains valid.

g. Final summary:
The best solution is to replace `liquibase.util.StringUtils` with `liquibase.util.StringUtil` and use `liquibase.util.StringUtil.trimToNull`. This is because it uses the Liquibase's own utility class, avoiding a dependency on a repackaged library.
</fix_planning>

```java
package liquibase.ext.mssql.sqlgenerator;

import liquibase.database.Database;
import liquibase.ext.mssql.database.MSSQLDatabase;
import liquibase.ext.mssql.statement.AddPrimaryKeyStatementMSSQL;
import liquibase.sql.Sql;
import liquibase.sql.UnparsedSql;
import liquibase.sqlgenerator.SqlGeneratorChain;
import liquibase.sqlgenerator.core.AddPrimaryKeyGenerator;
import liquibase.statement.core.AddPrimaryKeyStatement;
import liquibase.structure.core.Index;
import liquibase.util.StringUtil;

public class AddPrimaryKeyGeneratorMSSQL extends AddPrimaryKeyGenerator {
  @Override
  public int getPriority() {
    return 15;
  }

  /**
   * Conditionally executes to extension's custom Primary Key SQL generation process if statement is the
   * AddPrimaryKeyStatementMSSQL implementation and the custom attribute (fillFactor) is set.
   *
   * Otherwise, defers to default liquibase implementation.
   *
   * @param statement
   * @param database
   * @param sqlGeneratorChain
   * @return
   */
  @Override
  public Sql[] generateSql(AddPrimaryKeyStatement statement, Database database, SqlGeneratorChain sqlGeneratorChain) {
    if (statement instanceof AddPrimaryKeyStatementMSSQL && ((AddPrimaryKeyStatementMSSQL) statement).getFillFactor() != null) {
      return generateMSSQLSql((AddPrimaryKeyStatementMSSQL)statement, database, sqlGeneratorChain);
    }

    return super.generateSql(statement, database, sqlGeneratorChain);
  }

  /**
   * The extension's implementation is essentially a copy/paste of the default implementation, with the following changes:
   *
   * 1) Removed other database platform specific logic other than MSSQL (purely to simplify)
   *
   * 2) Added support for setting fillFactor
   *
   * @param statement
   * @param database
   * @param sqlGeneratorChain
   * @return
   */
  private Sql[] generateMSSQLSql(AddPrimaryKeyStatementMSSQL statement, Database database, SqlGeneratorChain sqlGeneratorChain) {
    String sql;
    if (statement.getConstraintName() == null) {
      sql = "ALTER TABLE " + database.escapeTableName(statement.getCatalogName(), statement.getSchemaName(), statement.getTableName()) + " ADD PRIMARY KEY (" + database.escapeColumnNameList(statement.getColumnNames()) + ")";
    } else {
      sql = "ALTER TABLE " + database.escapeTableName(statement.getCatalogName(), statement.getSchemaName(), statement.getTableName()) + " ADD CONSTRAINT " + database.escapeConstraintName(statement.getConstraintName())+" PRIMARY KEY";
      if (!statement.isClustered()) {
        sql += " NONCLUSTERED";
      }
      sql += " (" + database.escapeColumnNameList(statement.getColumnNames()) + ")";
    }

    // the only new feature being added is support for fillFactor
    sql += " WITH (FILLFACTOR = " + statement.getFillFactor() + ")";

    if (StringUtil.trimToNull(statement.getTablespace()) != null && database.supportsTablespaces()) {
      sql += " ON "+statement.getTablespace();
    }

    if (statement.getForIndexName() != null) {
      sql += " USING INDEX "+database.escapeObjectName(statement.getForIndexCatalogName(), statement.getForIndexSchemaName(), statement.getForIndexName(), Index.class);
    }

    return new Sql[] {
        new UnparsedSql(sql, getAffectedPrimaryKey(statement))
    };
  }

  @Override
  public boolean supports(AddPrimaryKeyStatement statement, Database database) {
    return database instanceof MSSQLDatabase;
  }

}
```
