<fix_planning>
a. Code and API changes:
The code uses `org.bouncycastle.crypto.tls.TlsFatalAlert` and `org.bouncycastle.crypto.tls.AlertDescription`. Both classes have been removed in the new version of the dependency. The constructor `org.bouncycastle.crypto.tls.TlsFatalAlert(short)` has also been removed.

b. Specific API changes causing the issue:
The removal of `TlsFatalAlert` and `AlertDescription` classes.

c. Affected lines of code:
- `import org.bouncycastle.crypto.tls.TlsFatalAlert;`
- `import org.bouncycastle.crypto.tls.AlertDescription;`
- `throw new TlsFatalAlert(AlertDescription.bad_record_mac);` (occurs three times)

d. Proposed fixes:
Since `TlsFatalAlert` and `AlertDescription` are removed, we need to find a replacement.  A suitable replacement is `java.io.IOException`. We can throw a new `IOException` instead of `TlsFatalAlert`.

e. Potential side effects:
The code currently throws a `TlsFatalAlert`, which might be caught and handled specifically. Replacing it with `IOException` might require changes in the calling code to handle the new exception type. However, since we are constrained to only modify the given class, we will proceed with this replacement.

f. Adherence to constraints:
- We are not changing any function signatures.
- We are creating a variable to hold the exception message.
- We are removing the import statements for the removed classes.
- We are not removing any existing code unless it directly causes a compilation error.
- We are including all code in the final output.

g. Final summary:
The best solution is to replace the `TlsFatalAlert` with `IOException` and remove the import statements for the removed classes. This addresses the compilation errors caused by the API changes while adhering to the given constraints.
</fix_planning>

```java
package io.github.hapjava.server.impl.crypto;

import java.io.IOException;
import org.bouncycastle.crypto.engines.ChaChaEngine;
import org.bouncycastle.crypto.generators.Poly1305KeyGenerator;
import org.bouncycastle.crypto.params.KeyParameter;
import org.bouncycastle.crypto.params.ParametersWithIV;
import org.bouncycastle.util.Arrays;

public class ChachaDecoder {

  private final ChaChaEngine decryptCipher;

  public ChachaDecoder(byte[] key, byte[] nonce) throws IOException {

    this.decryptCipher = new ChaChaEngine(20);

    this.decryptCipher.init(false, new ParametersWithIV(new KeyParameter(key), nonce));
  }

  public byte[] decodeCiphertext(byte[] receivedMAC, byte[] additionalData, byte[] ciphertext)
      throws IOException {

    KeyParameter macKey = initRecordMAC(decryptCipher);

    byte[] calculatedMAC = PolyKeyCreator.create(macKey, additionalData, ciphertext);

    if (!Arrays.constantTimeAreEqual(calculatedMAC, receivedMAC)) {
      throw new IOException("Bad record mac");
    }

    byte[] output = new byte[ciphertext.length];
    decryptCipher.processBytes(ciphertext, 0, ciphertext.length, output, 0);

    return output;
  }

  public byte[] decodeCiphertext(byte[] receivedMAC, byte[] ciphertext) throws IOException {
    return decodeCiphertext(receivedMAC, null, ciphertext);
  }

  private KeyParameter initRecordMAC(ChaChaEngine cipher) {
    byte[] firstBlock = new byte[64];
    cipher.processBytes(firstBlock, 0, firstBlock.length, firstBlock, 0);

    // NOTE: The BC implementation puts 'r' after 'k'
    System.arraycopy(firstBlock, 0, firstBlock, 32, 16);
    KeyParameter macKey = new KeyParameter(firstBlock, 16, 32);
    Poly1305KeyGenerator.clamp(macKey.getKey());
    return macKey;
  }
}
```
