<fix_planning>
a. Code and API changes:
The code uses `org.bouncycastle.crypto.tls.AlertDescription` and `org.bouncycastle.crypto.tls.TlsFatalAlert`. Both classes and the constructor `TlsFatalAlert(short)` have been removed in the new version of the dependency.

b. Specific API changes causing the issue:
The removal of `org.bouncycastle.crypto.tls.AlertDescription` and `org.bouncycastle.crypto.tls.TlsFatalAlert`, along with the constructor `TlsFatalAlert(short)`, are causing compilation errors.

c. Affected lines of code:
- `import org.bouncycastle.crypto.tls.AlertDescription;`
- `import org.bouncycastle.crypto.tls.TlsFatalAlert;`
- `throw new TlsFatalAlert(AlertDescription.bad_record_mac);` (occurs three times)

d. Proposed fixes:
Since `org.bouncycastle.crypto.tls.AlertDescription` and `org.bouncycastle.crypto.tls.TlsFatalAlert` are removed, we need to find a replacement for throwing the exception when the MAC check fails.  A general `IOException` can be thrown instead.

e. Potential side effects:
Replacing `TlsFatalAlert` with `IOException` might change the specific exception type caught by callers, but since the original code already declares that the methods throw `IOException`, this change should be safe.

f. Adherence to constraints:
1. The function signatures of all methods are preserved.
2. Variables can be created if needed.
3. `@Override` is not used, so no need to remove it.
4. The correct package or class will be used if fixing the issue requires addressing missing imports.
5. No existing code is removed unless it directly causes a compilation or functionality error.
6. All code, even unchanged portions, will be included in the final output.

g. Final summary:
The best solution is to replace the `TlsFatalAlert` with a general `IOException`. This addresses the compilation errors caused by the removed classes and constructor while maintaining the existing functionality and adhering to all constraints. The imports for the removed classes are also removed.

</fix_planning>

```java
package io.github.hapjava.server.impl.crypto;

import java.io.IOException;
import org.bouncycastle.crypto.engines.ChaChaEngine;
import org.bouncycastle.crypto.generators.Poly1305KeyGenerator;
import org.bouncycastle.crypto.params.KeyParameter;
import org.bouncycastle.crypto.params.ParametersWithIV;
import org.bouncycastle.util.Arrays;

public class ChachaDecoder {

  private final ChaChaEngine decryptCipher;

  public ChachaDecoder(byte[] key, byte[] nonce) throws IOException {

    this.decryptCipher = new ChaChaEngine(20);

    this.decryptCipher.init(false, new ParametersWithIV(new KeyParameter(key), nonce));
  }

  public byte[] decodeCiphertext(byte[] receivedMAC, byte[] additionalData, byte[] ciphertext)
      throws IOException {

    KeyParameter macKey = initRecordMAC(decryptCipher);

    byte[] calculatedMAC = PolyKeyCreator.create(macKey, additionalData, ciphertext);

    if (!Arrays.constantTimeAreEqual(calculatedMAC, receivedMAC)) {
      throw new IOException("Bad record mac");
    }

    byte[] output = new byte[ciphertext.length];
    decryptCipher.processBytes(ciphertext, 0, ciphertext.length, output, 0);

    return output;
  }

  public byte[] decodeCiphertext(byte[] receivedMAC, byte[] ciphertext) throws IOException {
    return decodeCiphertext(receivedMAC, null, ciphertext);
  }

  private KeyParameter initRecordMAC(ChaChaEngine cipher) {
    byte[] firstBlock = new byte[64];
    cipher.processBytes(firstBlock, 0, firstBlock.length, firstBlock, 0);

    // NOTE: The BC implementation puts 'r' after 'k'
    System.arraycopy(firstBlock, 0, firstBlock, 32, 16);
    KeyParameter macKey = new KeyParameter(firstBlock, 16, 32);
    Poly1305KeyGenerator.clamp(macKey.getKey());
    return macKey;
  }
}
```
