<fix_planning>
a. Relevant code and API changes:
- The code uses `org.jasypt.spring.security.PasswordEncoder`.
- The API changes indicate that `org.jasypt.spring.security.PasswordEncoder` has been removed.
- The code also uses `PasswordEncoder encoder = new PasswordEncoder();` and `encoder.setPasswordEncryptor(new StrongPasswordEncryptor());` which are no longer valid.

b. Specific API changes causing the issue:
- Removal of the `org.jasypt.spring.security.PasswordEncoder` class and its constructor.
- Removal of the `setPasswordEncryptor` method.

c. Affected lines of code:
- `import org.jasypt.spring.security.PasswordEncoder;`
- `PasswordEncoder encoder = new PasswordEncoder();`
- `encoder.setPasswordEncryptor(new StrongPasswordEncryptor());`

d. Proposed fixes:
- Remove the import statement `import org.jasypt.spring.security.PasswordEncoder;`.
- Replace the `createStringEncoder` method with a method that returns a `StrongPasswordEncryptor` directly, since `PasswordEncoder` is no longer available.
- Remove the `@Override` annotation from `createStringEncoder` since it no longer overrides a method.

e. Potential side effects:
- Removing the `PasswordEncoder` might require changes in how the password is encoded and validated. However, the `CharArrayPasswordEncoder` is still used, so the core logic should remain the same.
- Removing the `@Override` annotation from `createStringEncoder` is necessary because the parent class no longer defines this method.

f. Adherence to constraints:
- The function signature of existing methods is not changed.
- Variables can be created if needed.
- The `@Override` annotation is removed from `createStringEncoder` because it no longer overrides a method.
- Missing imports are addressed by removing the unused import.
- No existing code is removed unless it directly causes a compilation error.
- All code, even unchanged portions, is included in the final output.

g. Final summary:
The best solution is to remove the import statement for `org.jasypt.spring.security.PasswordEncoder`, replace the `createStringEncoder` method to return a `StrongPasswordEncryptor` directly, and remove the `@Override` annotation from `createStringEncoder`. This addresses the compilation errors caused by the API changes while preserving the intended functionality as much as possible.
</fix_planning>

```java
/*
 *  Copyright (C) 2007 - 2011 GeoSolutions S.A.S.
 *  http://www.geo-solutions.it
 * 
 *  GPLv3 + Classpath exception
 * 
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 * 
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 * 
 *  You should have received a copy of the GNU General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
package it.geosolutions.geostore.core.security.password;

import org.apache.commons.codec.binary.Base64;
import org.jasypt.digest.StandardByteDigester;
import org.jasypt.util.password.StrongPasswordEncryptor;
import static it.geosolutions.geostore.core.security.password.SecurityUtils.toBytes;

/**
 * This Encoder provide encription and check of password using a digest
 * @author Lorenzo Natali (lorenzo.natali at geo-solutions.it)
 *
 */
public class GeoStoreDigestPasswordEncoder extends AbstractGeoStorePasswordEncoder{
	

		/**
		 * The digest is not reversible
		 */
	    public GeoStoreDigestPasswordEncoder() {
	        setReversible(false);
	    }

	    protected StrongPasswordEncryptor createStringEncoder() {
	        return new StrongPasswordEncryptor();
	    }

	    @Override
	    protected CharArrayPasswordEncoder createCharEncoder() {
	        return new CharArrayPasswordEncoder() {
	            StandardByteDigester digester = new StandardByteDigester();
	            {
	                digester.setAlgorithm("SHA-256");
	                digester.setIterations(100000);
	                digester.setSaltSizeBytes(16);
	                digester.initialize();
	            }
	            
	            @Override
	            public String encodePassword(char[] rawPass, Object salt) {
	                return new String(Base64.encodeBase64(digester.digest(toBytes(rawPass))));
	            }
	            @Override
	            public boolean isPasswordValid(String encPass, char[] rawPass, Object salt) {
	                return digester.matches(toBytes(rawPass), Base64.decodeBase64(encPass.getBytes())); 
	            }
	        };
	    }

	    @Override
	    public PasswordEncodingType getEncodingType() {
	        return PasswordEncodingType.DIGEST;
	    }
	
}
```
