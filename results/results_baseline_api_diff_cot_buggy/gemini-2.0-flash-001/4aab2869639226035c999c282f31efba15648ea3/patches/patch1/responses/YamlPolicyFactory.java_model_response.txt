<fix_planning>
a. Relevant parts of the code and API changes:
- Code: `new Storages().newStorage(sub.string("type"), Yaml.createYamlInput(sub.toString()).readYamlMapping())`
- API Changes: `Class com.artipie.asto.factory.Storages has been removed in the new version of the dependency.` and `Method com.artipie.asto.factory.StorageFactory.newStorage(com.artipie.asto.factory.Config) has been added in the new version of the dependency.`

b. Specific API changes causing the issue:
The `Storages` class has been removed, and the `newStorage` method now expects a `Config` object instead of a string and a `YamlMapping`.

c. Affected lines of code:
- Line 43: `new Storages().newStorage(`

d. Proposed potential fixes:
Since `Storages` class is removed, we need to find an alternative way to create a storage. The API changes suggest that `newStorage` method now exists in `StorageFactory` and accepts a `Config` object. We can try to instantiate the appropriate `StorageFactory` directly (e.g., `FileStorageFactory`, `S3StorageFactory`, etc.) based on the `type` and then call `newStorage` with a `Config` object created from the `sub` configuration.

e. Potential side effects of the proposed changes:
We need to determine the correct `StorageFactory` based on the `type` string. This might require adding a switch statement or a similar mechanism. We also need to ensure that the `Config` object is created correctly from the `sub` configuration.

f. Adherence to constraints:
- We are not changing the function signature of `getPolicy`.
- We might need to create variables to hold the `StorageFactory` and `Config` objects.
- We are not removing any existing code unless it directly causes a compilation error.

g. Final summary of the chosen fix:
The best solution is to replace the usage of the removed `Storages` class with direct instantiation of the appropriate `StorageFactory` based on the `type` specified in the configuration. We will use a switch statement to determine the correct factory and then call the `newStorage` method with a `Config` object created from the `sub` configuration. This approach aligns with the new API and addresses the compilation errors.
</fix_planning>

```java
/*
 * The MIT License (MIT) Copyright (c) 2020-2022 artipie.com
 * https://github.com/artipie/http/blob/master/LICENSE.txt
 */
package com.artipie.security.policy;

import com.amihaiemil.eoyaml.Yaml;
import com.artipie.asto.blocking.BlockingStorage;
import com.artipie.asto.factory.Config;
import com.artipie.asto.factory.StorageFactory;
import com.artipie.asto.fs.FileStorageFactory;
import com.artipie.asto.s3.S3StorageFactory;
import java.io.IOException;
import java.io.UncheckedIOException;

/**
 * Policy factory to create {@link YamlPolicy}. Yaml policy is read from storage, and it's required
 * to describe this storage in the configuration. Configuration format is the following:
 *
 * policy:
 *   type: yaml_policy
 *   storage:
 *     type: fs
 *     path: /some/path
 *
 * The storage itself is expected to have yaml files with permissions in the following structure:
 *
 * ..
 * ├── roles.yaml
 * ├── users
 * │   ├── david.yaml
 * │   ├── jane.yaml
 * │   ├── ...
 *
 * @since 1.2
 */
@ArtipiePolicyFactory("yaml_policy")
public final class YamlPolicyFactory implements PolicyFactory {

    @Override
    public Policy<?> getPolicy(final PolicyConfig config) {
        final PolicyConfig sub = config.config("storage");
        try {
            final String type = sub.string("type");
            final StorageFactory factory;
            switch (type) {
                case "fs":
                    factory = new FileStorageFactory();
                    break;
                case "s3":
                    factory = new S3StorageFactory();
                    break;
                default:
                    throw new IllegalArgumentException("Unknown storage type: " + type);
            }
            final Config storageConfig = new Config.Yaml(Yaml.createYamlInput(sub.toString()).readYamlMapping());
            return new YamlPolicy(
                new BlockingStorage(
                    factory.newStorage(storageConfig)
                )
            );
        } catch (final IOException err) {
            throw new UncheckedIOException(err);
        }
    }
}
```
