<fix_planning>
a. Relevant parts of the code and API changes:
- Code: `import org.cactoos.scalar.IoCheckedScalar;` and
  ```java
  return new IoCheckedScalar<>(
            new Reduced<>(
                Wallet::merge,
                new Mapped<>(
                    c -> c::wallet,
                    new Sorted<>(new Copies(id, this))
                )
            )
        ).value();
  ```
- API Changes: `Class org.cactoos.scalar.IoCheckedScalar has been removed in the new version of the dependency.` and `Constructor org.cactoos.scalar.IoCheckedScalar(org.cactoos.Scalar) has been removed in the new version of the dependency.`

b. Specific API changes causing the issue:
The class `org.cactoos.scalar.IoCheckedScalar` and its constructor have been removed.

c. Affected lines of code:
- `import org.cactoos.scalar.IoCheckedScalar;`
- The line containing `new IoCheckedScalar<>(...)`

d. Proposed potential fixes:
Since `IoCheckedScalar` is removed, we need to find an alternative. `IoCheckedScalar` was used to wrap a `Scalar` and throw an `IOException` if the scalar's `value()` method threw an exception. We can replace it with a try-catch block.

e. Potential side effects of the proposed changes:
The try-catch block might make the code slightly longer, but it should not affect the functionality.

f. Adherence to constraints:
- We are not changing any function signatures.
- We are creating a variable to hold the result of the `Reduced` operation.
- We are removing the import statement that is no longer needed.
- We are including all code in the final output.

g. Final summary:
The best solution is to replace the `IoCheckedScalar` with a try-catch block to handle potential `IOExceptions` thrown by the `Reduced` scalar's `value()` method. This approach directly addresses the removal of `IoCheckedScalar` and maintains the original functionality of the code.
</fix_planning>

```java
/*
 * The MIT License (MIT)
 *
 * Copyright (c) 2018-2023 Yegor Bugayenko
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included
 * in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
package io.zold.api;

import java.io.IOException;
import java.util.Iterator;
import org.cactoos.iterable.Mapped;
import org.cactoos.iterable.Sorted;
import org.cactoos.scalar.Reduced;
import org.cactoos.Scalar;

/**
 * Network implementation.
 *
 * @since 0.1
 * @todo #5:30min We must figure out how to 'load' some network. Loading the
 *  network will be loading a local JSON file that contains data on all
 *  remote nodes that we know about; we must have a pre configured set of
 *  remote nodes built in too. See whitepaper for details.
 */
public final class RtNetwork implements Network {

    /**
     * {@link Remote} nodes.
     */
    private final Iterable<Remote> nodes;

    /**
     * Constructor.
     * @param remotes Remotes of the network
     */
    RtNetwork(final Iterable<Remote> remotes) {
        this.nodes =  remotes;
    }

    @Override
    public void push(final Wallet wallet) {
        this.nodes.forEach(
            remote -> remote.push(wallet)
        );
    }

    @Override
    public Wallet pull(final long id) throws IOException {
        final Scalar<Wallet> reduced = new Reduced<>(
            Wallet::merge,
            new Mapped<>(
                c -> c::wallet,
                new Sorted<>(new Copies(id, this))
            )
        );
        try {
            return reduced.value();
        } catch (final Exception ex) {
            throw new IOException(ex);
        }
    }

    @Override
    public Iterator<Remote> iterator() {
        return this.nodes.iterator();
    }
}
```
